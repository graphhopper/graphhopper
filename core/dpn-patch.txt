### Eclipse Workspace Patch 1.0
#P GraphHopper
Index: core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnNode.java
===================================================================
--- core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnNode.java	(revision 2400)
+++ core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnNode.java	(working copy)
@@ -23,12 +23,13 @@
 import org.opengis.geometry.MismatchedDimensionException;
 import org.opengis.referencing.FactoryException;
 import org.opengis.referencing.operation.TransformException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import uk.co.ordnancesurvey.api.srs.LatLong;
 import uk.co.ordnancesurvey.api.srs.OpenCoordConverter;
 
 import com.graphhopper.reader.Node;
-import com.graphhopper.reader.osgb.OSITNElement;
 import com.graphhopper.util.PointAccess;
 
 /**
@@ -37,132 +38,144 @@
  * 
  * @author Nop
  */
-public class OsDpnNode extends OSITNElement implements Node {
-	private double lat;
-	private double lon;
+public class OsDpnNode extends OsDpnElement implements Node {
+    private double lat;
+    private double lon;
+
+    private static final Logger logger = LoggerFactory
+            .getLogger(OsDpnElement.class);
 
-	public static OsDpnNode create(long id, XMLStreamReader parser)
-			throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
-		// int attributeCount = parser.getAttributeCount();
-		// for (int i = 0; i < attributeCount; i++) {
-		// QName attributeName = parser.getAttributeName(i);
-		// System.err.println("QName:" + attributeName);
-		// }
-		OsDpnNode node = new OsDpnNode(id);
+    public static OsDpnNode create(String id, XMLStreamReader parser)
+            throws XMLStreamException, MismatchedDimensionException,
+            FactoryException, TransformException {
+        // int attributeCount = parser.getAttributeCount();
+        // for (int i = 0; i < attributeCount; i++) {
+        // QName attributeName = parser.getAttributeName(i);
+        // System.err.println("QName:" + attributeName);
+        // }
+        System.out.println("OsDpnNode.create()");
+        OsDpnNode node = new OsDpnNode(id);
 
-		parser.nextTag();
-		node.readTags(parser);
-		return node;
-	}
+        parser.nextTag();
+        node.readTags(parser);
+        return node;
+    }
 
-	public OsDpnNode(long id, PointAccess pointAccess, int accessId) {
-		super(id, NODE);
+    public OsDpnNode(String id, PointAccess pointAccess, int accessId) {
+        super(id, NODE);
 
-		this.lat = pointAccess.getLatitude(accessId);
-		this.lon = pointAccess.getLongitude(accessId);
-		if (pointAccess.is3D())
-			setTag("ele", pointAccess.getElevation(accessId));
-	}
+        this.lat = pointAccess.getLatitude(accessId);
+        this.lon = pointAccess.getLongitude(accessId);
+        if (pointAccess.is3D())
+            setTag("ele", pointAccess.getElevation(accessId));
+    }
 
-	public OsDpnNode(long id) {
-		super(id, NODE);
+    public OsDpnNode(String id) {
+        super(id, NODE);
 
-	}
+    }
 
-	public double getLat() {
-		return lat;
-	}
+    @Override
+    public double getLat() {
+        return lat;
+    }
 
-	public double getLon() {
-		return lon;
-	}
+    @Override
+    public double getLon() {
+        return lon;
+    }
 
-	public double getEle() {
-		Object ele = getTags().get("ele");
-		if (ele == null)
-			// return Double.NaN;
-			return 1d;
-		return (Double) ele;
-	}
+    public double getEle() {
+        Object ele = getTags().get("ele");
+        if (ele == null)
+            // return Double.NaN;
+            return 1d;
+        return (Double) ele;
+    }
 
-	@Override
-	public void setTag(String name, Object value) {
-		if ("ele".equals(name)) {
-			if (value == null)
-				value = null;
-			else if (value instanceof String) {
-				String str = (String) value;
-				str = str.trim().replaceAll("\\,", ".");
-				if (str.isEmpty())
-					value = null;
-				else
-					try {
-						value = Double.parseDouble(str);
-					} catch (NumberFormatException ex) {
-						return;
-					}
-			} else
-				// force cast
-				value = ((Number) value).doubleValue();
-		}
-		super.setTag(name, value);
-	}
+    @Override
+    public void setTag(String name, Object value) {
+        if ("ele".equals(name)) {
+            if (value == null)
+                value = null;
+            else if (value instanceof String) {
+                String str = (String) value;
+                str = str.trim().replaceAll("\\,", ".");
+                if (str.isEmpty())
+                    value = null;
+                else
+                    try {
+                        value = Double.parseDouble(str);
+                    } catch (NumberFormatException ex) {
+                        return;
+                    }
+            } else
+                // force cast
+                value = ((Number) value).doubleValue();
+        }
+        super.setTag(name, value);
+    }
 
-	@Override
-	public String toString() {
-		StringBuilder txt = new StringBuilder();
-		txt.append("Node: ");
-		txt.append(getId());
-		txt.append(" lat=");
-		txt.append(getLat());
-		txt.append(" lon=");
-		txt.append(getLon());
-		if (!getTags().isEmpty()) {
-			txt.append("\n");
-			txt.append(tagsToString());
-		}
-		return txt.toString();
-	}
+    @Override
+    public String toString() {
+        StringBuilder txt = new StringBuilder();
+        txt.append("Node: ");
+        txt.append(getId());
+        txt.append(" lat=");
+        txt.append(getLat());
+        txt.append(" lon=");
+        txt.append(getLon());
+        if (!getTags().isEmpty()) {
+            txt.append("\n");
+            txt.append(tagsToString());
+        }
+        return txt.toString();
+    }
 
-	@Override
-	protected void parseCoords(String elementText) throws MismatchedDimensionException, FactoryException, TransformException {
-		String[] split = elementText.split(",");
+    @Override
+    public void parseCoords(String elementText)
+            throws MismatchedDimensionException, FactoryException,
+            TransformException {
+        String elementSeparator = " ";
+        parseCoordinateString(elementText, elementSeparator);
+    }
 
-		Double easting = Double.parseDouble(split[0]);
-		Double northing = Double.parseDouble(split[1]);
-		LatLong wgs84 = OpenCoordConverter.toWGS84(easting, northing);
-		lat = wgs84.getLatAngle();
-		lon = wgs84.getLongAngle();
-		System.err.println(toString());
-	}
+    public void parseCoordinateString(String elementText,
+            String elementSeparator) throws MismatchedDimensionException,
+            FactoryException, TransformException {
+        String[] split = elementText.split(elementSeparator);
 
-	@Override
-	protected void parseNetworkMember(String elementText) {
-		throw new UnsupportedOperationException("Nodes should not have members");
-	}
+        if (3 == split.length) {
+            setTag("ele", split[2]);
+        }
+        Double easting = Double.parseDouble(split[0]);
+        Double northing = Double.parseDouble(split[1]);
+        LatLong wgs84 = OpenCoordConverter.toWGS84(easting, northing);
+        lat = wgs84.getLatAngle();
+        lon = wgs84.getLongAngle();
+        if (logger.isDebugEnabled())
+            logger.debug(toString());
+    }
 
-	@Override
-	protected void addDirectedNode(String nodeId, String grade, String orientation) {
-		throw new UnsupportedOperationException(
-				"Nodes should not have directed nodes");
-	}
-	
-	@Override
-	protected void addDirectedLink(String nodeId, String orientation) {
-		throw new UnsupportedOperationException(
-				"Nodes should not have directed links");
-	}
+    @Override
+    protected void parseNetworkMember(String elementText) {
+        throw new UnsupportedOperationException("Nodes should not have members");
+    }
 
-	@Override
-	protected void parseCoordinateString(String elementText,
-			String elementSeparator) {
-		throw new UnsupportedOperationException();
-		
-	}
+    @Override
+    protected void addNode(String nodeId) {
+        throw new UnsupportedOperationException(
+                "Nodes should not have directed nodes");
+    }
 
-	@Override
-	protected void parseCoords(int dimensions, String lineDefinition) {
-		throw new UnsupportedOperationException();
-	}
+    @Override
+    protected void addDirectedLink(String nodeId, String orientation) {
+        throw new UnsupportedOperationException(
+                "Nodes should not have directed links");
+    }
+
+    protected void parseCoords(int dimensions, String lineDefinition) {
+        throw new UnsupportedOperationException();
+    }
 
 }
Index: core/src/main/java/com/graphhopper/reader/osgb/OSITNNode.java
===================================================================
--- core/src/main/java/com/graphhopper/reader/osgb/OSITNNode.java	(revision 2400)
+++ core/src/main/java/com/graphhopper/reader/osgb/OSITNNode.java	(working copy)
@@ -41,140 +41,156 @@
  * @author Nop
  */
 public class OSITNNode extends OSITNElement implements Node {
-	private double lat;
-	private double lon;
-	private static final Logger logger = LoggerFactory
-			.getLogger(OSITNNode.class);
-	private boolean[] clones = {false,false,false,false};
+    private double lat;
+    private double lon;
+    private static final Logger logger = LoggerFactory
+            .getLogger(OSITNNode.class);
+    private final boolean[] clones = { false, false, false, false };
+
+    public static OSITNNode create(long id, XMLStreamReader parser)
+            throws XMLStreamException, MismatchedDimensionException,
+            FactoryException, TransformException {
+        OSITNNode node = new OSITNNode(id);
 
-	public static OSITNNode create(long id, XMLStreamReader parser)
-			throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
-		OSITNNode node = new OSITNNode(id);
+        parser.nextTag();
+        node.readTags(parser);
+        return node;
+    }
 
-		parser.nextTag();
-		node.readTags(parser);
-		return node;
-	}
+    public OSITNNode(long id, PointAccess pointAccess, int accessId) {
+        super(id, NODE);
 
-	public OSITNNode(long id, PointAccess pointAccess, int accessId) {
-		super(id, NODE);
+        this.lat = pointAccess.getLatitude(accessId);
+        this.lon = pointAccess.getLongitude(accessId);
+        if (pointAccess.is3D())
+            setTag("ele", pointAccess.getElevation(accessId));
+    }
 
-		this.lat = pointAccess.getLatitude(accessId);
-		this.lon = pointAccess.getLongitude(accessId);
-		if (pointAccess.is3D())
-			setTag("ele", pointAccess.getElevation(accessId));
-	}
-	
-	public OSITNNode(long id) {
-		super(id, NODE);
+    public OSITNNode(long id, double lat, double lon) {
+        super(id, NODE);
 
-	}
+        this.lat = lat;
+        this.lon = lon;
+    }
 
-	public double getLat() {
-		return lat;
-	}
+    public OSITNNode(long id) {
+        super(id, NODE);
 
-	public double getLon() {
-		return lon;
-	}
+    }
 
-	public double getEle() {
-		Object ele = getTags().get("ele");
-		if (ele == null)
-			// return Double.NaN;
-			return 1d;
-		return (Double) ele;
-	}
+    @Override
+    public double getLat() {
+        return lat;
+    }
 
-	@Override
-	public void setTag(String name, Object value) {
-		if ("ele".equals(name)) {
-			if (value == null)
-				value = null;
-			else if (value instanceof String) {
-				String str = (String) value;
-				str = str.trim().replaceAll("\\,", ".");
-				if (str.isEmpty())
-					value = null;
-				else
-					try {
-						value = Double.parseDouble(str);
-					} catch (NumberFormatException ex) {
-						return;
-					}
-			} else
-				// force cast
-				value = ((Number) value).doubleValue();
-		}
-		super.setTag(name, value);
-	}
+    @Override
+    public double getLon() {
+        return lon;
+    }
 
-	@Override
-	public String toString() {
-		StringBuilder txt = new StringBuilder();
-		txt.append("Node: ");
-		txt.append(getId());
-		txt.append(" lat=");
-		txt.append(getLat());
-		txt.append(" lon=");
-		txt.append(getLon());
-		if (!getTags().isEmpty()) {
-			txt.append("\n");
-			txt.append(tagsToString());
-		}
-		return txt.toString();
-	}
+    public double getEle() {
+        Object ele = getTags().get("ele");
+        if (ele == null)
+            // return Double.NaN;
+            return 1d;
+        return (Double) ele;
+    }
 
-	@Override
-	public void parseCoords(String elementText) throws MismatchedDimensionException, FactoryException, TransformException {
-		String elementSeparator = ",";
-		parseCoordinateString(elementText, elementSeparator);
-	}
+    @Override
+    public void setTag(String name, Object value) {
+        if ("ele".equals(name)) {
+            if (value == null)
+                value = null;
+            else if (value instanceof String) {
+                String str = (String) value;
+                str = str.trim().replaceAll("\\,", ".");
+                if (str.isEmpty())
+                    value = null;
+                else
+                    try {
+                        value = Double.parseDouble(str);
+                    } catch (NumberFormatException ex) {
+                        return;
+                    }
+            } else
+                // force cast
+                value = ((Number) value).doubleValue();
+        }
+        super.setTag(name, value);
+    }
 
-	public void parseCoordinateString(String elementText,
-			String elementSeparator) throws MismatchedDimensionException, FactoryException, TransformException {
-		String[] split = elementText.split(elementSeparator);
+    @Override
+    public String toString() {
+        StringBuilder txt = new StringBuilder();
+        txt.append("Node: ");
+        txt.append(getId());
+        txt.append(" lat=");
+        txt.append(getLat());
+        txt.append(" lon=");
+        txt.append(getLon());
+        if (!getTags().isEmpty()) {
+            txt.append("\n");
+            txt.append(tagsToString());
+        }
+        return txt.toString();
+    }
 
-		if(3==split.length) {
-			setTag("ele", split[2]);
-		}
-		Double easting = Double.parseDouble(split[0]);
-		Double northing = Double.parseDouble(split[1]);
-		LatLong wgs84 = OpenCoordConverter.toWGS84(easting, northing);
-		lat = wgs84.getLatAngle();
-		lon = wgs84.getLongAngle();
-		if (logger.isDebugEnabled()) logger.debug(toString());
-	}
+    @Override
+    public void parseCoords(String elementText)
+            throws MismatchedDimensionException, FactoryException,
+            TransformException {
+        String elementSeparator = ",";
+        parseCoordinateString(elementText, elementSeparator);
+    }
 
-	@Override
-	protected void parseNetworkMember(String elementText) {
-		throw new UnsupportedOperationException("Nodes should not have members");
-	}
+    @Override
+    public void parseCoordinateString(String elementText,
+            String elementSeparator) throws MismatchedDimensionException,
+            FactoryException, TransformException {
+        String[] split = elementText.split(elementSeparator);
 
-	@Override
-	protected void addDirectedNode(String nodeId, String grade, String orientation) {
-		throw new UnsupportedOperationException(
-				"Nodes should not have directed nodes");
-	}
-	
-	@Override
-	protected void addDirectedLink(String nodeId, String orientation) {
-		throw new UnsupportedOperationException(
-				"Nodes should not have directed links");
-	}
-	
-	public OSITNNode gradeClone(long nodeId) {
-		OSITNNode clone = new OSITNNode(nodeId);
-		Map<String, Object> tags = this.getTags();
-		clone.setTags(tags);
-		clone.lat = this.lat;
-		clone.lon = this.lon;
-		return clone;
-	}
+        if (3 == split.length) {
+            setTag("ele", split[2]);
+        }
+        Double easting = Double.parseDouble(split[0]);
+        Double northing = Double.parseDouble(split[1]);
+        LatLong wgs84 = OpenCoordConverter.toWGS84(easting, northing);
+        lat = wgs84.getLatAngle();
+        lon = wgs84.getLongAngle();
+        if (logger.isDebugEnabled())
+            logger.debug(toString());
+    }
 
-	@Override
-	protected void parseCoords(int dimensions, String lineDefinition) {
-		throw new UnsupportedOperationException();
-	}
+    @Override
+    protected void parseNetworkMember(String elementText) {
+        throw new UnsupportedOperationException("Nodes should not have members");
+    }
+
+    @Override
+    protected void addDirectedNode(String nodeId, String grade,
+            String orientation) {
+        throw new UnsupportedOperationException(
+                "Nodes should not have directed nodes");
+    }
+
+    @Override
+    protected void addDirectedLink(String nodeId, String orientation) {
+        throw new UnsupportedOperationException(
+                "Nodes should not have directed links");
+    }
+
+    public OSITNNode gradeClone(long nodeId) {
+        OSITNNode clone = new OSITNNode(nodeId);
+        Map<String, Object> tags = this.getTags();
+        clone.setTags(tags);
+        clone.lat = this.lat;
+        clone.lon = this.lon;
+        return clone;
+    }
+
+    @Override
+    protected void parseCoords(int dimensions, String lineDefinition) {
+        throw new UnsupportedOperationException();
+    }
 
 }
Index: core/src/main/java/com/graphhopper/reader/osgb/OSITNTurnRelation.java
===================================================================
--- core/src/main/java/com/graphhopper/reader/osgb/OSITNTurnRelation.java	(revision 2400)
+++ core/src/main/java/com/graphhopper/reader/osgb/OSITNTurnRelation.java	(working copy)
@@ -4,20 +4,15 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.Map;
-import java.util.Set;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import com.graphhopper.reader.DataReader;
 import com.graphhopper.reader.ITurnCostTableEntry;
-import com.graphhopper.reader.OSMReader;
-import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
 import com.graphhopper.reader.OSMTurnRelation.Type;
 import com.graphhopper.reader.TurnRelation;
-import com.graphhopper.routing.util.AbstractFlagEncoder;
 import com.graphhopper.routing.util.TurnCostEncoder;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
@@ -30,7 +25,8 @@
  * @author Stuart Adam
  */
 public class OSITNTurnRelation implements TurnRelation {
-    private static final Logger logger = LoggerFactory.getLogger(OSITNTurnRelation.class);
+    private static final Logger logger = LoggerFactory
+            .getLogger(OSITNTurnRelation.class);
 
     private static Map<String, Type> tags = new HashMap<String, Type>();
 
@@ -52,7 +48,8 @@
     private final long toOsmWayId;
     private final Type restriction;
 
-    public OSITNTurnRelation(long fromWayID, long viaNodeID, long toWayID, Type restrictionType) {
+    public OSITNTurnRelation(long fromWayID, long viaNodeID, long toWayID,
+            Type restrictionType) {
         this.fromOsmWayId = fromWayID;
         this.viaOsmNodeId = viaNodeID;
         this.toOsmWayId = toWayID;
@@ -90,7 +87,11 @@
      * @return a collection of node cost entries which can be added to the graph
      *         later
      */
-    public Collection<ITurnCostTableEntry> getRestrictionAsEntries(TurnCostEncoder encoder, EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, DataReader osmReader) {
+    @Override
+    public Collection<ITurnCostTableEntry> getRestrictionAsEntries(
+            TurnCostEncoder encoder, EdgeExplorer edgeOutExplorer,
+            EdgeExplorer edgeInExplorer, DataReader dataReader) {
+        DataReader<Long> osmReader = dataReader;
         int viaNodeId = osmReader.getInternalNodeIdOfOsmNode(this.viaOsmNodeId);
 
         try {
@@ -124,7 +125,10 @@
             while (iter.next()) {
                 int edgeId = iter.getEdge();
                 long wayId = osmReader.getOsmIdOfInternalEdge(edgeId);
-                if (edgeId != edgeIdFrom && this.restriction == Type.ONLY && wayId != this.toOsmWayId || this.restriction == Type.NOT && wayId == this.toOsmWayId && wayId >= 0) {
+                if (edgeId != edgeIdFrom && this.restriction == Type.ONLY
+                        && wayId != this.toOsmWayId
+                        || this.restriction == Type.NOT
+                        && wayId == this.toOsmWayId && wayId >= 0) {
                     final TurnCostTableEntry entry = new TurnCostTableEntry();
                     entry.nodeViaNode = viaNodeId;
                     entry.edgeFrom = edgeIdFrom;
@@ -138,13 +142,16 @@
             }
             return entries;
         } catch (Exception e) {
-            throw new IllegalStateException("Could not built turn table entry for relation of node with osmId:" + this.viaOsmNodeId, e);
+            throw new IllegalStateException(
+                    "Could not built turn table entry for relation of node with osmId:"
+                            + this.viaOsmNodeId, e);
         }
     }
 
     @Override
     public String toString() {
-        return "*-(" + fromOsmWayId + ")->" + viaOsmNodeId + "-(" + toOsmWayId + ")->*";
+        return "*-(" + fromOsmWayId + ")->" + viaOsmNodeId + "-(" + toOsmWayId
+                + ")->*";
     }
 
     /**
@@ -160,8 +167,9 @@
          * @return an unique id (edgeFrom, edgeTo) to avoid duplicate entries if
          *         multiple encoders are involved.
          */
+        @Override
         public long getItemId() {
-            return ((long) edgeFrom) << 32 | ((long) edgeTo);
+            return ((long) edgeFrom) << 32 | (edgeTo);
         }
 
         @Override
@@ -192,7 +200,8 @@
 
         @Override
         public String toString() {
-            return "*-(" + edgeFrom + ")->" + nodeViaNode + "-(" + edgeTo + ")->*";
+            return "*-(" + edgeFrom + ")->" + nodeViaNode + "-(" + edgeTo
+                    + ")->*";
         }
     }
 
Index: core/src/main/java/com/graphhopper/reader/OSMReader.java
===================================================================
--- core/src/main/java/com/graphhopper/reader/OSMReader.java	(revision 2400)
+++ core/src/main/java/com/graphhopper/reader/OSMReader.java	(working copy)
@@ -40,10 +40,12 @@
 
 import com.graphhopper.coll.GHLongIntBTree;
 import com.graphhopper.coll.LongIntMap;
-import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
 import com.graphhopper.reader.dem.ElevationProvider;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.storage.*;
+import com.graphhopper.storage.ExtendedStorage;
+import com.graphhopper.storage.GraphStorage;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.TurnCostStorage;
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.DistanceCalc3D;
 import com.graphhopper.util.DistanceCalcEarth;
@@ -74,10 +76,10 @@
  * 2.b) Reads ways OSM file and creates edges while calculating the speed etc from the OSM tags.
  * When creating an edge the pillar node information from the intermediate datastructure will be
  * stored in the way geometry of that edge.
- * <p/>
+ * <p/> 
  * @author Peter Karich
  */
-public class OSMReader implements DataReader
+public class OSMReader implements DataReader<Long>
 {
     protected static final int EMPTY = -1;
     // pillar node is >= 3
@@ -98,7 +100,7 @@
     // only append and update possible (no unordered storage like with this doubleParse): new OSMIDMap
     // same here: not applicable as ways introduces the nodes in 'wrong' order: new OSMIDSegmentedMap
     // memory overhead due to open addressing and full rehash:
-    //        nodeOsmIdToIndexMap = new BigLongIntMap(expectedNodes, EMPTY);
+    // nodeOsmIdToIndexMap = new BigLongIntMap(expectedNodes, EMPTY);
     // smaller memory overhead for bigger data sets because of avoiding a "rehash"
     // remember how many times a node was used to identify tower nodes
     private LongIntMap osmNodeIdToInternalNodeMap;
@@ -121,111 +123,113 @@
     private boolean exitOnlyPillarNodeException = true;
     private File osmFile;
 
-    public OSMReader( GraphStorage storage )
+    public OSMReader(GraphStorage storage)
     {
-        this.graphStorage = storage;
-        this.nodeAccess = graphStorage.getNodeAccess();
+	this.graphStorage = storage;
+	this.nodeAccess = graphStorage.getNodeAccess();
 
-        osmNodeIdToInternalNodeMap = new GHLongIntBTree(200);
-        osmNodeIdToNodeFlagsMap = new TLongLongHashMap(200, .5f, 0, 0);
-        osmWayIdToRouteWeightMap = new TLongLongHashMap(200, .5f, 0, 0);
-        pillarInfo = new PillarInfo(nodeAccess.is3D(), graphStorage.getDirectory());
+	osmNodeIdToInternalNodeMap = new GHLongIntBTree(200);
+	osmNodeIdToNodeFlagsMap = new TLongLongHashMap(200, .5f, 0, 0);
+	osmWayIdToRouteWeightMap = new TLongLongHashMap(200, .5f, 0, 0);
+	pillarInfo = new PillarInfo(nodeAccess.is3D(), graphStorage.getDirectory());
     }
 
     @Override
     public void readGraph() throws IOException
     {
-        if (encodingManager == null)
-            throw new IllegalStateException("Encoding manager was not set.");
+	if (encodingManager == null)
+	    throw new IllegalStateException("Encoding manager was not set.");
 
-        if (osmFile == null)
-            throw new IllegalStateException("No OSM file specified");
+	if (osmFile == null)
+	    throw new IllegalStateException("No OSM file specified");
 
-        if (!osmFile.exists())
-            throw new IllegalStateException("Your specified OSM file does not exist:" + osmFile.getAbsolutePath());
+	if (!osmFile.exists())
+	    throw new IllegalStateException("Your specified OSM file does not exist:"
+			    + osmFile.getAbsolutePath());
 
-        StopWatch sw1 = new StopWatch().start();
-        preProcess(osmFile);
-        sw1.stop();
+	StopWatch sw1 = new StopWatch().start();
+	preProcess(osmFile);
+	sw1.stop();
 
-        StopWatch sw2 = new StopWatch().start();
-        writeOsm2Graph(osmFile);
-        sw2.stop();
+	StopWatch sw2 = new StopWatch().start();
+	writeOsm2Graph(osmFile);
+	sw2.stop();
 
-        logger.info("time(pass1): " + (int) sw1.getSeconds() + " pass2: " + (int) sw2.getSeconds() + " total:"
-                + ((int) (sw1.getSeconds() + sw2.getSeconds())));
+	logger.info("time(pass1): " + (int) sw1.getSeconds() + " pass2: " + (int) sw2.getSeconds()
+			+ " total:" + (int) (sw1.getSeconds() + sw2.getSeconds()));
     }
 
     /**
      * Preprocessing of OSM file to select nodes which are used for highways. This allows a more
      * compact graph data structure.
      */
-    void preProcess( File osmFile )
+    void preProcess(File osmFile)
     {
-        OSMInputFile in = null;
-        try
-        {
-            in = new OSMInputFile(osmFile).setWorkerThreads(workerThreads).open();
+	OSMInputFile in = null;
+	try
+	{
+	    in = new OSMInputFile(osmFile).setWorkerThreads(workerThreads).open();
 
-            long tmpWayCounter = 1;
-            long tmpRelationCounter = 1;
-            RoutingElement item;
-            while ((item = in.getNext()) != null)
-            {
-                if (item.isType(OSMElement.WAY))
-                {
-                    final OSMWay way = (OSMWay) item;
-                    boolean valid = filterWay(way);
-                    if (valid)
-                    {
-                        TLongList wayNodes = way.getNodes();
-                        int s = wayNodes.size();
-                        for (int index = 0; index < s; index++)
-                        {
-                            prepareHighwayNode(wayNodes.get(index));
-                        }
+	    long tmpWayCounter = 1;
+	    long tmpRelationCounter = 1;
+	    RoutingElement item;
+	    while ((item = in.getNext()) != null)
+	    {
+		if (item.isType(OSMElement.WAY))
+		{
+		    final OSMWay way = (OSMWay) item;
+		    boolean valid = filterWay(way);
+		    if (valid)
+		    {
+			TLongList wayNodes = way.getNodes();
+			int s = wayNodes.size();
+			for (int index = 0; index < s; index++)
+			{
+			    prepareHighwayNode(wayNodes.get(index));
+			}
 
-                        if (++tmpWayCounter % 5000000 == 0)
-                        {
-                            logger.info(nf(tmpWayCounter) + " (preprocess), osmIdMap:" + nf(getNodeMap().getSize()) + " ("
-                                    + getNodeMap().getMemoryUsage() + "MB) " + Helper.getMemInfo());
-                        }
-                    }
-                }
-                if (item.isType(OSMElement.RELATION))
-                {
-                    final OSMRelation relation = (OSMRelation) item;
-                    if (!relation.isMetaRelation() && relation.hasTag("type", "route"))
-                        prepareWaysWithRelationInfo(relation);
+			if (++tmpWayCounter % 5000000 == 0)
+			{
+			    logger.info(nf(tmpWayCounter) + " (preprocess), osmIdMap:"
+					    + nf(getNodeMap().getSize()) + " ("
+					    + getNodeMap().getMemoryUsage() + "MB) "
+					    + Helper.getMemInfo());
+			}
+		    }
+		}
+		if (item.isType(OSMElement.RELATION))
+		{
+		    final OSMRelation relation = (OSMRelation) item;
+		    if (!relation.isMetaRelation() && relation.hasTag("type", "route"))
+			prepareWaysWithRelationInfo(relation);
 
-                    if (relation.hasTag("type", "restriction"))
-                        prepareRestrictionRelation(relation);
+		    if (relation.hasTag("type", "restriction"))
+			prepareRestrictionRelation(relation);
 
-                    if (++tmpRelationCounter % 50000 == 0)
-                    {
-                        logger.info(nf(tmpRelationCounter) + " (preprocess), osmWayMap:" + nf(getRelFlagsMap().size())
-                                + " " + Helper.getMemInfo());
-                    }
-
-                }
-            }
-        } catch (Exception ex)
-        {
-            throw new RuntimeException("Problem while parsing file", ex);
-        } finally
-        {
-            Helper.close(in);
-        }
+		    if (++tmpRelationCounter % 50000 == 0)
+		    {
+			logger.info(nf(tmpRelationCounter) + " (preprocess), osmWayMap:"
+					+ nf(getRelFlagsMap().size()) + " " + Helper.getMemInfo());
+		    }
+		}
+	    }
+	} catch (Exception ex)
+	{
+	    throw new RuntimeException("Problem while parsing file", ex);
+	} finally
+	{
+	    Helper.close(in);
+	}
     }
 
-    private void prepareRestrictionRelation( OSMRelation relation )
+    private void prepareRestrictionRelation(OSMRelation relation)
     {
-        TurnRelation turnRelation = createTurnRelation(relation);
-        if (turnRelation != null)
-        {
-            getOsmWayIdSet().add(turnRelation.getOsmIdFrom());
-            getOsmWayIdSet().add(turnRelation.getOsmIdTo());
-        }
+	TurnRelation turnRelation = createTurnRelation(relation);
+	if (turnRelation != null)
+	{
+	    getOsmWayIdSet().add(turnRelation.getOsmIdFrom());
+	    getOsmWayIdSet().add(turnRelation.getOsmIdTo());
+	}
     }
 
     /**
@@ -233,15 +237,15 @@
      */
     private TLongSet getOsmWayIdSet()
     {
-        return osmWayIdSet;
+	return osmWayIdSet;
     }
 
     private TIntLongMap getEdgeIdToOsmWayIdMap()
     {
-        if (edgeIdToOsmWayIdMap == null)
-            edgeIdToOsmWayIdMap = new TIntLongHashMap(getOsmWayIdSet().size(), 0.5f, -1, -1);
+	if (edgeIdToOsmWayIdMap == null)
+	    edgeIdToOsmWayIdMap = new TIntLongHashMap(getOsmWayIdSet().size(), 0.5f, -1, -1);
 
-        return edgeIdToOsmWayIdMap;
+	return edgeIdToOsmWayIdMap;
     }
 
     /**
@@ -250,652 +254,661 @@
      * <p/>
      * @return true the current xml entry is a way entry and has nodes
      */
-    boolean filterWay( OSMWay item )
+    boolean filterWay(OSMWay item)
     {
-        // ignore broken geometry
-        if (item.getNodes().size() < 2)
-            return false;
+	// ignore broken geometry
+	if (item.getNodes().size() < 2)
+	    return false;
 
-        // ignore multipolygon geometry
-        if (!item.hasTags())
-            return false;
+	// ignore multipolygon geometry
+	if (!item.hasTags())
+	    return false;
 
-        return encodingManager.acceptWay(item) > 0;
+	return encodingManager.acceptWay(item) > 0;
     }
 
     /**
      * Creates the edges and nodes files from the specified osm file.
      */
-    private void writeOsm2Graph( File osmFile )
+    private void writeOsm2Graph(File osmFile)
     {
-        int tmp = (int) Math.max(getNodeMap().getSize() / 50, 100);
-        
-        logger.info("creating graph. Found nodes (pillar+tower):" + nf(getNodeMap().getSize()) + ", " + Helper.getMemInfo());
-        graphStorage.create(tmp);
-        long wayStart = -1;
-        long relationStart = -1;
-        long counter = 1;
-        OSMInputFile in = null;
-        try
-        {
-            in = new OSMInputFile(osmFile).setWorkerThreads(workerThreads).open();
-            LongIntMap nodeFilter = getNodeMap();
+	int tmp = (int) Math.max(getNodeMap().getSize() / 50, 100);
+
+	logger.info("creating graph. Found nodes (pillar+tower):" + nf(getNodeMap().getSize())
+			+ ", " + Helper.getMemInfo());
+	graphStorage.create(tmp);
+	long wayStart = -1;
+	long relationStart = -1;
+	long counter = 1;
+	OSMInputFile in = null;
+	try
+	{
+	    in = new OSMInputFile(osmFile).setWorkerThreads(workerThreads).open();
+	    LongIntMap nodeFilter = getNodeMap();
 
-            RoutingElement item;
-            while ((item = in.getNext()) != null)
-            {
-                switch (item.getType())
-                {
-                    case OSMElement.NODE:
-                        if (nodeFilter.get(item.getId()) != -1)
-                        {
-                            processNode((OSMNode) item);
-                        }
-                        break;
+	    RoutingElement item;
+	    while ((item = in.getNext()) != null)
+	    {
+		switch (item.getType())
+		{
+		case OSMElement.NODE:
+		    OSMNode node = (OSMNode) item;
+		    if (nodeFilter.get(node.getId()) != -1)
+		    {
+			processNode((OSMNode) item);
+		    }
+		    break;
 
-                    case OSMElement.WAY:
-                        if (wayStart < 0)
-                        {
-                            logger.info(nf(counter) + ", now parsing ways");
-                            wayStart = counter;
-                        }
-                        processWay((OSMWay) item);
-                        break;
-                    case OSMElement.RELATION:
-                        if (relationStart < 0)
-                        {
-                            logger.info(nf(counter) + ", now parsing relations");
-                            relationStart = counter;
-                        }
-                        processRelation((OSMRelation) item);
-                        break;
-                }
-                if (++counter % 100000000 == 0)
-                {
-                    logger.info(nf(counter) + ", locs:" + nf(locations) + " (" + skippedLocations + ") " + Helper.getMemInfo());
-                }
-            }
+		case OSMElement.WAY:
+		    if (wayStart < 0)
+		    {
+			logger.info(nf(counter) + ", now parsing ways");
+			wayStart = counter;
+		    }
+		    processWay((OSMWay) item);
+		    break;
+		case OSMElement.RELATION:
+		    if (relationStart < 0)
+		    {
+			logger.info(nf(counter) + ", now parsing relations");
+			relationStart = counter;
+		    }
+		    processRelation((OSMRelation) item);
+		    break;
+		}
+		if (++counter % 100000000 == 0)
+		{
+		    logger.info(nf(counter) + ", locs:" + nf(locations) + " (" + skippedLocations
+				    + ") " + Helper.getMemInfo());
+		}
+	    }
 
-            // logger.info("storage nodes:" + storage.nodes() + " vs. graph nodes:" + storage.getGraph().nodes());
-        } catch (Exception ex)
-        {
-            throw new RuntimeException("Couldn't process file " + osmFile + ", error: " + ex.getMessage(), ex);
-        } finally
-        {
-            Helper.close(in);
-        }
+	    // logger.info("storage nodes:" + storage.nodes() +
+	    // " vs. graph nodes:" + storage.getGraph().nodes());
+	} catch (Exception ex)
+	{
+	    throw new RuntimeException("Couldn't process file " + osmFile + ", error: "
+			    + ex.getMessage(), ex);
+	} finally
+	{
+	    Helper.close(in);
+	}
 
-        finishedReading();
-        if (graphStorage.getNodes() == 0)
-            throw new IllegalStateException("osm must not be empty. read " + counter + " lines and " + locations + " locations");
+	finishedReading();
+	if (graphStorage.getNodes() == 0)
+	    throw new IllegalStateException("osm must not be empty. read " + counter
+			    + " lines and " + locations + " locations");
     }
 
     /**
      * Process properties, encode flags and create edges for the way.
      */
-    void processWay( OSMWay way )
+    void processWay(OSMWay way)
     {
-        if (way.getNodes().size() < 2)
-            return;
+	if (way.getNodes().size() < 2)
+	    return;
 
-        // ignore multipolygon geometry
-        if (!way.hasTags())
-            return;
+	// ignore multipolygon geometry
+	if (!way.hasTags())
+	    return;
 
-        long wayOsmId = way.getId();
+	long wayOsmId = way.getId();
 
-        long includeWay = encodingManager.acceptWay(way);
-        if (includeWay == 0)
-            return;
+	long includeWay = encodingManager.acceptWay(way);
+	if (includeWay == 0)
+	    return;
 
-        long relationFlags = getRelFlagsMap().get(way.getId());
+	long relationFlags = getRelFlagsMap().get(way.getId());
 
-        // TODO move this after we have created the edge and know the coordinates => encodingManager.applyWayTags
-        // estimate length of the track e.g. for ferry speed calculation
-        TLongList osmNodeIds = way.getNodes();
-        if (osmNodeIds.size() > 1)
-        {
-            int first = getNodeMap().get(osmNodeIds.get(0));
-            int last = getNodeMap().get(osmNodeIds.get(osmNodeIds.size() - 1));
-            double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
-            double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
-            if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon) && !Double.isNaN(lastLat) && !Double.isNaN(lastLon))
-            {
-                double estimatedDist = distCalc.calcDist(firstLat, firstLon, lastLat, lastLon);
-                way.setTag("estimated_distance", estimatedDist);
-                way.setTag("estimated_center", new GHPoint((firstLat + lastLat) / 2, (firstLon + lastLon) / 2));
-            }
-        }
+	// TODO move this after we have created the edge and know the
+	// coordinates => encodingManager.applyWayTags
+	// estimate length of the track e.g. for ferry speed calculation
+	TLongList osmNodeIds = way.getNodes();
+	if (osmNodeIds.size() > 1)
+	{
+	    int first = getNodeMap().get(osmNodeIds.get(0));
+	    int last = getNodeMap().get(osmNodeIds.get(osmNodeIds.size() - 1));
+	    double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
+	    double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
+	    if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon) && !Double.isNaN(lastLat)
+			    && !Double.isNaN(lastLon))
+	    {
+		double estimatedDist = distCalc.calcDist(firstLat, firstLon, lastLat, lastLon);
+		way.setTag("estimated_distance", estimatedDist);
+		way.setTag("estimated_center", new GHPoint((firstLat + lastLat) / 2,
+				(firstLon + lastLon) / 2));
+	    }
+	}
 
-        long wayFlags = encodingManager.handleWayTags(way, includeWay, relationFlags);
-        if (wayFlags == 0)
-            return;
+	long wayFlags = encodingManager.handleWayTags(way, includeWay, relationFlags);
+	if (wayFlags == 0)
+	    return;
 
-        List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
-        // look for barriers along the way
-        final int size = osmNodeIds.size();
-        int lastBarrier = -1;
-        for (int i = 0; i < size; i++)
-        {
-            long nodeId = osmNodeIds.get(i);
-            long nodeFlags = getNodeFlagsMap().get(nodeId);
-            // barrier was spotted and way is otherwise passable for that mode of travel
-            if (nodeFlags > 0)
-            {
-                if ((nodeFlags & wayFlags) > 0)
-                {
-                    // remove barrier to avoid duplicates
-                    getNodeFlagsMap().put(nodeId, 0);
+	List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
+	// look for barriers along the way
+	final int size = osmNodeIds.size();
+	int lastBarrier = -1;
+	for (int i = 0; i < size; i++)
+	{
+	    long nodeId = osmNodeIds.get(i);
+	    long nodeFlags = getNodeFlagsMap().get(nodeId);
+	    // barrier was spotted and way is otherwise passable for that mode
+	    // of travel
+	    if (nodeFlags > 0)
+		if ((nodeFlags & wayFlags) > 0)
+		{
+		    // remove barrier to avoid duplicates
+		    getNodeFlagsMap().put(nodeId, 0);
 
-                    // create shadow node copy for zero length edge
-                    long newNodeId = addBarrierNode(nodeId);
-                    if (i > 0)
-                    {
-                        // start at beginning of array if there was no previous barrier
-                        if (lastBarrier < 0)
-                            lastBarrier = 0;
+		    // create shadow node copy for zero length edge
+		    long newNodeId = addBarrierNode(nodeId);
+		    if (i > 0)
+		    {
+			// start at beginning of array if there was no previous
+			// barrier
+			if (lastBarrier < 0)
+			    lastBarrier = 0;
 
-                        // add way up to barrier shadow node
-                        long transfer[] = osmNodeIds.toArray(lastBarrier, i - lastBarrier + 1);
-                        transfer[transfer.length - 1] = newNodeId;
-                        TLongList partIds = new TLongArrayList(transfer);
-                        createdEdges.addAll(addOSMWay(partIds, wayFlags, wayOsmId));
+			// add way up to barrier shadow node
+			long transfer[] = osmNodeIds.toArray(lastBarrier, i - lastBarrier + 1);
+			transfer[transfer.length - 1] = newNodeId;
+			TLongList partIds = new TLongArrayList(transfer);
+			createdEdges.addAll(addOSMWay(partIds, wayFlags, wayOsmId));
 
-                        // create zero length edge for barrier
-                        createdEdges.addAll(addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId));
-                    } else
-                    {
-                        // run edge from real first node to shadow node
-                        createdEdges.addAll(addBarrierEdge(nodeId, newNodeId, wayFlags, nodeFlags, wayOsmId));
+			// create zero length edge for barrier
+			createdEdges.addAll(addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags,
+					wayOsmId));
+		    } else
+		    {
+			// run edge from real first node to shadow node
+			createdEdges.addAll(addBarrierEdge(nodeId, newNodeId, wayFlags, nodeFlags,
+					wayOsmId));
 
-                        // exchange first node for created barrier node
-                        osmNodeIds.set(0, newNodeId);
-                    }
-                    // remember barrier for processing the way behind it
-                    lastBarrier = i;
-                }
-            }
-        }
+			// exchange first node for created barrier node
+			osmNodeIds.set(0, newNodeId);
+		    }
+		    // remember barrier for processing the way behind it
+		    lastBarrier = i;
+		}
+	}
 
-        // just add remainder of way to graph if barrier was not the last node
-        if (lastBarrier >= 0)
-        {
-            if (lastBarrier < size - 1)
-            {
-                long transfer[] = osmNodeIds.toArray(lastBarrier, size - lastBarrier);
-                TLongList partNodeIds = new TLongArrayList(transfer);
-                createdEdges.addAll(addOSMWay(partNodeIds, wayFlags, wayOsmId));
-            }
-        } else
-        {
-            // no barriers - simply add the whole way
-            createdEdges.addAll(addOSMWay(way.getNodes(), wayFlags, wayOsmId));
-        }
+	// just add remainder of way to graph if barrier was not the last node
+	if (lastBarrier >= 0)
+	{
+	    if (lastBarrier < size - 1)
+	    {
+		long transfer[] = osmNodeIds.toArray(lastBarrier, size - lastBarrier);
+		TLongList partNodeIds = new TLongArrayList(transfer);
+		createdEdges.addAll(addOSMWay(partNodeIds, wayFlags, wayOsmId));
+	    }
+	} else
+	    // no barriers - simply add the whole way
+	    createdEdges.addAll(addOSMWay(way.getNodes(), wayFlags, wayOsmId));
 
-        for (EdgeIteratorState edge : createdEdges)
-        {
-            encodingManager.applyWayTags(way, edge);
-        }
+	for (EdgeIteratorState edge : createdEdges)
+	    encodingManager.applyWayTags(way, edge);
     }
 
-    public void processRelation( OSMRelation relation ) throws XMLStreamException
+    public void processRelation(OSMRelation relation) throws XMLStreamException
     {
-        if (relation.hasTag("type", "restriction"))
-        {
-            TurnRelation turnRelation = createTurnRelation(relation);
-            if (turnRelation != null)
-            {
-                ExtendedStorage extendedStorage = graphStorage.getExtendedStorage();
-                if (extendedStorage instanceof TurnCostStorage)
-                {
-                    TurnCostStorage tcs = (TurnCostStorage) extendedStorage;
-                    Collection<ITurnCostTableEntry> entries = encodingManager.analyzeTurnRelation(turnRelation, this);
-                    for (ITurnCostTableEntry entry : entries)
-                    {
-                        tcs.addTurnInfo(entry.getVia(), entry.getEdgeFrom(), entry.getEdgeTo(), (int) entry.getFlags());
-                    }
-                }
-            }
-        }
+	if (relation.hasTag("type", "restriction"))
+	{
+	    TurnRelation turnRelation = createTurnRelation(relation);
+	    if (turnRelation != null)
+	    {
+		ExtendedStorage extendedStorage = graphStorage.getExtendedStorage();
+		if (extendedStorage instanceof TurnCostStorage)
+		{
+		    TurnCostStorage tcs = (TurnCostStorage) extendedStorage;
+		    Collection<ITurnCostTableEntry> entries = encodingManager.analyzeTurnRelation(
+				    turnRelation, this);
+		    for (ITurnCostTableEntry entry : entries)
+			tcs.addTurnInfo(entry.getVia(), entry.getEdgeFrom(), entry.getEdgeTo(),
+					(int) entry.getFlags());
+		}
+	    }
+	}
     }
 
     /**
      * @return OSM way ID from specified edgeId. Only previously stored OSM-way-IDs are returned in
-     * order to reduce memory overhead.
+     *         order to reduce memory overhead.
      */
-    public long getOsmIdOfInternalEdge( int edgeId )
+    @Override
+    public Long getOsmIdOfInternalEdge(int edgeId)
     {
-        return getEdgeIdToOsmWayIdMap().get(edgeId);
+	return getEdgeIdToOsmWayIdMap().get(edgeId);
     }
 
-    public int getInternalNodeIdOfOsmNode( long nodeOsmId )
+    @Override
+    public int getInternalNodeIdOfOsmNode(Long nodeOsmId)
     {
-        int id = getNodeMap().get(nodeOsmId);
-        if (id < TOWER_NODE)
-            return -id - 3;
+	int id = getNodeMap().get(nodeOsmId);
+	if (id < TOWER_NODE)
+	    return -id - 3;
 
-        return EMPTY;
+	return EMPTY;
     }
 
-    // TODO remove this ugly stuff via better preparsing phase! E.g. putting every tags etc into a helper file!
-    double getTmpLatitude( int id )
+    // TODO remove this ugly stuff via better preparsing phase! E.g. putting
+    // every tags etc into a helper file!
+    double getTmpLatitude(int id)
     {
-        if (id == EMPTY)
-            return Double.NaN;
-        if (id < TOWER_NODE)
-        {
-            // tower node
-            id = -id - 3;
-            return nodeAccess.getLatitude(id);
-        } else if (id > -TOWER_NODE)
-        {
-            // pillar node
-            id = id - 3;
-            return pillarInfo.getLatitude(id);
-        } else
-            // e.g. if id is not handled from preparse (e.g. was ignored via isInBounds)
-            return Double.NaN;
+	if (id == EMPTY)
+	    return Double.NaN;
+	if (id < TOWER_NODE)
+	{
+	    // tower node
+	    id = -id - 3;
+	    return nodeAccess.getLatitude(id);
+	} else if (id > -TOWER_NODE)
+	{
+	    // pillar node
+	    id = id - 3;
+	    return pillarInfo.getLatitude(id);
+	} else
+	    // e.g. if id is not handled from preparse (e.g. was ignored via
+	    // isInBounds)
+	    return Double.NaN;
     }
 
-    double getTmpLongitude( int id )
+    double getTmpLongitude(int id)
     {
-        if (id == EMPTY)
-            return Double.NaN;
-        if (id < TOWER_NODE)
-        {
-            // tower node
-            id = -id - 3;
-            return nodeAccess.getLongitude(id);
-        } else if (id > -TOWER_NODE)
-        {
-            // pillar node
-            id = id - 3;
-            return pillarInfo.getLon(id);
-        } else
-            // e.g. if id is not handled from preparse (e.g. was ignored via isInBounds)
-            return Double.NaN;
+	if (id == EMPTY)
+	    return Double.NaN;
+	if (id < TOWER_NODE)
+	{
+	    // tower node
+	    id = -id - 3;
+	    return nodeAccess.getLongitude(id);
+	} else if (id > -TOWER_NODE)
+	{
+	    // pillar node
+	    id = id - 3;
+	    return pillarInfo.getLon(id);
+	} else
+	    // e.g. if id is not handled from preparse (e.g. was ignored via
+	    // isInBounds)
+	    return Double.NaN;
     }
 
-    private void processNode( OSMNode node )
+    private void processNode(OSMNode node)
     {
-        if (isInBounds(node))
-        {
-            addNode(node);
+	if (isInBounds(node))
+	{
+	    addNode(node);
 
-            // analyze node tags for barriers
-            if (node.hasTags())
-            {
-                long nodeFlags = encodingManager.handleNodeTags(node);
-                if (nodeFlags != 0)
-                    getNodeFlagsMap().put(node.getId(), nodeFlags);
-            }
+	    // analyze node tags for barriers
+	    if (node.hasTags())
+	    {
+		long nodeFlags = encodingManager.handleNodeTags(node);
+		if (nodeFlags != 0)
+		    getNodeFlagsMap().put(node.getId(), nodeFlags);
+	    }
 
-            locations++;
-        } else
-        {
-            skippedLocations++;
-        }
+	    locations++;
+	} else
+	    skippedLocations++;
     }
 
-    boolean addNode( OSMNode node )
+    boolean addNode(OSMNode node)
     {
-        int nodeType = getNodeMap().get(node.getId());
-        if (nodeType == EMPTY)
-            return false;
+	int nodeType = getNodeMap().get(node.getId());
+	if (nodeType == EMPTY)
+	    return false;
 
-        double lat = node.getLat();
-        double lon = node.getLon();
-        double ele = getElevation(node);
-        if (nodeType == TOWER_NODE)
-        {
-            addTowerNode(node.getId(), lat, lon, ele);
-        } else if (nodeType == PILLAR_NODE)
-        {
-            pillarInfo.setNode(nextPillarId, lat, lon, ele);
-            getNodeMap().put(node.getId(), nextPillarId + 3);
-            nextPillarId++;
-        }
-        return true;
+	double lat = node.getLat();
+	double lon = node.getLon();
+	double ele = getElevation(node);
+	if (nodeType == TOWER_NODE)
+	    addTowerNode(node.getId(), lat, lon, ele);
+	else if (nodeType == PILLAR_NODE)
+	{
+	    pillarInfo.setNode(nextPillarId, lat, lon, ele);
+	    getNodeMap().put(node.getId(), nextPillarId + 3);
+	    nextPillarId++;
+	}
+	return true;
     }
 
-    protected double getElevation( OSMNode node )
+    protected double getElevation(OSMNode node)
     {
-        return eleProvider.getEle(node.getLat(), node.getLon());
+	return eleProvider.getEle(node.getLat(), node.getLon());
     }
 
-    void prepareWaysWithRelationInfo( OSMRelation osmRelation )
+    void prepareWaysWithRelationInfo(OSMRelation osmRelation)
     {
-        // is there at least one tag interesting for the registed encoders?
-        if (encodingManager.handleRelationTags(osmRelation, 0) == 0)
-            return;
+	// is there at least one tag interesting for the registed encoders?
+	if (encodingManager.handleRelationTags(osmRelation, 0) == 0)
+	    return;
 
-        int size = osmRelation.getMembers().size();
-        for (int index = 0; index < size; index++)
-        {
-            OSMRelation.Member member = osmRelation.getMembers().get(index);
-            if (member.type() != OSMRelation.Member.WAY)
-                continue;
+	int size = osmRelation.getMembers().size();
+	for (int index = 0; index < size; index++)
+	{
+	    OSMRelation.Member member = osmRelation.getMembers().get(index);
+	    if (member.type() != OSMRelation.Member.WAY)
+		continue;
 
-            long osmId = member.ref();
-            long oldRelationFlags = getRelFlagsMap().get(osmId);
+	    long osmId = member.ref();
+	    long oldRelationFlags = getRelFlagsMap().get(osmId);
 
-            // Check if our new relation data is better comparated to the the last one
-            long newRelationFlags = encodingManager.handleRelationTags(osmRelation, oldRelationFlags);
-            if (oldRelationFlags != newRelationFlags)
-                getRelFlagsMap().put(osmId, newRelationFlags);
-        }
+	    // Check if our new relation data is better comparated to the the
+	    // last one
+	    long newRelationFlags = encodingManager.handleRelationTags(osmRelation,
+			    oldRelationFlags);
+	    if (oldRelationFlags != newRelationFlags)
+		getRelFlagsMap().put(osmId, newRelationFlags);
+	}
     }
 
-    void prepareHighwayNode( long osmId )
+    void prepareHighwayNode(long osmId)
     {
-        int tmpIndex = getNodeMap().get(osmId);
-        if (tmpIndex == EMPTY)
-        {
-            // osmId is used exactly once
-            getNodeMap().put(osmId, PILLAR_NODE);
-        } else if (tmpIndex > EMPTY)
-        {
-            // mark node as tower node as it occured at least twice times
-            getNodeMap().put(osmId, TOWER_NODE);
-        } else
-        {
-            // tmpIndex is already negative (already tower node)
-        }
+	int tmpIndex = getNodeMap().get(osmId);
+	if (tmpIndex == EMPTY)
+	{
+	    // osmId is used exactly once
+	    getNodeMap().put(osmId, PILLAR_NODE);
+	} else if (tmpIndex > EMPTY)
+	{
+	    // mark node as tower node as it occured at least twice times
+	    getNodeMap().put(osmId, TOWER_NODE);
+	} else
+	{
+	    // tmpIndex is already negative (already tower node)
+	}
     }
 
-    int addTowerNode( long osmId, double lat, double lon, double ele )
+    int addTowerNode(long osmId, double lat, double lon, double ele)
     {
-        if (nodeAccess.is3D())
-            nodeAccess.setNode(nextTowerId, lat, lon, ele);
-        else
-            nodeAccess.setNode(nextTowerId, lat, lon);
+	if (nodeAccess.is3D())
+	    nodeAccess.setNode(nextTowerId, lat, lon, ele);
+	else
+	    nodeAccess.setNode(nextTowerId, lat, lon);
 
-        int id = -(nextTowerId + 3);
-        getNodeMap().put(osmId, id);
-        nextTowerId++;
-        return id;
+	int id = -(nextTowerId + 3);
+	getNodeMap().put(osmId, id);
+	nextTowerId++;
+	return id;
     }
 
     /**
      * This method creates from an OSM way (via the osm ids) one or more edges in the graph.
      */
-    Collection<EdgeIteratorState> addOSMWay( TLongList osmNodeIds, long flags, long wayOsmId )
+    Collection<EdgeIteratorState> addOSMWay(TLongList osmNodeIds, long flags, long wayOsmId)
     {
-        PointList pointList = new PointList(osmNodeIds.size(), nodeAccess.is3D());
-        List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
-        int firstNode = -1;
-        int lastIndex = osmNodeIds.size() - 1;
-        int lastInBoundsPillarNode = -1;
-        try
-        {
-            for (int i = 0; i < osmNodeIds.size(); i++)
-            {
-                long osmId = osmNodeIds.get(i);
-                int tmpNode = getNodeMap().get(osmId);
-                if (tmpNode == EMPTY)
-                    continue;
-
-                // skip osmIds with no associated pillar or tower id (e.g. !OSMReader.isBounds)
-                if (tmpNode == TOWER_NODE)
-                    continue;
+	PointList pointList = new PointList(osmNodeIds.size(), nodeAccess.is3D());
+	List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
+	int firstNode = -1;
+	int lastIndex = osmNodeIds.size() - 1;
+	int lastInBoundsPillarNode = -1;
+	try
+	{
+	    for (int i = 0; i < osmNodeIds.size(); i++)
+	    {
+		long osmId = osmNodeIds.get(i);
+		int tmpNode = getNodeMap().get(osmId);
+		if (tmpNode == EMPTY)
+		    continue;
 
-                if (tmpNode == PILLAR_NODE)
-                {
-                    // In some cases no node information is saved for the specified osmId.
-                    // ie. a way references a <node> which does not exist in the current file.
-                    // => if the node before was a pillar node then convert into to tower node (as it is also end-standing).
-                    if (!pointList.isEmpty() && lastInBoundsPillarNode > -TOWER_NODE)
-                    {
-                        // transform the pillar node to a tower node
-                        tmpNode = lastInBoundsPillarNode;
-                        tmpNode = handlePillarNode(tmpNode, osmId, null, true);
-                        tmpNode = -tmpNode - 3;
-                        if (pointList.getSize() > 1 && firstNode >= 0)
-                        {
-                            // TOWER node
-                            newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
-                            pointList.clear();
-                            pointList.add(nodeAccess, tmpNode);
-                        }
-                        firstNode = tmpNode;
-                        lastInBoundsPillarNode = -1;
-                    }
-                    continue;
-                }
+		// skip osmIds with no associated pillar or tower id (e.g.
+		// !OSMReader.isBounds)
+		if (tmpNode == TOWER_NODE)
+		    continue;
 
-                if (tmpNode <= -TOWER_NODE && tmpNode >= TOWER_NODE)
-                    throw new AssertionError("Mapped index not in correct bounds " + tmpNode + ", " + osmId);
+		if (tmpNode == PILLAR_NODE)
+		{
+		    // In some cases no node information is saved for the
+		    // specified osmId.
+		    // ie. a way references a <node> which does not exist in the
+		    // current file.
+		    // => if the node before was a pillar node then convert into
+		    // to tower node (as it is also end-standing).
+		    if (!pointList.isEmpty() && lastInBoundsPillarNode > -TOWER_NODE)
+		    {
+			// transform the pillar node to a tower node
+			tmpNode = lastInBoundsPillarNode;
+			tmpNode = handlePillarNode(tmpNode, osmId, null, true);
+			tmpNode = -tmpNode - 3;
+			if (pointList.getSize() > 1 && firstNode >= 0)
+			{
+			    // TOWER node
+			    newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
+			    pointList.clear();
+			    pointList.add(nodeAccess, tmpNode);
+			}
+			firstNode = tmpNode;
+			lastInBoundsPillarNode = -1;
+		    }
+		    continue;
+		}
 
-                if (tmpNode > -TOWER_NODE)
-                {
-                    boolean convertToTowerNode = i == 0 || i == lastIndex;
-                    if (!convertToTowerNode)
-                    {
-                        lastInBoundsPillarNode = tmpNode;
-                    }
+		if (tmpNode <= -TOWER_NODE && tmpNode >= TOWER_NODE)
+		    throw new AssertionError("Mapped index not in correct bounds " + tmpNode + ", "
+				    + osmId);
 
-                    // PILLAR node, but convert to towerNode if end-standing
-                    tmpNode = handlePillarNode(tmpNode, osmId, pointList, convertToTowerNode);
-                }
+		if (tmpNode > -TOWER_NODE)
+		{
+		    boolean convertToTowerNode = i == 0 || i == lastIndex;
+		    if (!convertToTowerNode)
+		    {
+			lastInBoundsPillarNode = tmpNode;
+		    }
+		    // PILLAR node, but convert to towerNode if end-standing
+		    tmpNode = handlePillarNode(tmpNode, osmId, pointList, convertToTowerNode);
+		}
 
-                if (tmpNode < TOWER_NODE)
-                {
-                    // TOWER node
-                    tmpNode = -tmpNode - 3;
-                    pointList.add(nodeAccess, tmpNode);
-                    if (firstNode >= 0)
-                    {
-                        newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
-                        pointList.clear();
-                        pointList.add(nodeAccess, tmpNode);
-                    }
-                    firstNode = tmpNode;
-                }
-            }
-        } catch (RuntimeException ex)
-        {
-            logger.error("Couldn't properly add edge with osm ids:" + osmNodeIds, ex);
-            if (exitOnlyPillarNodeException)
-                throw ex;
-        }
-        return newEdges;
+		if (tmpNode < TOWER_NODE)
+		{
+		    // TOWER node
+		    tmpNode = -tmpNode - 3;
+		    pointList.add(nodeAccess, tmpNode);
+		    if (firstNode >= 0)
+		    {
+			newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
+			pointList.clear();
+			pointList.add(nodeAccess, tmpNode);
+		    }
+		    firstNode = tmpNode;
+		}
+	    }
+	} catch (RuntimeException ex)
+	{
+	    logger.error("Couldn't properly add edge with osm ids:" + osmNodeIds, ex);
+	    if (exitOnlyPillarNodeException)
+		throw ex;
+	}
+	return newEdges;
     }
 
-    EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long flags, long wayOsmId )
+    EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList, long flags,
+		    long wayOsmId)
     {
-        // sanity checks
-        if (fromIndex < 0 || toIndex < 0)
-            throw new AssertionError("to or from index is invalid for this edge " + fromIndex + "->" + toIndex + ", points:" + pointList);
-        if (pointList.getDimension() != nodeAccess.getDimension())
-            throw new AssertionError("Dimension does not match for pointList vs. nodeAccess " + pointList.getDimension() + " <-> " + nodeAccess.getDimension());
+	// sanity checks
+	if (fromIndex < 0 || toIndex < 0)
+	    throw new AssertionError("to or from index is invalid for this edge " + fromIndex
+			    + "->" + toIndex + ", points:" + pointList);
+	if (pointList.getDimension() != nodeAccess.getDimension())
+	    throw new AssertionError("Dimension does not match for pointList vs. nodeAccess "
+			    + pointList.getDimension() + " <-> " + nodeAccess.getDimension());
 
-        double towerNodeDistance = 0;
-        double prevLat = pointList.getLatitude(0);
-        double prevLon = pointList.getLongitude(0);
-        double prevEle = pointList.is3D() ? pointList.getElevation(0) : Double.NaN;
-        double lat, lon, ele = Double.NaN;
-        PointList pillarNodes = new PointList(pointList.getSize() - 2, nodeAccess.is3D());
-        int nodes = pointList.getSize();
-        for (int i = 1; i < nodes; i++)
-        {
-            // we could save some lines if we would use pointList.calcDistance(distCalc);
-            lat = pointList.getLatitude(i);
-            lon = pointList.getLongitude(i);
-            if (pointList.is3D())
-            {
-                ele = pointList.getElevation(i);
-                towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon, prevEle, lat, lon, ele);
-                prevEle = ele;
-            } else
-                towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat, lon);
-            prevLat = lat;
-            prevLon = lon;
-            if (nodes > 2 && i < nodes - 1)
-            {
-                if (pillarNodes.is3D())
-                    pillarNodes.add(lat, lon, ele);
-                else
-                    pillarNodes.add(lat, lon);
-            }
-        }
-        if (towerNodeDistance == 0)
-        {
-            // As investigation shows often two paths should have crossed via one identical point 
-            // but end up in two very release points.
-            zeroCounter++;
-            towerNodeDistance = 0.0001;
-        }
+	double towerNodeDistance = 0;
+	double prevLat = pointList.getLatitude(0);
+	double prevLon = pointList.getLongitude(0);
+	double prevEle = pointList.is3D() ? pointList.getElevation(0) : Double.NaN;
+	double lat, lon, ele = Double.NaN;
+	PointList pillarNodes = new PointList(pointList.getSize() - 2, nodeAccess.is3D());
+	int nodes = pointList.getSize();
+	for (int i = 1; i < nodes; i++)
+	{
+	    // we could save some lines if we would use
+	    // pointList.calcDistance(distCalc);
+	    lat = pointList.getLatitude(i);
+	    lon = pointList.getLongitude(i);
+	    if (pointList.is3D())
+	    {
+		ele = pointList.getElevation(i);
+		towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon, prevEle, lat, lon, ele);
+		prevEle = ele;
+	    } else
+		towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat, lon);
+	    prevLat = lat;
+	    prevLon = lon;
+	    if (nodes > 2 && i < nodes - 1)
+		if (pillarNodes.is3D())
+		    pillarNodes.add(lat, lon, ele);
+		else
+		    pillarNodes.add(lat, lon);
+	}
+	if (towerNodeDistance == 0)
+	{
+	    // As investigation shows often two paths should have crossed via
+	    // one identical point
+	    // but end up in two very release points.
+	    zeroCounter++;
+	    towerNodeDistance = 0.0001;
+	}
 
-        EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex).setDistance(towerNodeDistance).setFlags(flags);
-        if (nodes > 2)
-        {
-            if (doSimplify)
-                simplifyAlgo.simplify(pillarNodes);
+	EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex)
+			.setDistance(towerNodeDistance).setFlags(flags);
+	if (nodes > 2)
+	{
+	    if (doSimplify)
+		simplifyAlgo.simplify(pillarNodes);
 
-            iter.setWayGeometry(pillarNodes);
-        }
-        storeOsmWayID(iter.getEdge(), wayOsmId);
-        return iter;
+	    iter.setWayGeometry(pillarNodes);
+	}
+	storeOsmWayID(iter.getEdge(), wayOsmId);
+	return iter;
     }
 
     /**
      * Stores only osmWayIds which are required for relations
      */
-    private void storeOsmWayID( int edgeId, long osmWayId )
+    private void storeOsmWayID(int edgeId, long osmWayId)
     {
-        if (getOsmWayIdSet().contains(osmWayId))
-        {
-            getEdgeIdToOsmWayIdMap().put(edgeId, osmWayId);
-        }
+	if (getOsmWayIdSet().contains(osmWayId))
+	    getEdgeIdToOsmWayIdMap().put(edgeId, osmWayId);
     }
 
     /**
      * @return converted tower node
      */
-    private int handlePillarNode( int tmpNode, long osmId, PointList pointList, boolean convertToTowerNode )
+    private int handlePillarNode(int tmpNode, long osmId, PointList pointList,
+		    boolean convertToTowerNode)
     {
-        tmpNode = tmpNode - 3;
-        double lat = pillarInfo.getLatitude(tmpNode);
-        double lon = pillarInfo.getLongitude(tmpNode);
-        double ele = pillarInfo.getElevation(tmpNode);
-        if (lat == Double.MAX_VALUE || lon == Double.MAX_VALUE)
-            throw new RuntimeException("Conversion pillarNode to towerNode already happended!? "
-                    + "osmId:" + osmId + " pillarIndex:" + tmpNode);
+	tmpNode = tmpNode - 3;
+	double lat = pillarInfo.getLatitude(tmpNode);
+	double lon = pillarInfo.getLongitude(tmpNode);
+	double ele = pillarInfo.getElevation(tmpNode);
+	if (lat == Double.MAX_VALUE || lon == Double.MAX_VALUE)
+	    throw new RuntimeException("Conversion pillarNode to towerNode already happended!? "
+			    + "osmId:" + osmId + " pillarIndex:" + tmpNode);
 
-        if (convertToTowerNode)
-        {
-            // convert pillarNode type to towerNode, make pillar values invalid
-            pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);
-            tmpNode = addTowerNode(osmId, lat, lon, ele);
-        } else
-        {
-            if (pointList.is3D())
-                pointList.add(lat, lon, ele);
-            else
-                pointList.add(lat, lon);
-        }
+	if (convertToTowerNode)
+	{
+	    // convert pillarNode type to towerNode, make pillar values invalid
+	    pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);
+	    tmpNode = addTowerNode(osmId, lat, lon, ele);
+	} else if (pointList.is3D())
+	    pointList.add(lat, lon, ele);
+	else
+	    pointList.add(lat, lon);
 
-        return (int) tmpNode;
+	return tmpNode;
     }
 
     protected void finishedReading()
     {
-        printInfo("way");
-        pillarInfo.clear();
-        eleProvider.release();
-        osmNodeIdToInternalNodeMap = null;
-        osmNodeIdToNodeFlagsMap = null;
-        osmWayIdToRouteWeightMap = null;
-        osmWayIdSet = null;
-        edgeIdToOsmWayIdMap = null;
+	printInfo("way");
+	pillarInfo.clear();
+	eleProvider.release();
+	osmNodeIdToInternalNodeMap = null;
+	osmNodeIdToNodeFlagsMap = null;
+	osmWayIdToRouteWeightMap = null;
+	osmWayIdSet = null;
+	edgeIdToOsmWayIdMap = null;
     }
 
     /**
      * Create a copy of the barrier node
      */
-    long addBarrierNode( long nodeId )
+    long addBarrierNode(long nodeId)
     {
-        OSMNode newNode;
-        int graphIndex = getNodeMap().get(nodeId);
-        if (graphIndex < TOWER_NODE)
-        {
-            graphIndex = -graphIndex - 3;
-            newNode = new OSMNode(createNewNodeId(), nodeAccess, graphIndex);
-        } else
-        {
-            graphIndex = graphIndex - 3;
-            newNode = new OSMNode(createNewNodeId(), pillarInfo, graphIndex);
-        }
+	OSMNode newNode;
+	int graphIndex = getNodeMap().get(nodeId);
+	if (graphIndex < TOWER_NODE)
+	{
+	    graphIndex = -graphIndex - 3;
+	    newNode = new OSMNode(createNewNodeId(), nodeAccess, graphIndex);
+	} else
+	{
+	    graphIndex = graphIndex - 3;
+	    newNode = new OSMNode(createNewNodeId(), pillarInfo, graphIndex);
+	}
 
-        final long id = newNode.getId();
-        prepareHighwayNode(id);
-        addNode(newNode);
-        return id;
+	final long id = newNode.getId();
+	prepareHighwayNode(id);
+	addNode(newNode);
+	return id;
     }
 
     private long createNewNodeId()
     {
-        return newUniqueOsmId++;
+	return newUniqueOsmId++;
     }
 
     /**
      * Add a zero length edge with reduced routing options to the graph.
      */
-    Collection<EdgeIteratorState> addBarrierEdge( long fromId, long toId, long flags, long nodeFlags, long wayOsmId )
+    Collection<EdgeIteratorState> addBarrierEdge(long fromId, long toId, long flags,
+		    long nodeFlags, long wayOsmId)
     {
-        // clear barred directions from routing flags
-        flags &= ~nodeFlags;
-        // add edge
-        barrierNodeIds.clear();
-        barrierNodeIds.add(fromId);
-        barrierNodeIds.add(toId);
-        return addOSMWay(barrierNodeIds, flags, wayOsmId);
+	// clear barred directions from routing flags
+	flags &= ~nodeFlags;
+	// add edge
+	barrierNodeIds.clear();
+	barrierNodeIds.add(fromId);
+	barrierNodeIds.add(toId);
+	return addOSMWay(barrierNodeIds, flags, wayOsmId);
     }
 
     /**
      * Creates an OSM turn relation out of an unspecified OSM relation
      * <p>
+     * 
      * @return the OSM turn relation, <code>null</code>, if unsupported turn relation
      */
-    TurnRelation createTurnRelation( OSMRelation relation )
+    TurnRelation createTurnRelation(OSMRelation relation)
     {
-        OSMTurnRelation.Type type = OSMTurnRelation.Type.getRestrictionType(relation.getTag("restriction"));
-        if (type != OSMTurnRelation.Type.UNSUPPORTED)
-        {
-            long fromWayID = -1;
-            long viaNodeID = -1;
-            long toWayID = -1;
+	OSMTurnRelation.Type type = OSMTurnRelation.Type.getRestrictionType(relation
+			.getTag("restriction"));
+	if (type != OSMTurnRelation.Type.UNSUPPORTED)
+	{
+	    long fromWayID = -1;
+	    long viaNodeID = -1;
+	    long toWayID = -1;
 
-            for (OSMRelation.Member member : relation.getMembers())
-            {
-                if (OSMElement.WAY == member.type())
-                {
-                    if ("from".equals(member.role()))
-                    {
-                        fromWayID = member.ref();
-                    } else if ("to".equals(member.role()))
-                    {
-                        toWayID = member.ref();
-                    }
-                } else if (OSMElement.NODE == member.type() && "via".equals(member.role()))
-                {
-                    viaNodeID = member.ref();
-                }
-            }
-            if (fromWayID >= 0 && toWayID >= 0 && viaNodeID >= 0)
-            {
-                return new OSMTurnRelation(fromWayID, viaNodeID, toWayID, type);
-            }
-        }
-        return null;
+	    for (OSMRelation.Member member : relation.getMembers())
+		if (OSMElement.WAY == member.type())
+		{
+		    if ("from".equals(member.role()))
+			fromWayID = member.ref();
+		    else if ("to".equals(member.role()))
+			toWayID = member.ref();
+		} else if (OSMElement.NODE == member.type() && "via".equals(member.role()))
+		    viaNodeID = member.ref();
+	    if (fromWayID >= 0 && toWayID >= 0 && viaNodeID >= 0)
+		return new OSMTurnRelation(fromWayID, viaNodeID, toWayID, type);
+	}
+	return null;
     }
 
     /**
      * Filter method, override in subclass
      */
-    boolean isInBounds( OSMNode node )
+    boolean isInBounds(OSMNode node)
     {
-        return true;
+	return true;
     }
 
     /**
@@ -903,76 +916,86 @@
      */
     protected LongIntMap getNodeMap()
     {
-        return osmNodeIdToInternalNodeMap;
+	return osmNodeIdToInternalNodeMap;
     }
 
     protected TLongLongMap getNodeFlagsMap()
     {
-        return osmNodeIdToNodeFlagsMap;
+	return osmNodeIdToNodeFlagsMap;
     }
 
     TLongLongHashMap getRelFlagsMap()
     {
-        return osmWayIdToRouteWeightMap;
+	return osmWayIdToRouteWeightMap;
     }
 
     /**
      * Specify the type of the path calculation (car, bike, ...).
      */
-    public OSMReader setEncodingManager( EncodingManager em )
+    @Override
+    public OSMReader setEncodingManager(EncodingManager em)
     {
-        this.encodingManager = em;
-        return this;
+	this.encodingManager = em;
+	return this;
     }
 
-    public OSMReader setWayPointMaxDistance( double maxDist )
+    @Override
+    public OSMReader setWayPointMaxDistance(double maxDist)
     {
-        doSimplify = maxDist > 0;
-        simplifyAlgo.setMaxDistance(maxDist);
-        return this;
+	doSimplify = maxDist > 0;
+	simplifyAlgo.setMaxDistance(maxDist);
+	return this;
     }
 
-    public OSMReader setWorkerThreads( int numOfWorkers )
+    @Override
+    public OSMReader setWorkerThreads(int numOfWorkers)
     {
-        this.workerThreads = numOfWorkers;
-        return this;
+	this.workerThreads = numOfWorkers;
+	return this;
     }
 
-    public OSMReader setElevationProvider( ElevationProvider eleProvider )
+    @Override
+    public OSMReader setElevationProvider(ElevationProvider eleProvider)
     {
-        if (eleProvider == null)
-            throw new IllegalStateException("Use the NOOP elevation provider instead of null or don't call setElevationProvider");
+	if (eleProvider == null)
+	    throw new IllegalStateException(
+			    "Use the NOOP elevation provider instead of null or don't call setElevationProvider");
 
-        if (!nodeAccess.is3D() && ElevationProvider.NOOP != eleProvider)
-            throw new IllegalStateException("Make sure you graph accepts 3D data");
+	if (!nodeAccess.is3D() && ElevationProvider.NOOP != eleProvider)
+	    throw new IllegalStateException("Make sure you graph accepts 3D data");
 
-        this.eleProvider = eleProvider;
-        return this;
+	this.eleProvider = eleProvider;
+	return this;
     }
 
-    public DataReader setOSMFile( File osmFile )
+    @Override
+    public DataReader setOSMFile(File osmFile)
     {
-        this.osmFile = osmFile;
-        return this;
+	this.osmFile = osmFile;
+	return this;
     }
 
-    private void printInfo( String str )
+    private void printInfo(String str)
     {
-        LoggerFactory.getLogger(getClass()).info(
-                "finished " + str + " processing." + " nodes: " + graphStorage.getNodes() + ", osmIdMap.size:" + getNodeMap().getSize()
-                + ", osmIdMap:" + getNodeMap().getMemoryUsage() + "MB" + ", nodeFlagsMap.size:" + getNodeFlagsMap().size()
-                + ", relFlagsMap.size:" + getRelFlagsMap().size() + " " + Helper.getMemInfo());
+	LoggerFactory.getLogger(getClass()).info(
+			"finished " + str + " processing." + " nodes: " + graphStorage.getNodes()
+					+ ", osmIdMap.size:" + getNodeMap().getSize()
+					+ ", osmIdMap:" + getNodeMap().getMemoryUsage() + "MB"
+					+ ", nodeFlagsMap.size:" + getNodeFlagsMap().size()
+					+ ", relFlagsMap.size:" + getRelFlagsMap().size() + " "
+					+ Helper.getMemInfo());
     }
 
     @Override
     public String toString()
     {
-        return getClass().getSimpleName();
+	return getClass().getSimpleName();
     }
 
+    @Override
     public GraphStorage getGraphStorage()
     {
-        return graphStorage;
+	return graphStorage;
     }
 
 }
Index: core/src/main/java/com/graphhopper/reader/RoutingElement.java
===================================================================
--- core/src/main/java/com/graphhopper/reader/RoutingElement.java	(revision 2400)
+++ core/src/main/java/com/graphhopper/reader/RoutingElement.java	(working copy)
@@ -5,26 +5,24 @@
 
 public interface RoutingElement {
 
-	void setTag(String name, Object value);
+    void setTag(String name, Object value);
 
-	String getTag(String string);
-	
-	<T> T getTag( String key, T defaultValue );
+    String getTag(String string);
 
-	boolean hasTags();
+    <T> T getTag(String key, T defaultValue);
 
-	boolean hasTag(String key, String... values);
+    boolean hasTags();
 
-	boolean hasTag(String key, Object value);
+    boolean hasTag(String key, String... values);
 
-	boolean hasTag(String key, Set<String> values);
+    boolean hasTag(String key, Object value);
 
-	boolean hasTag(List<String> keyList, Set<String> values);
+    boolean hasTag(String key, Set<String> values);
 
-	int getType();
+    boolean hasTag(List<String> keyList, Set<String> values);
 
-	boolean isType(int way);
+    int getType();
 
-	long getId();
+    boolean isType(int way);
 
 }
\ No newline at end of file
Index: core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnInputFile.java
===================================================================
--- core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnInputFile.java	(revision 2400)
+++ core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnInputFile.java	(working copy)
@@ -27,7 +27,6 @@
 import java.lang.reflect.Constructor;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
 import java.util.zip.GZIPInputStream;
 import java.util.zip.ZipInputStream;
 
@@ -52,231 +51,198 @@
  * @author Nop
  */
 public class OsDpnInputFile implements Sink, Closeable {
-	private boolean eof;
-	private InputStream bis;
-	// for xml parsing
-	private XMLStreamReader parser;
-	// for pbf parsing
-	private boolean binary = false;
-	private final BlockingQueue<RoutingElement> itemQueue;
-	private boolean hasIncomingData;
-	private int workerThreads = -1;
-	private static final Logger logger = LoggerFactory
-			.getLogger(OsDpnInputFile.class);
-
-	public OsDpnInputFile(File file) throws IOException {
-		bis = decode(file);
-		itemQueue = new LinkedBlockingQueue<RoutingElement>(50000);
-	}
+    private boolean eof;
+    private final InputStream bis;
+    // for xml parsing
+    private XMLStreamReader parser;
+    // for pbf parsing
+    private boolean binary = false;
+    private final BlockingQueue<RoutingElement> itemQueue;
+    private boolean hasIncomingData;
+    private int workerThreads = -1;
+    private static final Logger logger = LoggerFactory
+            .getLogger(OsDpnInputFile.class);
 
-	public OsDpnInputFile open() throws XMLStreamException {
-		if (binary) {
-			// openPBFReader(bis);
-		} else {
-			openXMLStream(bis);
-		}
-		return this;
-	}
+    public OsDpnInputFile(File file) throws IOException {
+        bis = decode(file);
+        itemQueue = new LinkedBlockingQueue<RoutingElement>(50000);
+    }
 
-	/**
-	 * Currently on for pbf format. Default is number of cores.
-	 */
-	public OsDpnInputFile setWorkerThreads(int num) {
-		workerThreads = num;
-		return this;
-	}
+    public OsDpnInputFile open() throws XMLStreamException {
+        if (binary) {
+            // openPBFReader(bis);
+        } else {
+            openXMLStream(bis);
+        }
+        return this;
+    }
 
-	@SuppressWarnings("unchecked")
-	private InputStream decode(File file) throws IOException {
-		final String name = file.getName();
+    /**
+     * Currently on for pbf format. Default is number of cores.
+     */
+    public OsDpnInputFile setWorkerThreads(int num) {
+        workerThreads = num;
+        return this;
+    }
 
-		InputStream ips = null;
-		try {
-			ips = new BufferedInputStream(new FileInputStream(file), 50000);
-		} catch (FileNotFoundException e) {
-			throw new RuntimeException(e);
-		}
-		ips.mark(10);
+    @SuppressWarnings("unchecked")
+    private InputStream decode(File file) throws IOException {
+        final String name = file.getName();
 
-		// check file header
-		byte header[] = new byte[6];
-		ips.read(header);
+        InputStream ips = null;
+        try {
+            ips = new BufferedInputStream(new FileInputStream(file), 50000);
+        } catch (FileNotFoundException e) {
+            throw new RuntimeException(e);
+        }
+        ips.mark(10);
 
-		/*
-		 * can parse bz2 directly with additional lib if (header[0] == 'B' &&
-		 * header[1] == 'Z') { return new CBZip2InputStream(ips); }
-		 */
-		if (header[0] == 31 && header[1] == -117) {
-			ips.reset();
-			return new GZIPInputStream(ips, 50000);
-		} else if (header[0] == 0 && header[1] == 0 && header[2] == 0
-				&& header[4] == 10 && header[5] == 9
-				&& (header[3] == 13 || header[3] == 14)) {
-			ips.reset();
-			binary = true;
-			return ips;
-		} else if (header[0] == 'P' && header[1] == 'K') {
-			ips.reset();
-			ZipInputStream zip = new ZipInputStream(ips);
-			zip.getNextEntry();
+        // check file header
+        byte header[] = new byte[6];
+        ips.read(header);
 
-			return zip;
-		} else if (name.endsWith(".osm") || name.endsWith(".xml")) {
-			ips.reset();
-			return ips;
-		} else if (name.endsWith(".bz2") || name.endsWith(".bzip2")) {
-			String clName = "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream";
-			try {
-				Class clazz = Class.forName(clName);
-				ips.reset();
-				Constructor<InputStream> ctor = clazz.getConstructor(
-						InputStream.class, boolean.class);
-				return ctor.newInstance(ips, true);
-			} catch (Exception e) {
-				throw new IllegalArgumentException("Cannot instantiate "
-						+ clName, e);
-			}
-		} else {
-			throw new IllegalArgumentException(
-					"Input file is not of valid type " + file.getPath());
-		}
-	}
+        /*
+         * can parse bz2 directly with additional lib if (header[0] == 'B' &&
+         * header[1] == 'Z') { return new CBZip2InputStream(ips); }
+         */
+        if (header[0] == 31 && header[1] == -117) {
+            ips.reset();
+            return new GZIPInputStream(ips, 50000);
+        } else if (header[0] == 0 && header[1] == 0 && header[2] == 0
+                && header[4] == 10 && header[5] == 9
+                && (header[3] == 13 || header[3] == 14)) {
+            ips.reset();
+            binary = true;
+            return ips;
+        } else if (header[0] == 'P' && header[1] == 'K') {
+            ips.reset();
+            ZipInputStream zip = new ZipInputStream(ips);
+            zip.getNextEntry();
 
-	private void openXMLStream(InputStream in) throws XMLStreamException {
-		XMLInputFactory factory = XMLInputFactory.newInstance();
-		parser = factory.createXMLStreamReader(bis, "UTF-8");
+            return zip;
+        } else if (name.endsWith(".gml") || name.endsWith(".xml")) {
+            ips.reset();
+            return ips;
+        } else if (name.endsWith(".bz2") || name.endsWith(".bzip2")) {
+            String clName = "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream";
+            try {
+                Class clazz = Class.forName(clName);
+                ips.reset();
+                Constructor<InputStream> ctor = clazz.getConstructor(
+                        InputStream.class, boolean.class);
+                return ctor.newInstance(ips, true);
+            } catch (Exception e) {
+                throw new IllegalArgumentException("Cannot instantiate "
+                        + clName, e);
+            }
+        } else {
+            throw new IllegalArgumentException(
+                    "Input file is not of valid type " + file.getPath());
+        }
+    }
 
-		int event = parser.next();
-		if (event != XMLStreamConstants.START_ELEMENT
-				|| !parser.getLocalName().equalsIgnoreCase("FeatureCollection")) {
-			throw new IllegalArgumentException(
-					"File is not a valid OS ITN stream");
-		}
+    private void openXMLStream(InputStream in) throws XMLStreamException {
+        XMLInputFactory factory = XMLInputFactory.newInstance();
+        parser = factory.createXMLStreamReader(bis, "UTF-8");
 
-		eof = false;
-	}
+        int event = parser.next();
+        if (event != XMLStreamConstants.START_ELEMENT
+                || !parser.getLocalName().equalsIgnoreCase("FeatureCollection")) {
+            throw new IllegalArgumentException(
+                    "File is not a valid OS ITN stream");
+        }
 
-	public RoutingElement getNext() throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
-		if (eof)
-			throw new IllegalStateException("EOF reached");
+        eof = false;
+    }
 
-		RoutingElement item;
-		if (binary)
-			item = getNextPBF();
-		else
-			item = getNextXML();
+    public RoutingElement getNext() throws XMLStreamException,
+            MismatchedDimensionException, FactoryException, TransformException {
+        if (eof)
+            throw new IllegalStateException("EOF reached");
 
-		if (item != null)
-			return item;
+        RoutingElement item;
+        item = getNextXML();
 
-		eof = true;
-		return null;
-	}
+        if (item != null)
+            return item;
 
-	private RoutingElement getNextXML() throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+        eof = true;
+        return null;
+    }
 
-		int event = parser.next();
-		while (event != XMLStreamConstants.END_DOCUMENT) {
-			if (event == XMLStreamConstants.START_ELEMENT) {
-				String idStr = parser.getAttributeValue("gml", "id");
-				if (idStr != null) {
-					String name = parser.getLocalName();
-					idStr = idStr.substring(4);
-					long id = Long.parseLong(idStr);
+    private RoutingElement getNextXML() throws XMLStreamException,
+            MismatchedDimensionException, FactoryException, TransformException {
 
-					logger.info(":" + name + ":");
-					switch (name) {
-					case "RouteNode": {
-						return OsDpnNode.create(id, parser);
-					}
-					case "RouteLink": {
-						return OsDpnWay.create(id, parser);
-					}
-					case "Route": {
-						//TODO grouped features
-					}
-					default: {
-						
-					}
+        int event = parser.next();
+        while (event != XMLStreamConstants.END_DOCUMENT) {
+            if (event == XMLStreamConstants.START_ELEMENT) {
+                String idStr = parser.getAttributeValue(null, "id");
+                if (idStr != null) {
+                    String name = parser.getLocalName();
+                    idStr = idStr.substring(4);
 
-					}
-				}
-			}
-			event = parser.next();
-		}
-		parser.close();
-		return null;
-	}
+                    logger.info(":" + name + ":");
+                    switch (name) {
+                        case "RouteNode": {
+                            return OsDpnNode.create(idStr, parser);
+                        }
+                        case "RouteLink": {
+                            return OsDpnWay.create(idStr, parser);
+                        }
+                        case "Route": {
+                            // TODO grouped features
+                        }
+                        default: {
 
-	public boolean isEOF() {
-		return eof;
-	}
+                        }
 
-	@Override
-	public void close() throws IOException {
-		try {
-			if (!binary)
-				parser.close();
-		} catch (XMLStreamException ex) {
-			throw new IOException(ex);
-		} finally {
-			eof = true;
-			bis.close();
-			// if exception happend on OSMInputFile-thread we need to shutdown
-			// the pbf handling
-			if (pbfReaderThread != null && pbfReaderThread.isAlive())
-				pbfReaderThread.interrupt();
-		}
-	}
+                    }
+                }
+            }
+            event = parser.next();
+        }
+        parser.close();
+        return null;
+    }
 
-	Thread pbfReaderThread;
+    public boolean isEOF() {
+        return eof;
+    }
 
-	// private void openPBFReader(InputStream stream) {
-	// hasIncomingData = true;
-	// if (workerThreads <= 0)
-	// workerThreads = 2;
-	//
-	// PbfReader reader = new PbfReader(stream, this, workerThreads);
-	// pbfReaderThread = new Thread(reader, "PBF Reader");
-	// pbfReaderThread.start();
-	// }
+    @Override
+    public void close() throws IOException {
+        try {
+            if (!binary)
+                parser.close();
+        } catch (XMLStreamException ex) {
+            throw new IOException(ex);
+        } finally {
+            eof = true;
+            bis.close();
+            // if exception happend on OSMInputFile-thread we need to shutdown
+            // the pbf handling
+            if (pbfReaderThread != null && pbfReaderThread.isAlive())
+                pbfReaderThread.interrupt();
+        }
+    }
 
-	@Override
-	public void process(RoutingElement item) {
-		try {
-			// blocks if full
-			itemQueue.put(item);
-		} catch (InterruptedException ex) {
-			throw new RuntimeException(ex);
-		}
+    Thread pbfReaderThread;
 
-		// throw exception if full
-		// itemQueue.add(item);
-	}
+    @Override
+    public void process(RoutingElement item) {
+        try {
+            // blocks if full
+            itemQueue.put(item);
+        } catch (InterruptedException ex) {
+            throw new RuntimeException(ex);
+        }
 
-	@Override
-	public void complete() {
-		hasIncomingData = false;
-	}
+        // throw exception if full
+        // itemQueue.add(item);
+    }
 
-	private RoutingElement getNextPBF() {
-		RoutingElement next = null;
-		while (next == null) {
-			if (!hasIncomingData && itemQueue.isEmpty()) {
-				// we are done, stop polling
-				eof = true;
-				break;
-			}
-
-			try {
-				// we cannot use "itemQueue.take()" as it blocks and
-				// hasIncomingData can change
-				next = itemQueue.poll(10, TimeUnit.MILLISECONDS);
-			} catch (InterruptedException ex) {
-				eof = true;
-				break;
-			}
-		}
-		return next;
-	}
+    @Override
+    public void complete() {
+        hasIncomingData = false;
+    }
 }
Index: core/src/main/java/com/graphhopper/reader/osgb/OsItnReader.java
===================================================================
--- core/src/main/java/com/graphhopper/reader/osgb/OsItnReader.java	(revision 2400)
+++ core/src/main/java/com/graphhopper/reader/osgb/OsItnReader.java	(working copy)
@@ -37,17 +37,15 @@
 import com.graphhopper.reader.ITurnCostTableEntry;
 import com.graphhopper.reader.Node;
 import com.graphhopper.reader.OSMElement;
-import com.graphhopper.reader.OSMNode;
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMTurnRelation;
+import com.graphhopper.reader.OSMTurnRelation.Type;
 import com.graphhopper.reader.PillarInfo;
 import com.graphhopper.reader.Relation;
 import com.graphhopper.reader.RelationMember;
 import com.graphhopper.reader.RoutingElement;
 import com.graphhopper.reader.Way;
-import com.graphhopper.reader.OSMTurnRelation.Type;
 import com.graphhopper.reader.dem.ElevationProvider;
-import com.graphhopper.routing.util.AbstractFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.ExtendedStorage;
 import com.graphhopper.storage.GraphHopperStorage;
@@ -108,7 +106,7 @@
  * @author Peter Karich
  */
 
-public class OsItnReader implements DataReader {
+public class OsItnReader implements DataReader<Long> {
 
     private static final String TURN_FROM_TO_VIA_FORMAT = "Turn from:{} to:{} via:{}";
     private static final String PRINT_INFO_FORMAT = "finished {}  processing. nodes:{}, osmIdMap.size:{}, osmIdMap:{}MB, nodeFlagsMap.size:{}, relFlagsMap.size:{} {}";
@@ -145,7 +143,9 @@
     private static final String EDGE_ID_TO_OSMIDMAP_FORMAT = "edgeIdTOOsmidmap: {}";
 
     public class ProcessVisitor {
-        public void process(ProcessData processData, OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+        public void process(ProcessData processData, OsItnInputFile in)
+                throws XMLStreamException, MismatchedDimensionException,
+                FactoryException, TransformException {
         }
     }
 
@@ -161,8 +161,10 @@
     protected static final int PILLAR_NODE = 1;
     // tower node is <= -3
     protected static final int TOWER_NODE = -2;
-    private static final Logger logger = LoggerFactory.getLogger(OsItnReader.class);
-    private static final Logger errors_logger = LoggerFactory.getLogger("ingestionerrors");
+    private static final Logger logger = LoggerFactory
+            .getLogger(OsItnReader.class);
+    private static final Logger errors_logger = LoggerFactory
+            .getLogger("ingestionerrors");
 
     private static final int MAX_GRADE_SEPARATION = 4;
     private long locations;
@@ -191,7 +193,7 @@
     // smaller memory overhead for bigger data sets because of avoiding a
     // "rehash"
     // remember how many times a node was used to identify tower nodes
-    private LongIntMap osmNodeIdToInternalNodeMap;
+    private final LongIntMap osmNodeIdToInternalNodeMap;
     private TLongLongHashMap osmNodeIdToNodeFlagsMap;
     private TLongLongHashMap osmWayIdToRouteWeightMap;
     // stores osm way ids used by relations to identify which edge ids needs to
@@ -209,7 +211,7 @@
     // negative but increasing to avoid clash with custom created OSM files
     private long newUniqueOsmId = -Long.MAX_VALUE;
     private ElevationProvider eleProvider = ElevationProvider.NOOP;
-    private boolean exitOnlyPillarNodeException = true;
+    private final boolean exitOnlyPillarNodeException = true;
     private File routingFile;
 
     private TLongObjectMap<ItnNodePair> edgeIdToNodeMap;
@@ -228,7 +230,8 @@
         osmNodeIdToInternalNodeMap = new GHLongIntBTree(200);
         osmNodeIdToNodeFlagsMap = new TLongLongHashMap(200, .5f, 0, 0);
         osmWayIdToRouteWeightMap = new TLongLongHashMap(200, .5f, 0, 0);
-        pillarInfo = new PillarInfo(nodeAccess.is3D(), graphStorage.getDirectory());
+        pillarInfo = new PillarInfo(nodeAccess.is3D(),
+                graphStorage.getDirectory());
     }
 
     @Override
@@ -240,7 +243,9 @@
             throw new IllegalStateException("No OS ITN file specified");
 
         if (!routingFile.exists())
-            throw new IllegalStateException("Your specified OS ITN file does not exist:" + routingFile.getAbsolutePath());
+            throw new IllegalStateException(
+                    "Your specified OS ITN file does not exist:"
+                            + routingFile.getAbsolutePath());
 
         StopWatch sw1 = new StopWatch().start();
         preProcess(routingFile);
@@ -250,7 +255,9 @@
         writeOsm2Graph(routingFile);
         sw2.stop();
 
-        logger.info(TIME_PASS1_PASS2_TOTAL_FORMAT, (int) sw1.getSeconds(), (int) sw2.getSeconds(), ((int) (sw1.getSeconds() + sw2.getSeconds())));
+        logger.info(TIME_PASS1_PASS2_TOTAL_FORMAT, (int) sw1.getSeconds(),
+                (int) sw2.getSeconds(),
+                ((int) (sw1.getSeconds() + sw2.getSeconds())));
     }
 
     /**
@@ -265,7 +272,9 @@
         }
     }
 
-    private void preProcessDirOrFile(File osmFile) throws XMLStreamException, IOException, MismatchedDimensionException, FactoryException, TransformException {
+    private void preProcessDirOrFile(File osmFile) throws XMLStreamException,
+            IOException, MismatchedDimensionException, FactoryException,
+            TransformException {
         if (osmFile.isDirectory()) {
             String absolutePath = osmFile.getAbsolutePath();
             String[] list = osmFile.list();
@@ -278,18 +287,23 @@
         }
     }
 
-    private void preProcessSingleFile(File osmFile) throws XMLStreamException, IOException, MismatchedDimensionException, FactoryException, TransformException {
+    private void preProcessSingleFile(File osmFile) throws XMLStreamException,
+            IOException, MismatchedDimensionException, FactoryException,
+            TransformException {
         OsItnInputFile in = null;
         try {
             logger.error(PREPROCESS_FORMAT, osmFile.getName());
-            in = new OsItnInputFile(osmFile).setWorkerThreads(workerThreads).open();
+            in = new OsItnInputFile(osmFile).setWorkerThreads(workerThreads)
+                    .open();
             preProcessSingleFile(in);
         } finally {
             Helper.close(in);
         }
     }
 
-    private void preProcessSingleFile(OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+    private void preProcessSingleFile(OsItnInputFile in)
+            throws XMLStreamException, MismatchedDimensionException,
+            FactoryException, TransformException {
         System.out.println("==== preProcessSingleFile");
         long tmpWayCounter = 1;
         long tmpRelationCounter = 1;
@@ -297,7 +311,7 @@
         while ((item = in.getNext()) != null) {
             logger.info(OS_ITN_READER_PRE_PROCESS_FORMAT, item.getType());
             if (item.isType(OSMElement.WAY)) {
-                final Way way = (Way) item;
+                final OSITNWay way = (OSITNWay) item;
                 boolean valid = filterWay(way);
                 if (valid) {
                     TLongList wayNodes = way.getNodes();
@@ -307,7 +321,10 @@
                     }
 
                     if (++tmpWayCounter % 500000 == 0) {
-                        logger.info(PREPROCESS_OSM_ID_MAP_MB_FORMAT, nf(tmpWayCounter), nf(getNodeMap().getSize()), getNodeMap().getMemoryUsage(), Helper.getMemInfo());
+                        logger.info(PREPROCESS_OSM_ID_MAP_MB_FORMAT,
+                                nf(tmpWayCounter), nf(getNodeMap().getSize()),
+                                getNodeMap().getMemoryUsage(),
+                                Helper.getMemInfo());
                     }
                 }
             }
@@ -316,19 +333,25 @@
                 // logger.warn("RELATION :" + item.getClass() + " TYPE:" +
                 // item.getTag(OSITNElement.TAG_KEY_TYPE) + " meta?" +
                 // relation.isMetaRelation());
-                if (!relation.isMetaRelation() && relation.hasTag(OSITNElement.TAG_KEY_TYPE, "route"))
+                if (!relation.isMetaRelation()
+                        && relation.hasTag(OSITNElement.TAG_KEY_TYPE, "route"))
                     prepareWaysWithRelationInfo(relation);
 
-                if (relation.hasTag(OSITNElement.TAG_KEY_TYPE, OSITNElement.TAG_VALUE_TYPE_RESTRICTION))
+                if (relation.hasTag(OSITNElement.TAG_KEY_TYPE,
+                        OSITNElement.TAG_VALUE_TYPE_RESTRICTION))
                     prepareRestrictionRelation(relation);
 
-                if (relation.hasTag(OSITNElement.TAG_KEY_TYPE, OSITNElement.TAG_VALUE_TYPE_NOENTRY)) {
+                if (relation.hasTag(OSITNElement.TAG_KEY_TYPE,
+                        OSITNElement.TAG_VALUE_TYPE_NOENTRY)) {
                     prepareNoEntryRelation(relation);
                 }
 
                 // If this way is prohibited then we want to make a note of it
                 // so we don't include it in later route generation
-                if (relation.hasTag(OSITNElement.TAG_KEY_TYPE, OSITNElement.TAG_VALUE_TYPE_ACCESS_LIMITED) || relation.hasTag(OSITNElement.TAG_KEY_TYPE, OSITNElement.TAG_VALUE_TYPE_ACCESS_PROHIBITED)) {
+                if (relation.hasTag(OSITNElement.TAG_KEY_TYPE,
+                        OSITNElement.TAG_VALUE_TYPE_ACCESS_LIMITED)
+                        || relation.hasTag(OSITNElement.TAG_KEY_TYPE,
+                                OSITNElement.TAG_VALUE_TYPE_ACCESS_PROHIBITED)) {
                     prepareAccessProhibitedRelation(relation);
                 }
 
@@ -343,7 +366,10 @@
                 }
 
                 if (++tmpRelationCounter % 50000 == 0) {
-                    logger.info(nf(tmpRelationCounter) + " (preprocess), osmWayMap:" + nf(getRelFlagsMap().size()) + " " + Helper.getMemInfo());
+                    logger.info(nf(tmpRelationCounter)
+                            + " (preprocess), osmWayMap:"
+                            + nf(getRelFlagsMap().size()) + " "
+                            + Helper.getMemInfo());
                 }
 
             }
@@ -353,13 +379,14 @@
     private void prepareRestrictionRelation(Relation relation) {
         OSITNTurnRelation turnRelation = createTurnRelation(relation);
         if (turnRelation != null) {
-            getOsmIdStoreRequiredSet().add(((OSITNTurnRelation) turnRelation).getOsmIdFrom());
-            getOsmIdStoreRequiredSet().add(((OSITNTurnRelation) turnRelation).getOsmIdTo());
+            getOsmIdStoreRequiredSet().add(turnRelation.getOsmIdFrom());
+            getOsmIdStoreRequiredSet().add(turnRelation.getOsmIdTo());
         }
     }
 
     private void prepareAccessProhibitedRelation(Relation relation) {
-        if (!encodingManager.isVehicleQualifierTypeExcluded(relation) && !encodingManager.isVehicleQualifierTypeIncluded(relation)) {
+        if (!encodingManager.isVehicleQualifierTypeExcluded(relation)
+                && !encodingManager.isVehicleQualifierTypeIncluded(relation)) {
             ArrayList<? extends RelationMember> members = relation.getMembers();
             // There will be only one
             for (RelationMember relationMember : members) {
@@ -398,9 +425,11 @@
     private void prepareRoadDirectionRelation(Relation relation) {
         // Check if this vehicle has an exception meaning we shouldn't handle
         // one way
-        if (!encodingManager.isVehicleQualifierTypeExcluded(relation) && !encodingManager.isVehicleQualifierTypeIncluded(relation)) {
+        if (!encodingManager.isVehicleQualifierTypeExcluded(relation)
+                && !encodingManager.isVehicleQualifierTypeIncluded(relation)) {
             // This will be "-1" the first time this is called
-            String orientationIndicator = relation.getTag(OSITNElement.TAG_KEY_ONEWAY_ORIENTATION);
+            String orientationIndicator = relation
+                    .getTag(OSITNElement.TAG_KEY_ONEWAY_ORIENTATION);
             TLongObjectMap<String> edgeIdToRoadDirectionMap = getEdgeRoadDirectionMap();
             ArrayList<? extends RelationMember> members = relation.getMembers();
             for (RelationMember relationMember : members) {
@@ -418,9 +447,11 @@
     private void prepareNoEntryRelation(Relation relation) {
         // Check if this vehicle has an exception meaning we shouldn't handle no
         // entry
-        if (!encodingManager.isVehicleQualifierTypeExcluded(relation) && !encodingManager.isVehicleQualifierTypeIncluded(relation)) {
+        if (!encodingManager.isVehicleQualifierTypeExcluded(relation)
+                && !encodingManager.isVehicleQualifierTypeIncluded(relation)) {
             long flags = 1l; // (+) orientation
-            String orientationIndicator = relation.getTag(OSITNElement.TAG_KEY_NOENTRY_ORIENTATION);
+            String orientationIndicator = relation
+                    .getTag(OSITNElement.TAG_KEY_NOENTRY_ORIENTATION);
             if ("-1".equals(orientationIndicator)) {
                 flags = 0l; // (-) orientation
             }
@@ -435,7 +466,8 @@
                 String[] coordParts = coords.split(",");
                 double xCoord = Double.parseDouble(coordParts[0]);
                 double yCoord = Double.parseDouble(coordParts[1]);
-                TDoubleObjectMap<TDoubleLongMap> xCoordMap = edgeIdToXToYToNodeFlagsMap.get(wayId);
+                TDoubleObjectMap<TDoubleLongMap> xCoordMap = edgeIdToXToYToNodeFlagsMap
+                        .get(wayId);
                 if (xCoordMap == null) {
                     xCoordMap = new TDoubleObjectHashMap<TDoubleLongMap>();
                     edgeIdToXToYToNodeFlagsMap.put(wayId, xCoordMap);
@@ -446,7 +478,8 @@
                     xCoordMap.put(xCoord, yCoordMap);
                 }
                 // now put the flag in there
-                logger.info(EDGE_ID_COORDS_TO_NODE_FLAGS_MAP_PUT_FORMAT, wayId, xCoord, yCoord, flags);
+                logger.info(EDGE_ID_COORDS_TO_NODE_FLAGS_MAP_PUT_FORMAT, wayId,
+                        xCoord, yCoord, flags);
 
                 yCoordMap.put(yCoord, flags);
             }
@@ -460,14 +493,16 @@
     private TIntLongMap getEdgeIdToOsmidMap() {
         logger.info(EDGE_ID_TO_OSMIDMAP_FORMAT, edgeIdToOsmIdMap);
         if (edgeIdToOsmIdMap == null)
-            edgeIdToOsmIdMap = new TIntLongHashMap(getOsmIdStoreRequiredSet().size());
+            edgeIdToOsmIdMap = new TIntLongHashMap(getOsmIdStoreRequiredSet()
+                    .size());
 
         return edgeIdToOsmIdMap;
     }
 
     private TLongObjectMap<ItnNodePair> getNodeEdgeMap() {
         if (edgeIdToNodeMap == null)
-            edgeIdToNodeMap = new TLongObjectHashMap<ItnNodePair>(getOsmIdStoreRequiredSet().size());
+            edgeIdToNodeMap = new TLongObjectHashMap<ItnNodePair>(
+                    getOsmIdStoreRequiredSet().size());
 
         return edgeIdToNodeMap;
     }
@@ -481,21 +516,24 @@
 
     private TLongObjectMap<String> getEdgeNameMap() {
         if (edgeNameMap == null)
-            edgeNameMap = new TLongObjectHashMap<String>(getOsmIdStoreRequiredSet().size());
+            edgeNameMap = new TLongObjectHashMap<String>(
+                    getOsmIdStoreRequiredSet().size());
 
         return edgeNameMap;
     }
 
     private TLongObjectMap<String> getEdgeRoadTypeMap() {
         if (edgeRoadTypeMap == null)
-            edgeRoadTypeMap = new TLongObjectHashMap<String>(getOsmIdStoreRequiredSet().size());
+            edgeRoadTypeMap = new TLongObjectHashMap<String>(
+                    getOsmIdStoreRequiredSet().size());
 
         return edgeRoadTypeMap;
     }
 
     private TLongObjectMap<String> getEdgeRoadDirectionMap() {
         if (edgeRoadDirectionMap == null)
-            edgeRoadDirectionMap = new TLongObjectHashMap<String>(getOsmIdStoreRequiredSet().size());
+            edgeRoadDirectionMap = new TLongObjectHashMap<String>(
+                    getOsmIdStoreRequiredSet().size());
 
         return edgeRoadDirectionMap;
     }
@@ -516,7 +554,7 @@
      * 
      * @return true the current xml entry is a way entry and has nodes
      */
-    boolean filterWay(Way way) {
+    boolean filterWay(OSITNWay way) {
         // ignore broken geometry
         if (way.getNodes().size() < 2)
             return false;
@@ -533,14 +571,18 @@
      */
     private void writeOsm2Graph(File osmFile) {
         int tmp = (int) Math.max(getNodeMap().getSize() / 50, 100);
-        logger.error(CREATING_GRAPH_FOUND_NODES_PILLAR_TOWER_FORMAT, nf(getNodeMap().getSize()), Helper.getMemInfo());
+        logger.error(CREATING_GRAPH_FOUND_NODES_PILLAR_TOWER_FORMAT,
+                nf(getNodeMap().getSize()), Helper.getMemInfo());
         graphStorage.create(tmp);
 
         ProcessData processData = new ProcessData();
         try {
             ProcessVisitor processVisitor = new ProcessVisitor() {
                 @Override
-                public void process(ProcessData processData, OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+                public void process(ProcessData processData, OsItnInputFile in)
+                        throws XMLStreamException,
+                        MismatchedDimensionException, FactoryException,
+                        TransformException {
                     logger.error("PROCESS STAGE 1");
                     processStageOne(processData, in);
                 }
@@ -549,7 +591,10 @@
             writeOsm2GraphFromDirOrFile(osmFile, processData, processVisitor);
             processVisitor = new ProcessVisitor() {
                 @Override
-                public void process(ProcessData processData, OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+                public void process(ProcessData processData, OsItnInputFile in)
+                        throws XMLStreamException,
+                        MismatchedDimensionException, FactoryException,
+                        TransformException {
                     logger.error("PROCESS STAGE 2");
                     processStageTwo(processData, in);
                 }
@@ -558,7 +603,10 @@
             writeOsm2GraphFromDirOrFile(osmFile, processData, processVisitor);
             processVisitor = new ProcessVisitor() {
                 @Override
-                public void process(ProcessData processData, OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+                public void process(ProcessData processData, OsItnInputFile in)
+                        throws XMLStreamException,
+                        MismatchedDimensionException, FactoryException,
+                        TransformException {
                     logger.error("PROCESS STAGE 3");
                     processStageThree(processData, in);
                 }
@@ -572,27 +620,37 @@
 
         finishedReading();
         if (graphStorage.getNodes() == 0)
-            throw new IllegalStateException("osm must not be empty. read " + processData.counter + " lines and " + locations + " locations");
+            throw new IllegalStateException("osm must not be empty. read "
+                    + processData.counter + " lines and " + locations
+                    + " locations");
     }
 
-    private void writeOsm2GraphFromDirOrFile(File osmFile, ProcessData processData, ProcessVisitor processVisitor) throws XMLStreamException, IOException, MismatchedDimensionException, FactoryException, TransformException {
+    private void writeOsm2GraphFromDirOrFile(File osmFile,
+            ProcessData processData, ProcessVisitor processVisitor)
+            throws XMLStreamException, IOException,
+            MismatchedDimensionException, FactoryException, TransformException {
         if (osmFile.isDirectory()) {
             String absolutePath = osmFile.getAbsolutePath();
             String[] list = osmFile.list();
             for (String file : list) {
                 File nextFile = new File(absolutePath + File.separator + file);
-                writeOsm2GraphFromDirOrFile(nextFile, processData, processVisitor);
+                writeOsm2GraphFromDirOrFile(nextFile, processData,
+                        processVisitor);
             }
         } else {
             writeOsm2GraphFromSingleFile(osmFile, processData, processVisitor);
         }
     }
 
-    private void writeOsm2GraphFromSingleFile(File osmFile, ProcessData processData, ProcessVisitor processVisitor) throws XMLStreamException, IOException, MismatchedDimensionException, FactoryException, TransformException {
+    private void writeOsm2GraphFromSingleFile(File osmFile,
+            ProcessData processData, ProcessVisitor processVisitor)
+            throws XMLStreamException, IOException,
+            MismatchedDimensionException, FactoryException, TransformException {
         OsItnInputFile in = null;
         try {
             logger.error(PROCESS_FORMAT, osmFile.getName());
-            in = new OsItnInputFile(osmFile).setWorkerThreads(workerThreads).open();
+            in = new OsItnInputFile(osmFile).setWorkerThreads(workerThreads)
+                    .open();
             processVisitor.process(processData, in);
             logger.info(STORAGE_NODES_FORMAT, graphStorage.getNodes());
         } finally {
@@ -601,62 +659,74 @@
 
     }
 
-    private void processStageOne(ProcessData processData, OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+    private void processStageOne(ProcessData processData, OsItnInputFile in)
+            throws XMLStreamException, MismatchedDimensionException,
+            FactoryException, TransformException {
         System.out.println("==== processStageOne");
         RoutingElement item;
         LongIntMap nodeFilter = getNodeMap();
         while ((item = in.getNext()) != null) {
             switch (item.getType()) {
-            case OSMElement.NODE:
-                long id = item.getId();
-                logger.info(NODEITEMID_FORMAT, id);
-                if (nodeFilter.get(id) != -1) {
-                    OSITNNode nodeItem = (OSITNNode) item;
-                    processNode(nodeItem);
+                case OSMElement.NODE:
+                    OSITNNode node = (OSITNNode) item;
+                    long id = node.getId();
+                    logger.info(NODEITEMID_FORMAT, id);
+                    if (nodeFilter.get(id) != -1) {
+                        OSITNNode nodeItem = (OSITNNode) item;
+                        processNode(nodeItem);
 
-                    String strId = String.valueOf(id);
-                    addGradeNodesIfRequired(nodeItem, strId, nodeFilter);
-                }
-                break;
+                        String strId = String.valueOf(id);
+                        addGradeNodesIfRequired(nodeItem, strId, nodeFilter);
+                    }
+                    break;
 
             }
             if (++processData.counter % 5000000 == 0) {
-                logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter), nf(locations), skippedLocations, Helper.getMemInfo());
+                logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter),
+                        nf(locations), skippedLocations, Helper.getMemInfo());
             }
         }
     }
 
-    private void processStageTwo(ProcessData processData, OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+    private void processStageTwo(ProcessData processData, OsItnInputFile in)
+            throws XMLStreamException, MismatchedDimensionException,
+            FactoryException, TransformException {
         System.out.println("==== processStageTwo");
         RoutingElement item;
         LongIntMap nodeFilter = getNodeMap();
         while ((item = in.getNext()) != null) {
             switch (item.getType()) {
-            case OSMElement.WAY:
-                OSITNWay way = (OSITNWay) item;
-                logger.info(WAY_FORMAT, way.getId(), processData.wayStart);
-                if (processData.wayStart < 0) {
-                    logger.info(NOW_PARSING_WAYS_FORMAT, nf(processData.counter));
-                    processData.wayStart = processData.counter;
-                }
-                if (!way.hasTag("highway")) {
-                    way.setTag("highway", "motorway");
-                }
-                // wayNodes will only contain the mid nodes and not the start or
-                // end nodes.
-                List<OSITNNode> wayNodes = prepareWaysNodes(way, nodeFilter);
-                processWay(way, wayNodes);
-                way.clearStoredCoords();
-                break;
+                case OSMElement.WAY:
+                    OSITNWay way = (OSITNWay) item;
+                    logger.info(WAY_FORMAT, way.getId(), processData.wayStart);
+                    if (processData.wayStart < 0) {
+                        logger.info(NOW_PARSING_WAYS_FORMAT,
+                                nf(processData.counter));
+                        processData.wayStart = processData.counter;
+                    }
+                    if (!way.hasTag("highway")) {
+                        way.setTag("highway", "motorway");
+                    }
+                    // wayNodes will only contain the mid nodes and not the
+                    // start or
+                    // end nodes.
+                    List<OSITNNode> wayNodes = prepareWaysNodes(way, nodeFilter);
+                    processWay(way, wayNodes);
+                    way.clearStoredCoords();
+                    break;
             }
             if (++processData.counter % 5000000 == 0) {
-                logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter), nf(locations), skippedLocations, Helper.getMemInfo());
+                logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter),
+                        nf(locations), skippedLocations, Helper.getMemInfo());
             }
         }
     }
 
-    private List<OSITNNode> prepareWaysNodes(RoutingElement item, LongIntMap nodeFilter) throws MismatchedDimensionException, FactoryException, TransformException {
-        List<OSITNNode> evaluateWayNodes = ((OSITNWay) item).evaluateWayNodes(getEdgeIdToXToYToNodeFlagsMap());
+    private List<OSITNNode> prepareWaysNodes(RoutingElement item,
+            LongIntMap nodeFilter) throws MismatchedDimensionException,
+            FactoryException, TransformException {
+        List<OSITNNode> evaluateWayNodes = ((OSITNWay) item)
+                .evaluateWayNodes(getEdgeIdToXToYToNodeFlagsMap());
         for (OSITNNode ositnNode : evaluateWayNodes) {
             nodeFilter.put(ositnNode.getId(), PILLAR_NODE);
             processNode(ositnNode);
@@ -665,33 +735,38 @@
         return evaluateWayNodes;
     }
 
-    private void processStageThree(ProcessData processData, OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+    private void processStageThree(ProcessData processData, OsItnInputFile in)
+            throws XMLStreamException, MismatchedDimensionException,
+            FactoryException, TransformException {
         System.out.println("==== processStageThree");
         RoutingElement item;
         while ((item = in.getNext()) != null) {
             switch (item.getType()) {
-            case OSMElement.RELATION:
-                if (processData.relationStart < 0) {
-                    logger.info(NOW_PARSING_RELATIONS_FORMAT, nf(processData.counter));
-                    processData.relationStart = processData.counter;
-                }
-                processRelation((Relation) item);
-                break;
+                case OSMElement.RELATION:
+                    if (processData.relationStart < 0) {
+                        logger.info(NOW_PARSING_RELATIONS_FORMAT,
+                                nf(processData.counter));
+                        processData.relationStart = processData.counter;
+                    }
+                    processRelation((Relation) item);
+                    break;
             }
             if (++processData.counter % 5000000 == 0) {
-                logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter), nf(locations), skippedLocations, Helper.getMemInfo());
+                logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter),
+                        nf(locations), skippedLocations, Helper.getMemInfo());
             }
         }
     }
 
-    private void addGradeNodesIfRequired(OSITNNode item, String idStr, LongIntMap nodeFilter) {
+    private void addGradeNodesIfRequired(OSITNNode item, String idStr,
+            LongIntMap nodeFilter) {
         String curId;
         for (int i = 1; i <= MAX_GRADE_SEPARATION; i++) {
             curId = i + idStr;
             long parseInt = Long.parseLong(curId);
             if (nodeFilter.get(parseInt) != -1) {
                 OSITNNode gradeNode = item.gradeClone(parseInt);
-                processNode((Node) gradeNode);
+                processNode(gradeNode);
             }
         }
     }
@@ -732,7 +807,8 @@
 
         String wayDirection = getWayRoadDirection(way.getId());
         // If the way is ONEWAY then set the direction
-        if (null != wayDirection && !way.hasTag(OSITNElement.TAG_KEY_ONEWAY_ORIENTATION)) {
+        if (null != wayDirection
+                && !way.hasTag(OSITNElement.TAG_KEY_ONEWAY_ORIENTATION)) {
             way.setTag(OSITNElement.TAG_KEY_ONEWAY_ORIENTATION, wayDirection);
         }
         // TODO move this after we have created the edge and know the
@@ -745,78 +821,87 @@
             long lastItnNode = osmNodeIds.get(osmNodeIds.size() - 1);
             int last = getNodeMap().get(lastItnNode);
 
-            logger.info(WAYID_FIRST_LAST_FORMAT, wayOsmId, firstItnNode, lastItnNode);
-            getNodeEdgeMap().put(wayOsmId, new ItnNodePair(firstItnNode, lastItnNode));
+            logger.info(WAYID_FIRST_LAST_FORMAT, wayOsmId, firstItnNode,
+                    lastItnNode);
+            getNodeEdgeMap().put(wayOsmId,
+                    new ItnNodePair(firstItnNode, lastItnNode));
             double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
             double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
-            if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon) && !Double.isNaN(lastLat) && !Double.isNaN(lastLon)) {
-                double estimatedDist = distCalc.calcDist(firstLat, firstLon, lastLat, lastLon);
+            if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon)
+                    && !Double.isNaN(lastLat) && !Double.isNaN(lastLon)) {
+                double estimatedDist = distCalc.calcDist(firstLat, firstLon,
+                        lastLat, lastLon);
                 way.setTag("estimated_distance", estimatedDist);
-                way.setTag("estimated_center", new GHPoint((firstLat + lastLat) / 2, (firstLon + lastLon) / 2));
+                way.setTag("estimated_center", new GHPoint(
+                        (firstLat + lastLat) / 2, (firstLon + lastLon) / 2));
             }
         }
 
-        long wayFlags = encodingManager.handleWayTags(way, includeWay, relationFlags);
+        long wayFlags = encodingManager.handleWayTags(way, includeWay,
+                relationFlags);
         if (wayFlags == 0)
             return;
         // logger.warn(ADDING_RELATION_TO_WAYS_FORMAT, wayFlags);
-        
-        // Check if we need to add additional TOWER nodes at the start and end locations to deal
-        // with a routing algorithm bug which prevents turn restrictions from working when you start or finish on the 
+
+        // Check if we need to add additional TOWER nodes at the start and end
+        // locations to deal
+        // with a routing algorithm bug which prevents turn restrictions from
+        // working when you start or finish on the
         // final edge of a way
         boolean shouldAddStartEndTowers = true;
-        //if (osmNodeIds)
-        osmNodeIds = createStartTowerNodeAndEdge(osmNodeIds, way, wayNodes, wayFlags, wayOsmId);
+        // if (osmNodeIds)
+        osmNodeIds = createStartTowerNodeAndEdge(osmNodeIds, way, wayNodes,
+                wayFlags, wayOsmId);
         // Process No Entry and then Barriers, and finally add the remaining way
         processNoEntry(way, wayNodes, osmNodeIds, wayFlags, wayOsmId);
 
     }
 
-    private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds, OSITNWay way, List<OSITNNode> wayNodes, long wayFlags, long wayOsmId) {
-        //if (osmNodeIds.size()>2) {
+    private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds,
+            OSITNWay way, List<OSITNNode> wayNodes, long wayFlags, long wayOsmId) {
+        // if (osmNodeIds.size()>2) {
         List<EdgeIteratorState> startCreatedEdges = new ArrayList<EdgeIteratorState>();
-        
+
         // Get the node id of the first pillar node/way node
-        
-        long nodeId = osmNodeIds.get(0); 
-        
-        
-        // Check if we have a pillar node at the start. If so we need to convert to a tower.
+
+        long nodeId = osmNodeIds.get(0);
+
+        // Check if we have a pillar node at the start. If so we need to convert
+        // to a tower.
         int graphIndex = getNodeMap().get(nodeId);
         if (graphIndex < TOWER_NODE) {
-            
-            OSMNode newNode = addBarrierNode(nodeId);
+
+            OSITNNode newNode = addBarrierNode(nodeId);
             long newNodeId = newNode.getId();
             int nodeType = getNodeMap().get(newNodeId);
-            
+
             // add way up to barrier shadow node
             long transfer[] = osmNodeIds.toArray(0, 2); // From 0 for length
                                                         // 2
             transfer[transfer.length - 1] = newNodeId;
             TLongList partIds = new TLongArrayList(transfer);
-            Collection<EdgeIteratorState> newWays = addOSMWay(partIds, wayFlags, wayOsmId);
+            Collection<EdgeIteratorState> newWays = addOSMWay(partIds,
+                    wayFlags, wayOsmId);
             // logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId, newWays.size());
             startCreatedEdges.addAll(newWays);
-    
-    //      if (nodeType==PILLAR_NODE) {
-            // Set this to be a TOWER node explicitly. This has to be after the edges are created
-    //        getNodeMap().put(newNodeId, TOWER_NODE);
-    //    }
-    
-            
+
+            // if (nodeType==PILLAR_NODE) {
+            // Set this to be a TOWER node explicitly. This has to be after the
+            // edges are created
+            // getNodeMap().put(newNodeId, TOWER_NODE);
+            // }
+
             // Set the 0th node id to be our new node id
             osmNodeIds.set(0, newNodeId);
-    //        osmNodeIds.insert(1, newNodeId);
-    
-            
+            // osmNodeIds.insert(1, newNodeId);
+
             for (EdgeIteratorState edge : startCreatedEdges) {
                 encodingManager.applyWayTags(way, edge);
             }
         }
         return osmNodeIds;
     }
-    
-    
+
     /**
      * This method processes the list of NodeIds and checks if any nodes have a
      * NoEntry Tag. If it does then it adds a shadow node and an extra way as a
@@ -834,13 +919,16 @@
      * @param wayOsmId
      * @return
      */
-    private List<EdgeIteratorState> processNoEntry(OSITNWay way, List<OSITNNode> wayNodes, TLongList osmNodeIds, long wayFlags, long wayOsmId) {
+    private List<EdgeIteratorState> processNoEntry(OSITNWay way,
+            List<OSITNNode> wayNodes, TLongList osmNodeIds, long wayFlags,
+            long wayOsmId) {
         List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
         int lastNoEntry = -1;
         List<EdgeIteratorState> noEntryCreatedEdges = new ArrayList<EdgeIteratorState>();
         boolean modifiedWithNoEntry = false;
         // Process Start Coordinate
-        String startDirection = checkForNoEntryDirection(wayOsmId, way.getStartCoord());
+        String startDirection = checkForNoEntryDirection(wayOsmId,
+                way.getStartCoord());
         if (startDirection != null) {
             modifiedWithNoEntry = true;
             lastNoEntry = 1; // This will set the index used for way nodes
@@ -851,19 +939,21 @@
             if (graphIndex != EMPTY) {
 
                 long nodeFlags = getNodeFlagsMap().get(nodeId);
-                OSMNode newNode = addBarrierNode(nodeId);
+                OSITNNode newNode = addBarrierNode(nodeId);
                 long newNodeId = newNode.getId();
                 // add way up to barrier shadow node
                 long transfer[] = osmNodeIds.toArray(0, 2); // From 0 for length
                                                             // 2
                 transfer[transfer.length - 1] = newNodeId;
                 TLongList partIds = new TLongArrayList(transfer);
-                Collection<EdgeIteratorState> newWays = addOSMWay(partIds, wayFlags, wayOsmId);
+                Collection<EdgeIteratorState> newWays = addOSMWay(partIds,
+                        wayFlags, wayOsmId);
                 // logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId, newWays.size());
                 noEntryCreatedEdges.addAll(newWays);
 
                 // create zero length edge for barrier to the next node
-                Collection<EdgeIteratorState> newBarriers = addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId);
+                Collection<EdgeIteratorState> newBarriers = addBarrierEdge(
+                        newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId);
                 // logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
                 // newBarriers.size());
                 noEntryCreatedEdges.addAll(newBarriers);
@@ -871,21 +961,34 @@
                 for (EdgeIteratorState edgeIteratorState : newWays) {
                     boolean forwards = startDirection.equals("true");
 
-                    long flags = encodingManager.flagsDefault(forwards, !forwards);
+                    long flags = encodingManager.flagsDefault(forwards,
+                            !forwards);
                     // Set the flags on our new edge.
                     edgeIteratorState.setFlags(flags);
                 }
                 successfulStartNoEntries++;
             } else {
                 failedStartNoEntries++;
-                errors_logger.error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId " + nodeId + " on way " + way.getId() + " for START Node " + osmNodeIds.toString() + " (" + successfulStartNoEntries + " succeeded, " + failedStartNoEntries + " failed)");
+                errors_logger
+                        .error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId "
+                                + nodeId
+                                + " on way "
+                                + way.getId()
+                                + " for START Node "
+                                + osmNodeIds.toString()
+                                + " ("
+                                + successfulStartNoEntries
+                                + " succeeded, "
+                                + failedStartNoEntries
+                                + " failed)");
             }
         }
         // Process Way Nodes
         final int size = osmNodeIds.size();
         for (int i = 1, j = 0; j < wayNodes.size(); i++, j++) {
             OSITNNode ositnNode = wayNodes.get(j);
-            String direction = checkForNoEntryDirection(wayOsmId, way.getWayCoords()[j]);
+            String direction = checkForNoEntryDirection(wayOsmId,
+                    way.getWayCoords()[j]);
             // If direction is null then there is no No Entry defined for this
             // way node
             if (direction != null) {
@@ -894,7 +997,7 @@
                 long nodeFlags = getNodeFlagsMap().get(nodeId);
 
                 // create shadow node copy for zero length edge
-                OSMNode newNode = addBarrierNode(nodeId);
+                OSITNNode newNode = addBarrierNode(nodeId);
                 long newNodeId = newNode.getId();
                 // Always > 0 as we start at index 1
                 if (i > 0) {
@@ -904,16 +1007,19 @@
                     if (lastNoEntry < 0)
                         lastNoEntry = 0;
                     // add way up to barrier shadow node
-                    long transfer[] = osmNodeIds.toArray(lastNoEntry, i - lastNoEntry + 1);
+                    long transfer[] = osmNodeIds.toArray(lastNoEntry, i
+                            - lastNoEntry + 1);
                     transfer[transfer.length - 1] = newNodeId;
                     TLongList partIds = new TLongArrayList(transfer);
-                    Collection<EdgeIteratorState> newWays = addOSMWay(partIds, wayFlags, wayOsmId);
+                    Collection<EdgeIteratorState> newWays = addOSMWay(partIds,
+                            wayFlags, wayOsmId);
                     // logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId,
                     // newWays.size());
                     noEntryCreatedEdges.addAll(newWays);
 
                     // create zero length edge for barrier to the next node
-                    Collection<EdgeIteratorState> newBarriers = addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId);
+                    Collection<EdgeIteratorState> newBarriers = addBarrierEdge(
+                            newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId);
                     // logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
                     // newBarriers.size());
                     noEntryCreatedEdges.addAll(newBarriers);
@@ -921,7 +1027,8 @@
                     for (EdgeIteratorState edgeIteratorState : newBarriers) {
                         boolean forwards = direction.equals("true");
 
-                        long flags = encodingManager.flagsDefault(forwards, !forwards);
+                        long flags = encodingManager.flagsDefault(forwards,
+                                !forwards);
                         // Set the flags on our new edge.
                         edgeIteratorState.setFlags(flags);
                     }
@@ -930,7 +1037,8 @@
                     // when the no entry is placed on either
                     // TODO end of way we will have issues
                     // run edge from real first node to shadow node
-                    Collection<EdgeIteratorState> newBarriers = addBarrierEdge(nodeId, newNodeId, wayFlags, nodeFlags, wayOsmId);
+                    Collection<EdgeIteratorState> newBarriers = addBarrierEdge(
+                            nodeId, newNodeId, wayFlags, nodeFlags, wayOsmId);
                     // logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
                     // newBarriers.size());
                     noEntryCreatedEdges.addAll(newBarriers);
@@ -945,7 +1053,8 @@
         // Process the last coordinate
         boolean processedEntireWay = false;
         TLongList nodeIdsToCreateWaysFor = null;
-        String endDirection = checkForNoEntryDirection(wayOsmId, way.getEndCoord());
+        String endDirection = checkForNoEntryDirection(wayOsmId,
+                way.getEndCoord());
         if (endDirection != null) {
             // Get the last node id
             long nodeId = osmNodeIds.get(osmNodeIds.size() - 1);
@@ -957,9 +1066,11 @@
                 {
                     if (lastNoEntry < 0)
                         lastNoEntry = 0;
-                    long transfer[] = osmNodeIds.toArray(lastNoEntry, size - lastNoEntry - 1);
+                    long transfer[] = osmNodeIds.toArray(lastNoEntry, size
+                            - lastNoEntry - 1);
                     nodeIdsToCreateWaysFor = new TLongArrayList(transfer);
-                    Collection<EdgeIteratorState> newEdges = addOSMWay(nodeIdsToCreateWaysFor, wayFlags, wayOsmId);
+                    Collection<EdgeIteratorState> newEdges = addOSMWay(
+                            nodeIdsToCreateWaysFor, wayFlags, wayOsmId);
                     // logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId,
                     // newEdges.size());
                     createdEdges.addAll(newEdges);
@@ -971,13 +1082,13 @@
                 processedEntireWay = true;
                 long nodeFlags = getNodeFlagsMap().get(nodeId);
                 // create shadow node copy for zero length edge
-                OSMNode newNode = addBarrierNode(nodeId);
+                OSITNNode newNode = addBarrierNode(nodeId);
                 long newNodeId = newNode.getId();
-                
-                // Set this to be a TOWER node explicitly to overcome a limitation in the GraphHopper code for TurnRestrictions
-                //getNodeMap().put(newNodeId, TOWER_NODE);
+
+                // Set this to be a TOWER node explicitly to overcome a
+                // limitation in the GraphHopper code for TurnRestrictions
+                // getNodeMap().put(newNodeId, TOWER_NODE);
 
-                
                 // add way up to barrier shadow node
                 long transfer[] = osmNodeIds.toArray(osmNodeIds.size() - 2, 2); // From
                                                                                 // 0
@@ -986,19 +1097,22 @@
                                                                                 // 2
                 transfer[transfer.length - 1] = newNodeId;
                 TLongList partIds = new TLongArrayList(transfer);
-                Collection<EdgeIteratorState> newWays = addOSMWay(partIds, wayFlags, wayOsmId);
+                Collection<EdgeIteratorState> newWays = addOSMWay(partIds,
+                        wayFlags, wayOsmId);
                 // logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId, newWays.size());
                 noEntryCreatedEdges.addAll(newWays);
 
                 // create zero length edge for barrier to the next node
-                Collection<EdgeIteratorState> newBarriers = addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId);
+                Collection<EdgeIteratorState> newBarriers = addBarrierEdge(
+                        newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId);
                 // logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
                 // newBarriers.size());
                 noEntryCreatedEdges.addAll(newBarriers);
                 // Update the orientation of our little one way
                 for (EdgeIteratorState edgeIteratorState : newBarriers) {
                     boolean forwards = endDirection.equals("-1");
-                    long flags = encodingManager.flagsDefault(forwards, !forwards);
+                    long flags = encodingManager.flagsDefault(forwards,
+                            !forwards);
                     // Set the flags on our new edge.
                     edgeIteratorState.setFlags(flags);
                 }
@@ -1007,7 +1121,18 @@
                 failedEndNoEntries++;
                 // TODO Figure out why there are some end nodes that don't have
                 // internal node ids
-                errors_logger.error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId " + nodeId + " on way " + way.getId() + " for END Node " + osmNodeIds.toString() + " (" + successfulEndNoEntries + " succeeded, " + failedEndNoEntries + " failed)");
+                errors_logger
+                        .error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId "
+                                + nodeId
+                                + " on way "
+                                + way.getId()
+                                + " for END Node "
+                                + osmNodeIds.toString()
+                                + " ("
+                                + successfulEndNoEntries
+                                + " succeeded, "
+                                + failedEndNoEntries
+                                + " failed)");
             }
         }
 
@@ -1018,7 +1143,8 @@
             // node
             if (modifiedWithNoEntry) {
                 if (lastNoEntry < size - 1) {
-                    long transfer[] = osmNodeIds.toArray(lastNoEntry, size - lastNoEntry);
+                    long transfer[] = osmNodeIds.toArray(lastNoEntry, size
+                            - lastNoEntry);
                     nodeIdsToCreateWaysFor = new TLongArrayList(transfer);
                 }
             } else {
@@ -1051,7 +1177,8 @@
         // Look for direction flags in edgeIdToXToYToNodeFlagsMap for the wayId,
         // x, y combination
         long key = wayId;
-        TDoubleObjectMap<TDoubleLongMap> xToYToNodeFlagsMap = getEdgeIdToXToYToNodeFlagsMap().get(key);
+        TDoubleObjectMap<TDoubleLongMap> xToYToNodeFlagsMap = getEdgeIdToXToYToNodeFlagsMap()
+                .get(key);
         if (xToYToNodeFlagsMap != null) {
             String[] coordParts = wayCoord.split(",");
             double xCoord = Double.parseDouble(coordParts[0]);
@@ -1101,7 +1228,8 @@
      * @param wayOsmId
      * @return
      */
-    private List<EdgeIteratorState> processBarriers(Way way, TLongList osmNodeIds, long wayFlags, long wayOsmId) {
+    private List<EdgeIteratorState> processBarriers(Way way,
+            TLongList osmNodeIds, long wayFlags, long wayOsmId) {
         List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
         // look for barriers along the way
         final int size = osmNodeIds.size();
@@ -1121,7 +1249,7 @@
                     getNodeFlagsMap().put(nodeId, 0);
 
                     // create shadow node copy for zero length edge
-                    OSMNode newNode = addBarrierNode(nodeId);
+                    OSITNNode newNode = addBarrierNode(nodeId);
                     long newNodeId = newNode.getId();
                     if (i > 0) {
                         // start at beginning of array if there was no
@@ -1131,22 +1259,28 @@
                             lastBarrier = 0;
 
                         // add way up to barrier shadow node
-                        long transfer[] = osmNodeIds.toArray(lastBarrier, i - lastBarrier + 1);
+                        long transfer[] = osmNodeIds.toArray(lastBarrier, i
+                                - lastBarrier + 1);
                         transfer[transfer.length - 1] = newNodeId;
                         TLongList partIds = new TLongArrayList(transfer);
-                        Collection<EdgeIteratorState> newWays = addOSMWay(partIds, wayFlags, wayOsmId);
+                        Collection<EdgeIteratorState> newWays = addOSMWay(
+                                partIds, wayFlags, wayOsmId);
                         // logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId,
                         // newWays.size());
                         createdEdges.addAll(newWays);
 
                         // create zero length edge for barrier
-                        Collection<EdgeIteratorState> newBarriers = addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId);
+                        Collection<EdgeIteratorState> newBarriers = addBarrierEdge(
+                                newNodeId, nodeId, wayFlags, nodeFlags,
+                                wayOsmId);
                         // logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
                         // newBarriers.size());
                         createdEdges.addAll(newBarriers);
                     } else {
                         // run edge from real first node to shadow node
-                        Collection<EdgeIteratorState> newBarriers = addBarrierEdge(nodeId, newNodeId, wayFlags, nodeFlags, wayOsmId);
+                        Collection<EdgeIteratorState> newBarriers = addBarrierEdge(
+                                nodeId, newNodeId, wayFlags, nodeFlags,
+                                wayOsmId);
                         // logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
                         // newBarriers.size());
                         createdEdges.addAll(newBarriers);
@@ -1166,7 +1300,8 @@
         TLongList nodeIdsToCreateWaysFor = null;
         if (lastBarrier >= 0) {
             if (lastBarrier < size - 1) {
-                long transfer[] = osmNodeIds.toArray(lastBarrier, size - lastBarrier);
+                long transfer[] = osmNodeIds.toArray(lastBarrier, size
+                        - lastBarrier);
                 nodeIdsToCreateWaysFor = new TLongArrayList(transfer);
             }
         } else {
@@ -1175,7 +1310,9 @@
         }
 
         if (nodeIdsToCreateWaysFor != null) {
-            long lastNodeId = nodeIdsToCreateWaysFor.get(nodeIdsToCreateWaysFor.size()-1);;
+            long lastNodeId = nodeIdsToCreateWaysFor.get(nodeIdsToCreateWaysFor
+                    .size() - 1);
+            ;
             long newNodeId = -1;
 
             int graphIndex = getNodeMap().get(lastNodeId);
@@ -1183,20 +1320,23 @@
 
             // add end tower here
             if (doInsertAdditionalTowerNodes) {
-//                System.out.println("nodeIdsToCreateWaysFor.size() is " + nodeIdsToCreateWaysFor.size() + " lastNodeId is "+ lastNodeId);
-                OSMNode newNode = addBarrierNode(lastNodeId);
+                // System.out.println("nodeIdsToCreateWaysFor.size() is " +
+                // nodeIdsToCreateWaysFor.size() + " lastNodeId is "+
+                // lastNodeId);
+                OSITNNode newNode = addBarrierNode(lastNodeId);
                 newNodeId = newNode.getId();
                 int nodeType = getNodeMap().get(newNodeId);
-                
-                nodeIdsToCreateWaysFor.set(nodeIdsToCreateWaysFor.size()-1, newNodeId);
+
+                nodeIdsToCreateWaysFor.set(nodeIdsToCreateWaysFor.size() - 1,
+                        newNodeId);
             }
-            
 
-            Collection<EdgeIteratorState> newEdges = addOSMWay(nodeIdsToCreateWaysFor, wayFlags, wayOsmId);
+            Collection<EdgeIteratorState> newEdges = addOSMWay(
+                    nodeIdsToCreateWaysFor, wayFlags, wayOsmId);
 
             createdEdges.addAll(newEdges);
             if (doInsertAdditionalTowerNodes) {
-                long transfer[] = {newNodeId, lastNodeId};
+                long transfer[] = { newNodeId, lastNodeId };
                 TLongList partIds = new TLongArrayList(transfer);
                 newEdges = addOSMWay(partIds, wayFlags, wayOsmId);
                 createdEdges.addAll(newEdges);
@@ -1228,23 +1368,30 @@
      * @throws XMLStreamException
      */
     public void processRelation(Relation relation) throws XMLStreamException {
-        if (relation.hasTag(OSITNElement.TAG_KEY_TYPE, OSITNElement.TAG_VALUE_TYPE_RESTRICTION)) {
+        if (relation.hasTag(OSITNElement.TAG_KEY_TYPE,
+                OSITNElement.TAG_VALUE_TYPE_RESTRICTION)) {
             OSITNTurnRelation turnRelation = createTurnRelation(relation);
             if (turnRelation != null) {
-                long fromId = ((OSITNTurnRelation) turnRelation).getOsmIdFrom();
-                long toId = ((OSITNTurnRelation) turnRelation).getOsmIdTo();
+                long fromId = turnRelation.getOsmIdFrom();
+                long toId = turnRelation.getOsmIdTo();
                 // These were not originally added here. This could be used to
                 // clean up getEdgeIdToOsmidMap() as it will now contain all
                 // edgeIdToOsmId mappings
                 getOsmIdStoreRequiredSet().add(fromId);
                 getOsmIdStoreRequiredSet().add(toId);
 
-                logger.info(TURN_FROM_TO_VIA_FORMAT, turnRelation.getOsmIdFrom(), turnRelation.getOsmIdTo(), turnRelation.getVia());
-                ExtendedStorage extendedStorage = ((GraphHopperStorage) graphStorage).getExtendedStorage();
+                logger.info(TURN_FROM_TO_VIA_FORMAT,
+                        turnRelation.getOsmIdFrom(), turnRelation.getOsmIdTo(),
+                        turnRelation.getVia());
+                ExtendedStorage extendedStorage = ((GraphHopperStorage) graphStorage)
+                        .getExtendedStorage();
                 if (extendedStorage instanceof TurnCostStorage) {
-                    Collection<ITurnCostTableEntry> entries = encodingManager.analyzeTurnRelation(turnRelation, this);
+                    Collection<ITurnCostTableEntry> entries = encodingManager
+                            .analyzeTurnRelation(turnRelation, this);
                     for (ITurnCostTableEntry entry : entries) {
-                        ((TurnCostStorage) extendedStorage).addTurnInfo(entry.getVia(), entry.getEdgeFrom(), entry.getEdgeTo(), (int) entry.getFlags());
+                        ((TurnCostStorage) extendedStorage).addTurnInfo(
+                                entry.getVia(), entry.getEdgeFrom(),
+                                entry.getEdgeTo(), (int) entry.getFlags());
                     }
                 }
             }
@@ -1255,7 +1402,8 @@
         // }
     }
 
-    public long getOsmIdOfInternalEdge(int edgeId) {
+    @Override
+    public Long getOsmIdOfInternalEdge(int edgeId) {
         return getEdgeIdToOsmidMap().get(edgeId);
     }
 
@@ -1263,7 +1411,8 @@
         return getEdgeIdToOsmidMap().get(edgeId);
     }
 
-    public int getInternalNodeIdOfOsmNode(long nodeOsmId) {
+    @Override
+    public int getInternalNodeIdOfOsmNode(Long nodeOsmId) {
         int id = getNodeMap().get(nodeOsmId);
         if (id < TOWER_NODE)
             return -id - 3;
@@ -1307,7 +1456,7 @@
             return Double.NaN;
     }
 
-    private void processNode(Node node) {
+    private void processNode(OSITNNode node) {
         if (isInBounds(node)) {
             addNode(node);
 
@@ -1326,7 +1475,7 @@
         }
     }
 
-    boolean addNode(Node node) {
+    boolean addNode(OSITNNode node) {
         int nodeType = getNodeMap().get(node.getId());
         if (nodeType == EMPTY) {
             // logger.warn(MISSING_FROM_MAP_FORMAT, node.getId());
@@ -1352,7 +1501,8 @@
 
     void prepareWaysWithRelationInfo(Relation relation) {
         // is there at least one tag interesting for the registered encoders?
-        long handleRelationTags = encodingManager.handleRelationTags(relation, 0);
+        long handleRelationTags = encodingManager.handleRelationTags(relation,
+                0);
         // logger.warn(PREPARE_ONE_WAY_FORMAT, handleRelationTags);
         if (handleRelationTags == 0) {
             return;
@@ -1369,7 +1519,8 @@
 
             // Check if our new relation data is better comparated to the the
             // last one
-            long newRelationFlags = encodingManager.handleRelationTags(relation, oldRelationFlags);
+            long newRelationFlags = encodingManager.handleRelationTags(
+                    relation, oldRelationFlags);
             // logger.warn(APPLYING_RELATION_FORMAT, oldRelationFlags,
             // newRelationFlags);
             if (oldRelationFlags != newRelationFlags) {
@@ -1382,11 +1533,13 @@
         int tmpIndex = getNodeMap().get(osmId);
         if (tmpIndex == EMPTY) {
             // osmId is used exactly once
-            logger.info(OS_ITN_READER_PREPARE_HIGHWAY_NODE_EMPTY_PILLAR_FORMAT, osmId);
+            logger.info(OS_ITN_READER_PREPARE_HIGHWAY_NODE_EMPTY_PILLAR_FORMAT,
+                    osmId);
             getNodeMap().put(osmId, PILLAR_NODE);
         } else if (tmpIndex > EMPTY) {
             // mark node as tower node as it occured at least twice times
-            logger.info(OS_ITN_READER_PREPARE_HIGHWAY_NODE_PILLAR_TOWER_FORMAT, osmId);
+            logger.info(OS_ITN_READER_PREPARE_HIGHWAY_NODE_PILLAR_TOWER_FORMAT,
+                    osmId);
             getNodeMap().put(osmId, TOWER_NODE);
         } else {
             // tmpIndex is already negative (already tower node)
@@ -1409,8 +1562,10 @@
      * This method creates from an OSM way (via the osm ids) one or more edges
      * in the graph.
      */
-    Collection<EdgeIteratorState> addOSMWay(TLongList osmNodeIds, long flags, long wayOsmId) {
-        PointList pointList = new PointList(osmNodeIds.size(), nodeAccess.is3D());
+    Collection<EdgeIteratorState> addOSMWay(TLongList osmNodeIds, long flags,
+            long wayOsmId) {
+        PointList pointList = new PointList(osmNodeIds.size(),
+                nodeAccess.is3D());
         List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
         int firstNode = -1;
         int lastIndex = osmNodeIds.size() - 1;
@@ -1434,14 +1589,16 @@
                     // current file.
                     // => if the node before was a pillar node then convert into
                     // to tower node (as it is also end-standing).
-                    if (!pointList.isEmpty() && lastInBoundsPillarNode > -TOWER_NODE) {
+                    if (!pointList.isEmpty()
+                            && lastInBoundsPillarNode > -TOWER_NODE) {
                         // transform the pillar node to a tower node
                         tmpNode = lastInBoundsPillarNode;
                         tmpNode = handlePillarNode(tmpNode, osmId, null, true);
                         tmpNode = -tmpNode - 3;
                         if (pointList.getSize() > 1 && firstNode >= 0) {
                             // TOWER node
-                            newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
+                            newEdges.add(addEdge(firstNode, tmpNode, pointList,
+                                    flags, wayOsmId));
                             pointList.clear();
                             pointList.add(nodeAccess, tmpNode);
                         }
@@ -1452,7 +1609,9 @@
                 }
 
                 if (tmpNode <= -TOWER_NODE && tmpNode >= TOWER_NODE)
-                    throw new AssertionError("Mapped index not in correct bounds " + tmpNode + ", " + osmId);
+                    throw new AssertionError(
+                            "Mapped index not in correct bounds " + tmpNode
+                                    + ", " + osmId);
 
                 if (tmpNode > -TOWER_NODE) {
                     boolean convertToTowerNode = i == 0 || i == lastIndex;
@@ -1461,7 +1620,8 @@
                     }
 
                     // PILLAR node, but convert to towerNode if end-standing
-                    tmpNode = handlePillarNode(tmpNode, osmId, pointList, convertToTowerNode);
+                    tmpNode = handlePillarNode(tmpNode, osmId, pointList,
+                            convertToTowerNode);
                 }
 
                 if (tmpNode < TOWER_NODE) {
@@ -1469,7 +1629,8 @@
                     tmpNode = -tmpNode - 3;
                     pointList.add(nodeAccess, tmpNode);
                     if (firstNode >= 0) {
-                        newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
+                        newEdges.add(addEdge(firstNode, tmpNode, pointList,
+                                flags, wayOsmId));
                         pointList.clear();
                         pointList.add(nodeAccess, tmpNode);
                     }
@@ -1477,26 +1638,35 @@
                 }
             }
         } catch (RuntimeException ex) {
-            logger.error("Couldn't properly add edge with osm ids:" + osmNodeIds, ex);
+            logger.error("Couldn't properly add edge with osm ids:"
+                    + osmNodeIds, ex);
             if (exitOnlyPillarNodeException)
                 throw ex;
         }
         return newEdges;
     }
 
-    EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList, long flags, long wayOsmId) {
+    EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList,
+            long flags, long wayOsmId) {
         // sanity checks
         if (fromIndex < 0 || toIndex < 0)
-            throw new AssertionError("to or from index is invalid for this edge " + fromIndex + "->" + toIndex + ", points:" + pointList);
+            throw new AssertionError(
+                    "to or from index is invalid for this edge " + fromIndex
+                            + "->" + toIndex + ", points:" + pointList);
         if (pointList.getDimension() != nodeAccess.getDimension())
-            throw new AssertionError("Dimension does not match for pointList vs. nodeAccess " + pointList.getDimension() + " <-> " + nodeAccess.getDimension());
+            throw new AssertionError(
+                    "Dimension does not match for pointList vs. nodeAccess "
+                            + pointList.getDimension() + " <-> "
+                            + nodeAccess.getDimension());
 
         double towerNodeDistance = 0;
         double prevLat = pointList.getLatitude(0);
         double prevLon = pointList.getLongitude(0);
-        double prevEle = pointList.is3D() ? pointList.getElevation(0) : Double.NaN;
+        double prevEle = pointList.is3D() ? pointList.getElevation(0)
+                : Double.NaN;
         double lat, lon, ele = Double.NaN;
-        PointList pillarNodes = new PointList(pointList.getSize() - 2, nodeAccess.is3D());
+        PointList pillarNodes = new PointList(pointList.getSize() - 2,
+                nodeAccess.is3D());
         int nodes = pointList.getSize();
         for (int i = 1; i < nodes; i++) {
             // we could save some lines if we would use
@@ -1505,10 +1675,12 @@
             lon = pointList.getLongitude(i);
             if (pointList.is3D()) {
                 ele = pointList.getElevation(i);
-                towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon, prevEle, lat, lon, ele);
+                towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon,
+                        prevEle, lat, lon, ele);
                 prevEle = ele;
             } else
-                towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat, lon);
+                towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat,
+                        lon);
             prevLat = lat;
             prevLon = lon;
             if (nodes > 2 && i < nodes - 1) {
@@ -1526,7 +1698,8 @@
             towerNodeDistance = 0.0001;
         }
         logger.info("Add edge flags:" + flags);
-        EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex).setDistance(towerNodeDistance).setFlags(flags);
+        EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex)
+                .setDistance(towerNodeDistance).setFlags(flags);
         if (nodes > 2) {
             if (doSimplify)
                 simplifyAlgo.simplify(pillarNodes);
@@ -1555,18 +1728,23 @@
     /**
      * @return converted tower node
      */
-    private int handlePillarNode(int tmpNode, long osmId, PointList pointList, boolean convertToTowerNode) {
-        logger.info(CONVERTING_PILLAR_TO_PILLAR_FORMAT, osmId, convertToTowerNode);
+    private int handlePillarNode(int tmpNode, long osmId, PointList pointList,
+            boolean convertToTowerNode) {
+        logger.info(CONVERTING_PILLAR_TO_PILLAR_FORMAT, osmId,
+                convertToTowerNode);
         tmpNode = tmpNode - 3;
         double lat = pillarInfo.getLatitude(tmpNode);
         double lon = pillarInfo.getLongitude(tmpNode);
         double ele = pillarInfo.getElevation(tmpNode);
         if (lat == Double.MAX_VALUE || lon == Double.MAX_VALUE)
-            throw new RuntimeException("Conversion pillarNode to towerNode already happended!? " + "osmId:" + osmId + " pillarIndex:" + tmpNode);
+            throw new RuntimeException(
+                    "Conversion pillarNode to towerNode already happended!? "
+                            + "osmId:" + osmId + " pillarIndex:" + tmpNode);
 
         if (convertToTowerNode) {
             // convert pillarNode type to towerNode, make pillar values invalid
-            pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);
+            pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE,
+                    Double.MAX_VALUE);
             tmpNode = addTowerNode(osmId, lat, lon, ele);
         } else {
             if (pointList.is3D())
@@ -1575,7 +1753,7 @@
                 pointList.add(lat, lon);
         }
 
-        return (int) tmpNode;
+        return tmpNode;
     }
 
     protected void finishedReading() {
@@ -1593,21 +1771,24 @@
     /**
      * Create a copy of the barrier node
      */
-    private OSMNode addBarrierNode(long nodeId) {
-        OSMNode newNode = null;
+    private OSITNNode addBarrierNode(long nodeId) {
+        OSITNNode newNode = null;
         int graphIndex = getNodeMap().get(nodeId);
-//        System.out.println("graphIndex BEFORE is " + graphIndex);
+        // System.out.println("graphIndex BEFORE is " + graphIndex);
 
         if (graphIndex < TOWER_NODE) {
             graphIndex = -graphIndex - 3;
-//            System.out.println("Create Tower node for nodeId " + nodeId + " graphIndex is " + graphIndex);
-            newNode = new OSMNode(createNewNodeId(), nodeAccess, graphIndex);
+            // System.out.println("Create Tower node for nodeId " + nodeId +
+            // " graphIndex is " + graphIndex);
+            newNode = new OSITNNode(createNewNodeId(), nodeAccess, graphIndex);
         } else {
             graphIndex = graphIndex - 3;
             try {
-//                System.out.println("Create Pillar node for nodeId " + nodeId + " graphIndex is " + graphIndex);
-                newNode = new OSMNode(createNewNodeId(), pillarInfo, graphIndex);
-//                System.out.println("newNode is " + newNode);
+                // System.out.println("Create Pillar node for nodeId " + nodeId
+                // + " graphIndex is " + graphIndex);
+                newNode = new OSITNNode(createNewNodeId(), pillarInfo,
+                        graphIndex);
+                // System.out.println("newNode is " + newNode);
             } catch (ArrayIndexOutOfBoundsException e) {
                 e.printStackTrace();
             }
@@ -1618,12 +1799,13 @@
         addNode(newNode);
         return newNode;
     }
+
     /**
      * Create a copy of the barrier node
      */
-    private OSMNode addBarrierNode(long nodeId, double lat, double lon) {
-        OSMNode newNode = null;
-        newNode = new OSMNode(createNewNodeId(), lat, lon);
+    private OSITNNode addBarrierNode(long nodeId, double lat, double lon) {
+        OSITNNode newNode = null;
+        newNode = new OSITNNode(createNewNodeId(), lat, lon);
 
         final long id = newNode.getId();
         prepareHighwayNode(id);
@@ -1638,7 +1820,8 @@
     /**
      * Add a zero length edge with reduced routing options to the graph.
      */
-    private Collection<EdgeIteratorState> addBarrierEdge(long fromId, long toId, long flags, long nodeFlags, long wayOsmId) {
+    private Collection<EdgeIteratorState> addBarrierEdge(long fromId,
+            long toId, long flags, long nodeFlags, long wayOsmId) {
         // clear barred directions from routing flags
         flags &= ~nodeFlags;
         // add edge
@@ -1656,7 +1839,9 @@
      *         relation
      */
     OSITNTurnRelation createTurnRelation(Relation relation) {
-        OSMTurnRelation.Type type = OSITNTurnRelation.getRestrictionType((String) relation.getTag(OSITNElement.TAG_KEY_RESTRICTION));
+        OSMTurnRelation.Type type = OSITNTurnRelation
+                .getRestrictionType(relation
+                        .getTag(OSITNElement.TAG_KEY_RESTRICTION));
 
         // Handle No Turn and Mandatory Turn Exceptions. This is done by
         // selectively ignoring restrictions based on excluded/included vehicle
@@ -1675,7 +1860,8 @@
             //
             // }
             // There is a no entry or mandatory turn
-            if (encodingManager.isVehicleQualifierTypeExcluded(relation) || encodingManager.isVehicleQualifierTypeIncluded(relation)) {
+            if (encodingManager.isVehicleQualifierTypeExcluded(relation)
+                    || encodingManager.isVehicleQualifierTypeIncluded(relation)) {
                 // The current encoder vehicle is excluded from this restriction
                 // so remove it OR (except buses=false)
                 // The current encoder vehicle is included in the exception so
@@ -1700,15 +1886,18 @@
                     } else if ("to".equals(member.role())) {
                         toWayID = ref;
                     }
-                } else if (OSMElement.NODE == member.type() && "via".equals(member.role())) {
+                } else if (OSMElement.NODE == member.type()
+                        && "via".equals(member.role())) {
                     viaNodeID = ref;
                 }
             }
 
-            if (type != OSMTurnRelation.Type.UNSUPPORTED && fromWayID >= 0 && toWayID >= 0) {
+            if (type != OSMTurnRelation.Type.UNSUPPORTED && fromWayID >= 0
+                    && toWayID >= 0) {
                 long foundViaNode = findViaNode(fromWayID, toWayID);
                 if (-1 < foundViaNode) {
-                    OSITNTurnRelation osmTurnRelation = new OSITNTurnRelation(fromWayID, foundViaNode, toWayID, type);
+                    OSITNTurnRelation osmTurnRelation = new OSITNTurnRelation(
+                            fromWayID, foundViaNode, toWayID, type);
                     return osmTurnRelation;
                 }
             }
@@ -1741,40 +1930,50 @@
     /**
      * Specify the type of the path calculation (car, bike, ...).
      */
+    @Override
     public OsItnReader setEncodingManager(EncodingManager acceptWay) {
         this.encodingManager = acceptWay;
         return this;
     }
 
+    @Override
     public OsItnReader setWayPointMaxDistance(double maxDist) {
         doSimplify = maxDist > 0;
         simplifyAlgo.setMaxDistance(maxDist);
         return this;
     }
 
+    @Override
     public OsItnReader setWorkerThreads(int numOfWorkers) {
         this.workerThreads = numOfWorkers;
         return this;
     }
 
+    @Override
     public OsItnReader setElevationProvider(ElevationProvider eleProvider) {
         if (eleProvider == null)
-            throw new IllegalStateException("Use the NOOP elevation provider instead of null or don't call setElevationProvider");
+            throw new IllegalStateException(
+                    "Use the NOOP elevation provider instead of null or don't call setElevationProvider");
 
         if (!nodeAccess.is3D() && ElevationProvider.NOOP != eleProvider)
-            throw new IllegalStateException("Make sure you graph accepts 3D data");
+            throw new IllegalStateException(
+                    "Make sure you graph accepts 3D data");
 
         this.eleProvider = eleProvider;
         return this;
     }
 
+    @Override
     public OsItnReader setOSMFile(File osmFile) {
         this.routingFile = osmFile;
         return this;
     }
 
     private void printInfo(String str) {
-        logger.info(PRINT_INFO_FORMAT, str, graphStorage.getNodes(), getNodeMap().getSize(), getNodeMap().getMemoryUsage(), getNodeFlagsMap().size(), getRelFlagsMap().size(), Helper.getMemInfo());
+        logger.info(PRINT_INFO_FORMAT, str, graphStorage.getNodes(),
+                getNodeMap().getSize(), getNodeMap().getMemoryUsage(),
+                getNodeFlagsMap().size(), getRelFlagsMap().size(),
+                Helper.getMemInfo());
     }
 
     @Override
@@ -1782,6 +1981,7 @@
         return getClass().getSimpleName();
     }
 
+    @Override
     public GraphStorage getGraphStorage() {
         return graphStorage;
     }
Index: core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnElement.java
===================================================================
--- core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnElement.java	(revision 2400)
+++ core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnElement.java	(working copy)
@@ -27,6 +27,9 @@
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
 
+import org.opengis.geometry.MismatchedDimensionException;
+import org.opengis.referencing.FactoryException;
+import org.opengis.referencing.operation.TransformException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -40,242 +43,277 @@
  * @author Peter
  */
 public abstract class OsDpnElement implements RoutingElement {
-	public static final int NODE = 0;
-	public static final int WAY = 1;
-	public static final int RELATION = 2;
-	private final int type;
-	private final long id;
-	private final Map<String, Object> properties = new HashMap<String, Object>(
-			5);
-	private static final Logger logger = LoggerFactory
-			.getLogger(OsDpnElement.class);
+    public static final int NODE = 0;
+    public static final int WAY = 1;
+    public static final int RELATION = 2;
+    private final int type;
+    private final String id;
+    private final Map<String, Object> properties = new HashMap<String, Object>(
+            5);
+    private static final Logger logger = LoggerFactory
+            .getLogger(OsDpnElement.class);
+
+    protected OsDpnElement(String id, int type) {
+        this.id = id;
+        this.type = type;
+    }
 
-	protected OsDpnElement(long id, int type) {
-		this.id = id;
-		this.type = type;
-	}
+    public String getId() {
+        return id;
+    }
 
-	public long getId() {
-		return id;
-	}
+    protected void readTags(XMLStreamReader parser) throws XMLStreamException,
+            MismatchedDimensionException, FactoryException, TransformException {
+        int event = parser.getEventType();
+        while (event != XMLStreamConstants.END_DOCUMENT
+                && (event != XMLStreamConstants.END_ELEMENT || !exitElement(parser))) {
+            if (event == XMLStreamConstants.CHARACTERS) {
+                event = parser.next();
+            } else {
+                if (event == XMLStreamConstants.START_ELEMENT) {
+                    // logger.info("LOCALNAME: {}", parser.getLocalName());
+                    switch (parser.getLocalName()) {
+                        case "pos":
+                        case "coordinates": {
+                            event = handleCoordinates(parser);
+                            break;
+                        }
+                        case "networkMember": {
+                            event = handleNetworkMember(parser);
+                            break;
+                        }
+                        case "posList": {
+                            event = handleMultiDimensionCoords(parser);
+                            break;
+                        }
+                        case "startNode":
+                        case "endNode": {
+                            event = handleNode(parser);
+                            break;
+                        }
+                        case "directedLink": {
+                            event = handleDirectedLink(parser);
+                            break;
+                        }
+                        case "instruction": {
+                            System.err.println("INSTRUCTION:");
+                            setTag("type", "restriction");
+                            event = handleTag("restriction", parser);
+                            break;
+                        }
+                        case "descriptiveTerm": {
+                            event = handleDescriptiveTerm(parser);
+                            break;
+                        }
+                        case "name": {
+                            event = handleTag("name", parser);
+                            break;
+                        }
+                        default: {
+                            event = parser.next();
+                        }
+                    }
+                } else {
+                    // logger.trace("EVENT:" + event);
+                    event = parser.next();
+                }
+            }
+        }
+    }
 
-	protected void readTags(XMLStreamReader parser) throws XMLStreamException {
-		int event = parser.getEventType();
-		while (event != XMLStreamConstants.END_DOCUMENT  && (event != XMLStreamConstants.END_ELEMENT || !exitElement(parser))) {
-			if (event == XMLStreamConstants.CHARACTERS) {
-				event = parser.next();
-			} else {
-				
-			if (event == XMLStreamConstants.START_ELEMENT) {
-				logger.info("LOCALNAME:"+parser.getLocalName());
-				switch (parser.getLocalName()) {
-				case "coordinates": {
-						event = handleCoordinates(parser);
-						break;
-					}
-				case "networkMember" : {
-					event = handleNetworkMember(parser);
-					break;
-				}
-				case "directedNode" : {
-					event = handleDirectedNode(parser);
-					break;
-				}
-				case "directedLink" : {
-					event = handleDirectedLink(parser);
-					break;
-				}
-				case "instruction" : {
-					System.err.println("INSTRUCTION:");
-					setTag("type", "restriction");
-					event = handleTag("restriction",parser);
-					break;
-				}
-				case "roadName" : {
-					event = handleTag("name", parser);
-					break;
-				}
-				default : {
-						event = parser.next();
-					}
-				}
-				
-				
-//				int attributeCount = parser.getAttributeCount();
-//				for (int i = 0; i < attributeCount; i++) {
-//					QName attributeName = parser.getAttributeName(i);
-//					System.err.println("QNAME:" + attributeName);
-//				}
-				
-				// read tag
-				// String key = parser.getAttributeValue(null, "k");
-				// String value = parser.getAttributeValue(null, "v");
-				// // ignore tags with empty values
-				// if (value != null && value.length() > 0)
-				// setTag(key, value);
+    private int handleDescriptiveTerm(XMLStreamReader parser)
+            throws XMLStreamException {
+        String roadType = parser.getElementText();
+        setTag("type", "route");
+        setTag("highway", roadType);
+        setTag("name", roadType);
+        return parser.getEventType();
+    }
 
-			}
-			else {
-				logger.info("EVENT:" + event);
-				event = parser.next();
-			}
-			}
-		}
-	}
+    private int handleDirectedLink(XMLStreamReader parser)
+            throws XMLStreamException {
+        String orientation = parser.getAttributeValue(null, "orientation");
+        String nodeId = parser.getAttributeValue(
+                "http://www.w3.org/1999/xlink", "href");
+        addDirectedLink(nodeId, orientation);
+        return parser.next();
+    }
 
-	private int handleDirectedLink(XMLStreamReader parser) throws XMLStreamException {
-		String orientation = parser.getAttributeValue(null, "orientation");
-		String nodeId = parser.getAttributeValue("http://www.w3.org/1999/xlink", "href");
-		addDirectedLink(nodeId, orientation);
-		return parser.next();
-	}
+    private int handleNode(XMLStreamReader parser) throws XMLStreamException {
+        String nodeId = parser.getAttributeValue(
+                "http://www.w3.org/1999/xlink", "href");
+        addNode(nodeId);
+        return parser.next();
+    }
 
-	private int handleDirectedNode(XMLStreamReader parser) throws XMLStreamException {
-		String orientation = parser.getAttributeValue(null, "orientation");
-		String nodeId = parser.getAttributeValue("http://www.w3.org/1999/xlink", "href");
-		addDirectedNode(nodeId, orientation);
-		return parser.next();
-	}
+    private int handleTag(String key, XMLStreamReader parser)
+            throws XMLStreamException {
+        properties.put(key, parser.getElementText());
+        return parser.getEventType();
+    }
 
-	private int handleTag(String key, XMLStreamReader parser) throws XMLStreamException {
-		properties.put(key, parser.getElementText());
-		return parser.getEventType();
-	}
+    private int handleNetworkMember(XMLStreamReader parser)
+            throws XMLStreamException {
+        String elementText = parser.getAttributeValue(
+                "http://www.w3.org/1999/xlink", "href");
+        parseNetworkMember(elementText);
+        return parser.next();
+    }
 
-	private int handleNetworkMember(XMLStreamReader parser) throws XMLStreamException {
-		String elementText = parser.getAttributeValue("http://www.w3.org/1999/xlink", "href");
-		parseNetworkMember(elementText);
-		return parser.next();
-	}
+    private int handleCoordinates(XMLStreamReader parser)
+            throws XMLStreamException, MismatchedDimensionException,
+            FactoryException, TransformException {
+        String elementText = parser.getElementText();
+        parseCoords(elementText);
+        return parser.getEventType();
+    }
 
-	private int handleCoordinates(XMLStreamReader parser)
-			throws XMLStreamException {
-		String elementText = parser.getElementText();
-		parseCoords(elementText);
-		return parser.getEventType();
-	}
+    private int handleMultiDimensionCoords(XMLStreamReader parser)
+            throws XMLStreamException {
+        String dimensionality = parser.getAttributeValue(null, "srsDimension");
+        logger.info("Dimensions:" + dimensionality);
+        String elementText = parser.getElementText();
+        parseCoords(Integer.valueOf(dimensionality), elementText);
+        return parser.getEventType();
+    }
 
-	protected abstract void parseCoords(String coordinates);
-	
-	protected abstract void addDirectedNode(String nodeId, String orientation);
-	
-	protected abstract void addDirectedLink(String nodeId, String orientation);
-	
-	protected abstract void parseNetworkMember(String elementText);
+    protected abstract void parseCoords(String coordinates)
+            throws MismatchedDimensionException, FactoryException,
+            TransformException;
 
-	private boolean exitElement(XMLStreamReader parser) {
-		switch(parser.getLocalName()) {
-		case "RoadNode" : 
-		case "RoadLink" :	return true;
-		}
-		return false;
-	}
+    protected abstract void parseCoords(int dimensions, String lineDefinition);
 
-	protected String tagsToString() {
-		if (properties.isEmpty())
-			return "<empty>";
+    protected abstract void addNode(String nodeId);
 
-		StringBuilder tagTxt = new StringBuilder();
-		for (Map.Entry<String, Object> entry : properties.entrySet()) {
-			tagTxt.append(entry.getKey());
-			tagTxt.append("=");
-			tagTxt.append(entry.getValue());
-			tagTxt.append("\n");
-		}
-		return tagTxt.toString();
-	}
+    protected abstract void addDirectedLink(String nodeId, String orientation);
 
-	protected Map<String, Object> getTags() {
-		return properties;
-	}
+    protected abstract void parseNetworkMember(String elementText);
 
-	public void setTags(Map<String, String> newTags) {
-		properties.clear();
-		if (newTags != null)
-			for (Entry<String, String> e : newTags.entrySet()) {
-				setTag(e.getKey(), e.getValue());
-			}
-	}
+    private boolean exitElement(XMLStreamReader parser) {
+        switch (parser.getLocalName()) {
+            case "RouteNode":
+            case "RouteLink":
+            case "Route":
+                return true;
+        }
+        return false;
+    }
 
-	public boolean hasTags() {
-		return !properties.isEmpty();
-	}
+    protected String tagsToString() {
+        if (properties.isEmpty())
+            return "<empty>";
 
-	public String getTag(String name) {
-		return (String) properties.get(name);
-	}
+        StringBuilder tagTxt = new StringBuilder();
+        for (Map.Entry<String, Object> entry : properties.entrySet()) {
+            tagTxt.append(entry.getKey());
+            tagTxt.append("=");
+            tagTxt.append(entry.getValue());
+            tagTxt.append("\n");
+        }
+        return tagTxt.toString();
+    }
 
-	@SuppressWarnings("unchecked")
-	public <T> T getTag(String key, T defaultValue) {
-		T val = (T) properties.get(key);
-		if (val == null)
-			return defaultValue;
-		return val;
-	}
+    protected Map<String, Object> getTags() {
+        return properties;
+    }
 
-	public void setTag(String name, Object value) {
-		properties.put(name, value);
-	}
+    public void setTags(Map<String, String> newTags) {
+        properties.clear();
+        if (newTags != null)
+            for (Entry<String, String> e : newTags.entrySet()) {
+                setTag(e.getKey(), e.getValue());
+            }
+    }
 
-	/**
-	 * Chaeck that the object has a given tag with a given value.
-	 */
-	public boolean hasTag(String key, Object value) {
-		return value.equals(properties.get(key));
-	}
+    @Override
+    public boolean hasTags() {
+        return !properties.isEmpty();
+    }
 
-	/**
-	 * Check that a given tag has one of the specified values. If no values are
-	 * given, just checks for presence of the tag
-	 */
-	public boolean hasTag(String key, String... values) {
-		Object osmValue = properties.get(key);
-		if (osmValue == null)
-			return false;
+    @Override
+    public String getTag(String name) {
+        return (String) properties.get(name);
+    }
 
-		// tag present, no values given: success
-		if (values.length == 0)
-			return true;
+    @Override
+    @SuppressWarnings("unchecked")
+    public <T> T getTag(String key, T defaultValue) {
+        T val = (T) properties.get(key);
+        if (val == null)
+            return defaultValue;
+        return val;
+    }
 
-		for (String val : values) {
-			if (val.equals(osmValue))
-				return true;
-		}
-		return false;
-	}
+    @Override
+    public void setTag(String name, Object value) {
+        properties.put(name, value);
+    }
 
-	/**
-	 * Check that a given tag has one of the specified values.
-	 */
-	public final boolean hasTag(String key, Set<String> values) {
-		return values.contains(properties.get(key));
-	}
+    /**
+     * Chaeck that the object has a given tag with a given value.
+     */
+    @Override
+    public boolean hasTag(String key, Object value) {
+        return value.equals(properties.get(key));
+    }
 
-	/**
-	 * Check a number of tags in the given order for the any of the given
-	 * values. Used to parse hierarchical access restrictions
-	 */
-	public boolean hasTag(List<String> keyList, Set<String> values) {
-		for (String key : keyList) {
-			if (values.contains(properties.get(key)))
-				return true;
-		}
-		return false;
-	}
+    /**
+     * Check that a given tag has one of the specified values. If no values are
+     * given, just checks for presence of the tag
+     */
+    @Override
+    public boolean hasTag(String key, String... values) {
+        Object osmValue = properties.get(key);
+        if (osmValue == null)
+            return false;
 
-	public void removeTag(String name) {
-		properties.remove(name);
-	}
+        // tag present, no values given: success
+        if (values.length == 0)
+            return true;
 
-	public void clearTags() {
-		properties.clear();
-	}
+        for (String val : values) {
+            if (val.equals(osmValue))
+                return true;
+        }
+        return false;
+    }
 
-	public int getType() {
-		return type;
-	}
+    /**
+     * Check that a given tag has one of the specified values.
+     */
+    @Override
+    public final boolean hasTag(String key, Set<String> values) {
+        return values.contains(properties.get(key));
+    }
 
-	public boolean isType(int type) {
-		return this.type == type;
-	}
+    /**
+     * Check a number of tags in the given order for the any of the given
+     * values. Used to parse hierarchical access restrictions
+     */
+    @Override
+    public boolean hasTag(List<String> keyList, Set<String> values) {
+        for (String key : keyList) {
+            if (values.contains(properties.get(key)))
+                return true;
+        }
+        return false;
+    }
+
+    public void removeTag(String name) {
+        properties.remove(name);
+    }
+
+    public void clearTags() {
+        properties.clear();
+    }
+
+    @Override
+    public int getType() {
+        return type;
+    }
+
+    @Override
+    public boolean isType(int type) {
+        return this.type == type;
+    }
 }
Index: core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnReader.java
===================================================================
--- core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnReader.java	(revision 2400)
+++ core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnReader.java	(working copy)
@@ -1,14 +1,13 @@
 package com.graphhopper.reader.osgb.dpn;
 
 import static com.graphhopper.util.Helper.nf;
-import gnu.trove.list.TLongList;
-import gnu.trove.list.array.TLongArrayList;
-import gnu.trove.map.TIntLongMap;
-import gnu.trove.map.TLongLongMap;
-import gnu.trove.map.hash.TIntLongHashMap;
-import gnu.trove.map.hash.TLongLongHashMap;
-import gnu.trove.set.TLongSet;
-import gnu.trove.set.hash.TLongHashSet;
+import gnu.trove.map.TLongObjectMap;
+import gnu.trove.map.TObjectIntMap;
+import gnu.trove.map.TObjectLongMap;
+import gnu.trove.map.hash.TLongObjectHashMap;
+import gnu.trove.map.hash.TObjectIntHashMap;
+import gnu.trove.map.hash.TObjectLongHashMap;
+import gnu.trove.set.hash.THashSet;
 
 import java.io.File;
 import java.io.IOException;
@@ -22,31 +21,20 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.graphhopper.coll.GHLongIntBTree;
-import com.graphhopper.coll.LongIntMap;
 import com.graphhopper.reader.DataReader;
-import com.graphhopper.reader.ITurnCostTableEntry;
 import com.graphhopper.reader.Node;
 import com.graphhopper.reader.OSMElement;
-import com.graphhopper.reader.OSMNode;
-import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMTurnRelation;
 import com.graphhopper.reader.PillarInfo;
 import com.graphhopper.reader.Relation;
 import com.graphhopper.reader.RelationMember;
 import com.graphhopper.reader.RoutingElement;
 import com.graphhopper.reader.TurnRelation;
-import com.graphhopper.reader.Way;
 import com.graphhopper.reader.dem.ElevationProvider;
 import com.graphhopper.reader.osgb.OSITNTurnRelation;
-import com.graphhopper.reader.osgb.OSITNWay;
-import com.graphhopper.reader.osgb.OsItnInputFile;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.storage.ExtendedStorage;
-import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.GraphStorage;
 import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.TurnCostStorage;
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.DistanceCalc3D;
 import com.graphhopper.util.DistanceCalcEarth;
@@ -101,870 +89,874 @@
  * @author Peter Karich
  */
 
-public class OsDpnReader implements DataReader {
-	private InputStream is;
-
-	protected static final int EMPTY = -1;
-	// pillar node is >= 3
-	protected static final int PILLAR_NODE = 1;
-	// tower node is <= -3
-	protected static final int TOWER_NODE = -2;
-	private static final Logger logger = LoggerFactory
-			.getLogger(OsDpnReader.class);
-	private long locations;
-	private long skippedLocations;
-	private final GraphStorage graphStorage;
-	private final NodeAccess nodeAccess;
-	private EncodingManager encodingManager = null;
-	private int workerThreads = -1;
-	protected long zeroCounter = 0;
-	// Using the correct Map<Long, Integer> is hard. We need a memory efficient
-	// and fast solution for big data sets!
-	//
-	// very slow: new SparseLongLongArray
-	// only append and update possible (no unordered storage like with this
-	// doubleParse): new OSMIDMap
-	// same here: not applicable as ways introduces the nodes in 'wrong' order:
-	// new OSMIDSegmentedMap
-	// memory overhead due to open addressing and full rehash:
-	// nodeOsmIdToIndexMap = new BigLongIntMap(expectedNodes, EMPTY);
-	// smaller memory overhead for bigger data sets because of avoiding a
-	// "rehash"
-	// remember how many times a node was used to identify tower nodes
-	private LongIntMap osmNodeIdToInternalNodeMap;
-	private TLongLongHashMap osmNodeIdToNodeFlagsMap;
-	private TLongLongHashMap osmWayIdToRouteWeightMap;
-	// stores osm way ids used by relations to identify which edge ids needs to
-	// be mapped later
-	private TLongHashSet osmIdStoreRequiredSet = new TLongHashSet();
-	private TIntLongMap edgeIdToOsmIdMap;
-	private final TLongList barrierNodeIds = new TLongArrayList();
-	protected PillarInfo pillarInfo;
-	private final DistanceCalc distCalc = new DistanceCalcEarth();
-	private final DistanceCalc3D distCalc3D = new DistanceCalc3D();
-	private final DouglasPeucker simplifyAlgo = new DouglasPeucker();
-	private boolean doSimplify = true;
-	private int nextTowerId = 0;
-	private int nextPillarId = 0;
-	// negative but increasing to avoid clash with custom created OSM files
-	private long newUniqueOsmId = -Long.MAX_VALUE;
-	private ElevationProvider eleProvider = ElevationProvider.NOOP;
-	private boolean exitOnlyPillarNodeException = true;
-	private File routingFile;
-
-	public OsDpnReader(GraphStorage storage) {
-		this.graphStorage = storage;
-		this.nodeAccess = graphStorage.getNodeAccess();
-
-		osmNodeIdToInternalNodeMap = new GHLongIntBTree(200);
-		osmNodeIdToNodeFlagsMap = new TLongLongHashMap(200, .5f, 0, 0);
-		osmWayIdToRouteWeightMap = new TLongLongHashMap(200, .5f, 0, 0);
-		pillarInfo = new PillarInfo(nodeAccess.is3D(),
-				graphStorage.getDirectory());
-	}
-
-	@Override
-	public void readGraph() throws IOException {
-		if (encodingManager == null)
-			throw new IllegalStateException("Encoding manager was not set.");
+public class OsDpnReader implements DataReader<String> {
+    private InputStream is;
 
-		if (routingFile == null)
-			throw new IllegalStateException("No OS ITN file specified");
+    protected static final int EMPTY = -1;
+    // pillar node is >= 3
+    protected static final int PILLAR_NODE = 1;
+    // tower node is <= -3
+    protected static final int TOWER_NODE = -2;
+    private static final Logger logger = LoggerFactory
+            .getLogger(OsDpnReader.class);
+    private long locations;
+    private long skippedLocations;
+    private final GraphStorage graphStorage;
+    private final NodeAccess nodeAccess;
+    private EncodingManager encodingManager = null;
+    private int workerThreads = -1;
+    protected long zeroCounter = 0;
+    // Using the correct Map<Long, Integer> is hard. We need a memory efficient
+    // and fast solution for big data sets!
+    //
+    // very slow: new SparseLongLongArray
+    // only append and update possible (no unordered storage like with this
+    // doubleParse): new OSMIDMap
+    // same here: not applicable as ways introduces the nodes in 'wrong' order:
+    // new OSMIDSegmentedMap
+    // memory overhead due to open addressing and full rehash:
+    // nodeOsmIdToIndexMap = new BigLongIntMap(expectedNodes, EMPTY);
+    // smaller memory overhead for bigger data sets because of avoiding a
+    // "rehash"
+    // remember how many times a node was used to identify tower nodes
+    private TObjectIntMap<String> osmNodeIdToInternalNodeMap;
+    private TObjectLongMap<String> osmNodeIdToNodeFlagsMap;
+    private TObjectLongHashMap<String> osmWayIdToRouteWeightMap;
+    // stores osm way ids used by relations to identify which edge ids needs to
+    // be mapped later
+    private THashSet<String> osmIdStoreRequiredSet = new THashSet<String>();
+    private TLongObjectMap<String> edgeIdToOsmIdMap;
+    protected PillarInfo pillarInfo;
+    private final DistanceCalc distCalc = new DistanceCalcEarth();
+    private final DistanceCalc3D distCalc3D = new DistanceCalc3D();
+    private final DouglasPeucker simplifyAlgo = new DouglasPeucker();
+    private boolean doSimplify = true;
+    private int nextTowerId = 0;
+    private int nextPillarId = 0;
+    // negative but increasing to avoid clash with custom created OSM files
+    private long newUniqueOsmId = -Long.MAX_VALUE;
+    private ElevationProvider eleProvider = ElevationProvider.NOOP;
+    private final boolean exitOnlyPillarNodeException = true;
+    private File routingFile;
 
-		if (!routingFile.exists())
-			throw new IllegalStateException(
-					"Your specified OS ITN file does not exist:"
-							+ routingFile.getAbsolutePath());
+    public OsDpnReader(GraphStorage storage) {
+        this.graphStorage = storage;
+        this.nodeAccess = graphStorage.getNodeAccess();
 
-		StopWatch sw1 = new StopWatch().start();
-		preProcess(routingFile);
-		sw1.stop();
+        osmNodeIdToInternalNodeMap = new TObjectIntHashMap<String>(200, .5f, -1);
+        osmNodeIdToNodeFlagsMap = new TObjectLongHashMap<String>(200, .5f, 0);
+        osmWayIdToRouteWeightMap = new TObjectLongHashMap<String>(200, .5f, 0);
+        pillarInfo = new PillarInfo(nodeAccess.is3D(),
+                graphStorage.getDirectory());
+    }
 
-		StopWatch sw2 = new StopWatch().start();
-		writeOsm2Graph(routingFile);
-		sw2.stop();
+    @Override
+    public void readGraph() throws IOException {
+        if (encodingManager == null)
+            throw new IllegalStateException("Encoding manager was not set.");
 
-		logger.info("time(pass1): " + (int) sw1.getSeconds() + " pass2: "
-				+ (int) sw2.getSeconds() + " total:"
-				+ ((int) (sw1.getSeconds() + sw2.getSeconds())));
-	}
+        if (routingFile == null)
+            throw new IllegalStateException("No OS DPN file specified");
 
-	/**
-	 * Preprocessing of OSM file to select nodes which are used for highways.
-	 * This allows a more compact graph data structure.
-	 */
-	void preProcess(File osmFile) {
-		OsItnInputFile in = null;
-		try {
-			in = new OsItnInputFile(osmFile).setWorkerThreads(workerThreads)
-					.open();
+        if (!routingFile.exists())
+            throw new IllegalStateException(
+                    "Your specified OS DPN file does not exist:"
+                            + routingFile.getAbsolutePath());
 
-			long tmpWayCounter = 1;
-			long tmpRelationCounter = 1;
-			RoutingElement item;
-			while ((item = in.getNext()) != null) {
-				System.out.println("OsItnReader.preProcess( " + item.getType()
-						+ " )");
-				if (item.isType(OSMElement.WAY)) {
-					final OSITNWay way = (OSITNWay) item;
-					boolean valid = filterWay(way);
-					if (valid) {
-						TLongList wayNodes = way.getNodes();
-						int s = wayNodes.size();
-						for (int index = 0; index < s; index++) {
-							prepareHighwayNode(wayNodes.get(index));
-						}
+        StopWatch sw1 = new StopWatch().start();
+        preProcess(routingFile);
+        sw1.stop();
 
-						if (++tmpWayCounter % 500000 == 0) {
-							logger.info(nf(tmpWayCounter)
-									+ " (preprocess), osmIdMap:"
-									+ nf(getNodeMap().getSize()) + " ("
-									+ getNodeMap().getMemoryUsage() + "MB) "
-									+ Helper.getMemInfo());
-						}
-					}
-				}
-				if (item.isType(OSMElement.RELATION)) {
-					final OSMRelation relation = (OSMRelation) item;
-					if (!relation.isMetaRelation()
-							&& relation.hasTag("type", "route"))
-						prepareWaysWithRelationInfo(relation);
+        StopWatch sw2 = new StopWatch().start();
+        writeOsm2Graph(routingFile);
+        sw2.stop();
 
-					if (relation.hasTag("type", "restriction"))
-						prepareRestrictionRelation(relation);
+        logger.info("time(pass1): " + (int) sw1.getSeconds() + " pass2: "
+                + (int) sw2.getSeconds() + " total:"
+                + ((int) (sw1.getSeconds() + sw2.getSeconds())));
+    }
 
-					if (++tmpRelationCounter % 50000 == 0) {
-						logger.info(nf(tmpRelationCounter)
-								+ " (preprocess), osmWayMap:"
-								+ nf(getRelFlagsMap().size()) + " "
-								+ Helper.getMemInfo());
-					}
+    /**
+     * Preprocessing of OSM file to select nodes which are used for highways.
+     * This allows a more compact graph data structure.
+     */
+    void preProcess(File osmFile) {
+        OsDpnInputFile in = null;
+        try {
+            in = new OsDpnInputFile(osmFile).setWorkerThreads(workerThreads)
+                    .open();
 
-				}
-			}
-		} catch (Exception ex) {
-			// throw new RuntimeException("Problem while parsing file", ex);
-		} finally {
-			Helper.close(in);
-		}
-	}
+            long tmpWayCounter = 1;
+            long tmpRelationCounter = 1;
+            RoutingElement item;
+            while ((item = in.getNext()) != null) {
+                System.out.println("OsItnReader.preProcess( " + item.getType()
+                        + " )");
+                if (item.isType(OSMElement.WAY)) {
+                    final OsDpnWay way = (OsDpnWay) item;
+                    boolean valid = filterWay(way);
+                    if (valid) {
+                        List<String> wayNodes = way.getNodes();
+                        int s = wayNodes.size();
+                        for (int index = 0; index < s; index++) {
+                            prepareHighwayNode(wayNodes.get(index));
+                        }
 
-	private void prepareRestrictionRelation(OSMRelation relation) {
-		TurnRelation turnRelation = createTurnRelation(relation);
-		if (turnRelation != null) {
-			getOsmIdStoreRequiredSet().add(
-					((TurnRelation) turnRelation).getOsmIdFrom());
-			getOsmIdStoreRequiredSet().add(
-					((TurnRelation) turnRelation).getOsmIdTo());
-		}
-	}
+                        if (++tmpWayCounter % 500000 == 0) {
+                            logger.info(nf(tmpWayCounter)
+                                    + " (preprocess), osmIdMap:"
+                                    + nf(getNodeMap().size())
+                                    + Helper.getMemInfo());
+                        }
+                    }
+                }
+                // if (item.isType(OSMElement.RELATION)) {
+                // final OSMRelation relation = (OSMRelation) item;
+                // if (!relation.isMetaRelation()
+                // && relation.hasTag("type", "route"))
+                // prepareWaysWithRelationInfo(relation);
+                //
+                // if (relation.hasTag("type", "restriction"))
+                // prepareRestrictionRelation(relation);
+                //
+                // if (++tmpRelationCounter % 50000 == 0) {
+                // logger.info(nf(tmpRelationCounter)
+                // + " (preprocess), osmWayMap:"
+                // + nf(getRelFlagsMap().size()) + " "
+                // + Helper.getMemInfo());
+                // }
+                //
+                // }
+            }
+        } catch (Exception ex) {
+            throw new RuntimeException("Problem while parsing file", ex);
+        } finally {
+            Helper.close(in);
+        }
+    }
 
-	private TLongSet getOsmIdStoreRequiredSet() {
-		return osmIdStoreRequiredSet;
-	}
+    /*
+     * private void prepareRestrictionRelation(OSMRelation relation) {
+     * TurnRelation turnRelation = createTurnRelation(relation); if
+     * (turnRelation != null) {
+     * getOsmIdStoreRequiredSet().add(turnRelation.getOsmIdFrom());
+     * getOsmIdStoreRequiredSet().add(turnRelation.getOsmIdTo()); } }
+     */
 
-	private TIntLongMap getEdgeIdToOsmidMap() {
-		if (edgeIdToOsmIdMap == null)
-			edgeIdToOsmIdMap = new TIntLongHashMap(getOsmIdStoreRequiredSet()
-					.size());
+    private THashSet<String> getOsmIdStoreRequiredSet() {
+        return osmIdStoreRequiredSet;
+    }
 
-		return edgeIdToOsmIdMap;
-	}
+    private TLongObjectMap<String> getEdgeIdToOsmidMap() {
+        if (edgeIdToOsmIdMap == null)
+            edgeIdToOsmIdMap = new TLongObjectHashMap<String>(
+                    getOsmIdStoreRequiredSet().size());
 
-	/**
-	 * Filter ways but do not analyze properties wayNodes will be filled with
-	 * participating node ids.
-	 * <p/>
-	 * 
-	 * @return true the current xml entry is a way entry and has nodes
-	 */
-	boolean filterWay(OSITNWay way) {
-		// ignore broken geometry
-		if (way.getNodes().size() < 2)
-			return false;
+        return edgeIdToOsmIdMap;
+    }
 
-		// ignore multipolygon geometry
-		if (!way.hasTags())
-			return false;
+    /**
+     * Filter ways but do not analyze properties wayNodes will be filled with
+     * participating node ids.
+     * <p/>
+     * 
+     * @return true the current xml entry is a way entry and has nodes
+     */
+    boolean filterWay(OsDpnWay way) {
+        // ignore broken geometry
+        if (way.getNodes().size() < 2)
+            return false;
 
-		return encodingManager.acceptWay(way) > 0;
-	}
+        // ignore multipolygon geometry
+        if (!way.hasTags())
+            return false;
 
-	/**
-	 * Creates the edges and nodes files from the specified osm file.
-	 */
-	private void writeOsm2Graph(File osmFile) {
-		int tmp = (int) Math.max(getNodeMap().getSize() / 50, 100);
-		logger.info("creating graph. Found nodes (pillar+tower):"
-				+ nf(getNodeMap().getSize()) + ", " + Helper.getMemInfo());
-		graphStorage.create(tmp);
-		long wayStart = -1;
-		long relationStart = -1;
-		long counter = 1;
-		OsItnInputFile in = null;
-		try {
-			in = new OsItnInputFile(osmFile).setWorkerThreads(workerThreads)
-					.open();
-			LongIntMap nodeFilter = getNodeMap();
+        return encodingManager.acceptWay(way) > 0;
+    }
 
-			RoutingElement item;
-			while ((item = in.getNext()) != null) {
-				switch (item.getType()) {
-				case OSMElement.NODE:
-					logger.info("NODEITEMID:" + item.getId());
-					if (nodeFilter.get(item.getId()) != -1) {
-						processNode((Node) item);
-					}
-					break;
+    /**
+     * Creates the edges and nodes files from the specified osm file.
+     */
+    private void writeOsm2Graph(File osmFile) {
+        int tmp = Math.max(getNodeMap().size() / 50, 100);
+        logger.info("creating graph. Found nodes (pillar+tower):"
+                + nf(getNodeMap().size()) + ", " + Helper.getMemInfo());
+        graphStorage.create(tmp);
+        long wayStart = -1;
+        long relationStart = -1;
+        long counter = 1;
+        OsDpnInputFile in = null;
+        try {
+            in = new OsDpnInputFile(osmFile).setWorkerThreads(workerThreads)
+                    .open();
+            TObjectIntMap<String> nodeFilter = getNodeMap();
 
-				case OSMElement.WAY:
-					logger.info("WAY:" + item.getId() + ":" + wayStart);
-					if (wayStart < 0) {
-						logger.info(nf(counter) + ", now parsing ways");
-						wayStart = counter;
-					}
-					processWay((Way) item);
-					break;
-				case OSMElement.RELATION:
-					if (relationStart < 0) {
-						logger.info(nf(counter) + ", now parsing relations");
-						relationStart = counter;
-					}
-					processRelation((Relation) item);
-					break;
-				}
-				if (++counter % 5000000 == 0) {
-					logger.info(nf(counter) + ", locs:" + nf(locations) + " ("
-							+ skippedLocations + ") " + Helper.getMemInfo());
-				}
-			}
+            RoutingElement item;
+            while ((item = in.getNext()) != null) {
+                switch (item.getType()) {
+                    case OSMElement.NODE:
+                        OsDpnNode dpnNode = (OsDpnNode) item;
+                        String id = dpnNode.getId();
+                        logger.info("NODEITEMID:" + id);
+                        if (nodeFilter.get(id) != -1) {
+                            processNode(dpnNode);
+                        }
+                        break;
 
-			// logger.info("storage nodes:" + graphStorage.getNodes());
-		} catch (Exception ex) {
-//			throw new RuntimeException("Couldn't process file " + osmFile, ex);
-		} finally {
-			Helper.close(in);
-		}
+                    case OSMElement.WAY:
+                        OsDpnWay dpnWay = (OsDpnWay) item;
+                        logger.info("WAY:" + dpnWay.getId() + ":" + wayStart);
+                        if (wayStart < 0) {
+                            logger.info(nf(counter) + ", now parsing ways");
+                            wayStart = counter;
+                        }
+                        processWay(dpnWay);
+                        break;
+                    case OSMElement.RELATION:
+                        if (relationStart < 0) {
+                            logger.info(nf(counter) + ", now parsing relations");
+                            relationStart = counter;
+                        }
+                        processRelation((Relation) item);
+                        break;
+                }
+                if (++counter % 5000000 == 0) {
+                    logger.info(nf(counter) + ", locs:" + nf(locations) + " ("
+                            + skippedLocations + ") " + Helper.getMemInfo());
+                }
+            }
 
-		finishedReading();
-		if (graphStorage.getNodes() == 0)
-			throw new IllegalStateException("osm must not be empty. read "
-					+ counter + " lines and " + locations + " locations");
-	}
+            // logger.info("storage nodes:" + graphStorage.getNodes());
+        } catch (Exception ex) {
+            System.out.println(ex.getClass());
+            // throw new RuntimeException("Couldn't process file " + osmFile,
+            // ex);
+        } finally {
+            Helper.close(in);
+        }
 
-	/**
-	 * Process properties, encode flags and create edges for the way.
-	 */
-	void processWay(Way way) {
-		if (way.getNodes().size() < 2)
-			return;
+        finishedReading();
+        if (graphStorage.getNodes() == 0)
+            throw new IllegalStateException("osm must not be empty. read "
+                    + counter + " lines and " + locations + " locations");
+    }
 
-		// ignore multipolygon geometry
-		if (!way.hasTags())
-			return;
+    /**
+     * Process properties, encode flags and create edges for the way.
+     */
+    void processWay(OsDpnWay way) {
+        if (way.getNodes().size() < 2)
+            return;
 
-		long wayOsmId = way.getId();
+        // ignore multipolygon geometry
+        if (!way.hasTags())
+            return;
 
-		long includeWay = encodingManager.acceptWay(way);
-		if (includeWay == 0)
-			return;
+        String wayOsmId = way.getId();
 
-		long relationFlags = getRelFlagsMap().get(way.getId());
+        long includeWay = encodingManager.acceptWay(way);
+        if (includeWay == 0)
+            return;
 
-		// TODO move this after we have created the edge and know the
-		// coordinates => encodingManager.applyWayTags
-		// estimate length of the track e.g. for ferry speed calculation
-		TLongList osmNodeIds = way.getNodes();
-		if (osmNodeIds.size() > 1) {
-			int first = getNodeMap().get(osmNodeIds.get(0));
-			int last = getNodeMap().get(osmNodeIds.get(osmNodeIds.size() - 1));
-			double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
-			double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
-			if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon)
-					&& !Double.isNaN(lastLat) && !Double.isNaN(lastLon)) {
-				double estimatedDist = distCalc.calcDist(firstLat, firstLon,
-						lastLat, lastLon);
-				way.setTag("estimated_distance", estimatedDist);
-				way.setTag("estimated_center", new GHPoint(
-						(firstLat + lastLat) / 2, (firstLon + lastLon) / 2));
-			}
-		}
+        long relationFlags = getRelFlagsMap().get(way.getId());
 
-		long wayFlags = encodingManager.handleWayTags(way, includeWay,
-				relationFlags);
-		if (wayFlags == 0)
-			return;
+        // TODO move this after we have created the edge and know the
+        // coordinates => encodingManager.applyWayTags
+        // estimate length of the track e.g. for ferry speed calculation
+        List<String> osmNodeIds = way.getNodes();
+        if (osmNodeIds.size() > 1) {
+            int first = getNodeMap().get(osmNodeIds.get(0));
+            int last = getNodeMap().get(osmNodeIds.get(osmNodeIds.size() - 1));
+            double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
+            double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
+            if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon)
+                    && !Double.isNaN(lastLat) && !Double.isNaN(lastLon)) {
+                double estimatedDist = distCalc.calcDist(firstLat, firstLon,
+                        lastLat, lastLon);
+                way.setTag("estimated_distance", estimatedDist);
+                way.setTag("estimated_center", new GHPoint(
+                        (firstLat + lastLat) / 2, (firstLon + lastLon) / 2));
+            }
+        }
 
-		List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
-		// look for barriers along the way
-		final int size = osmNodeIds.size();
-		int lastBarrier = -1;
-		for (int i = 0; i < size; i++) {
-			long nodeId = osmNodeIds.get(i);
-			long nodeFlags = getNodeFlagsMap().get(nodeId);
-			// barrier was spotted and way is otherwise passable for that mode
-			// of travel
-			if (nodeFlags > 0) {
-				if ((nodeFlags & wayFlags) > 0) {
-					// remove barrier to avoid duplicates
-					getNodeFlagsMap().put(nodeId, 0);
+        long wayFlags = encodingManager.handleWayTags(way, includeWay,
+                relationFlags);
+        if (wayFlags == 0)
+            return;
 
-					// create shadow node copy for zero length edge
-					long newNodeId = addBarrierNode(nodeId);
-					if (i > 0) {
-						// start at beginning of array if there was no previous
-						// barrier
-						if (lastBarrier < 0)
-							lastBarrier = 0;
+        List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
+        // look for barriers along the way
+        final int size = osmNodeIds.size();
+        int lastBarrier = -1;
+        for (int i = 0; i < size; i++) {
+            String nodeId = osmNodeIds.get(i);
+            long nodeFlags = getNodeFlagsMap().get(nodeId);
+            // barrier was spotted and way is otherwise passable for that mode
+            // of travel
+            if (nodeFlags > 0) {
+                if ((nodeFlags & wayFlags) > 0) {
+                    // remove barrier to avoid duplicates
+                    getNodeFlagsMap().put(nodeId, 0);
 
-						// add way up to barrier shadow node
-						long transfer[] = osmNodeIds.toArray(lastBarrier, i
-								- lastBarrier + 1);
-						transfer[transfer.length - 1] = newNodeId;
-						TLongList partIds = new TLongArrayList(transfer);
-						createdEdges.addAll(addOSMWay(partIds, wayFlags,
-								wayOsmId));
+                    // create shadow node copy for zero length edge
+                    String newNodeId = addBarrierNode(nodeId);
+                    if (i > 0) {
+                        // start at beginning of array if there was no previous
+                        // barrier
+                        if (lastBarrier < 0)
+                            lastBarrier = 0;
 
-						// create zero length edge for barrier
-						createdEdges.addAll(addBarrierEdge(newNodeId, nodeId,
-								wayFlags, nodeFlags, wayOsmId));
-					} else {
-						// run edge from real first node to shadow node
-						createdEdges.addAll(addBarrierEdge(nodeId, newNodeId,
-								wayFlags, nodeFlags, wayOsmId));
+                        // add way up to barrier shadow node
+                        String transfer[] = { "" };
+                        transfer = osmNodeIds.subList(lastBarrier,
+                                i - lastBarrier + 1).toArray(transfer);
+                        transfer[transfer.length - 1] = newNodeId;
+                        createdEdges.addAll(addOSMWay(transfer, wayFlags,
+                                wayOsmId));
 
-						// exchange first node for created barrier node
-						osmNodeIds.set(0, newNodeId);
-					}
-					// remember barrier for processing the way behind it
-					lastBarrier = i;
-				}
-			}
-		}
+                        // create zero length edge for barrier
+                        createdEdges.addAll(addBarrierEdge(newNodeId, nodeId,
+                                wayFlags, nodeFlags, wayOsmId));
+                    } else {
+                        // run edge from real first node to shadow node
+                        createdEdges.addAll(addBarrierEdge(nodeId, newNodeId,
+                                wayFlags, nodeFlags, wayOsmId));
 
-		// just add remainder of way to graph if barrier was not the last node
-		if (lastBarrier >= 0) {
-			if (lastBarrier < size - 1) {
-				long transfer[] = osmNodeIds.toArray(lastBarrier, size
-						- lastBarrier);
-				TLongList partNodeIds = new TLongArrayList(transfer);
-				createdEdges.addAll(addOSMWay(partNodeIds, wayFlags, wayOsmId));
-			}
-		} else {
-			// no barriers - simply add the whole way
-			createdEdges.addAll(addOSMWay(way.getNodes(), wayFlags, wayOsmId));
-		}
+                        // exchange first node for created barrier node
+                        osmNodeIds.set(0, newNodeId);
+                    }
+                    // remember barrier for processing the way behind it
+                    lastBarrier = i;
+                }
+            }
+        }
 
-		for (EdgeIteratorState edge : createdEdges) {
-			encodingManager.applyWayTags(way, edge);
-		}
-	}
+        // just add remainder of way to graph if barrier was not the last node
+        if (lastBarrier >= 0) {
+            if (lastBarrier < size - 1) {
+                String transfer[] = { "" };
+                transfer = osmNodeIds.subList(lastBarrier, size - lastBarrier)
+                        .toArray(transfer);
+                createdEdges.addAll(addOSMWay(transfer, wayFlags, wayOsmId));
+            }
+        } else {
+            // no barriers - simply add the whole way
+            String transfer[] = { "" };
+            transfer = way.getNodes().toArray(transfer);
+            createdEdges.addAll(addOSMWay(transfer, wayFlags, wayOsmId));
+        }
 
-	public void processRelation(Relation relation) throws XMLStreamException {
-//		if (relation.hasTag("type", "restriction")) {
-//			TurnRelation turnRelation = createTurnRelation(relation);
-//			if (turnRelation != null) {
-//				ExtendedStorage extendedStorage = ((GraphHopperStorage) graphStorage)
-//						.getExtendedStorage();
-//				if (extendedStorage instanceof TurnCostStorage) {
-//					Collection<ITurnCostTableEntry> entries = encodingManager
-//							.analyzeTurnRelation(turnRelation, this);
-//					for (ITurnCostTableEntry entry : entries) {
-//						((TurnCostStorage) extendedStorage).setTurnCosts(
-//								entry.nodeVia, entry.edgeFrom, entry.edgeTo,
-//								(int) entry.flags);
-//					}
-//				}
-//			}
-//		}
-	}
+        for (EdgeIteratorState edge : createdEdges) {
+            encodingManager.applyWayTags(way, edge);
+        }
+    }
 
-	public long getOsmIdOfInternalEdge(int edgeId) {
-		return getEdgeIdToOsmidMap().get(edgeId);
-	}
+    public void processRelation(Relation relation) throws XMLStreamException {
+        // if (relation.hasTag("type", "restriction")) {
+        // TurnRelation turnRelation = createTurnRelation(relation);
+        // if (turnRelation != null) {
+        // ExtendedStorage extendedStorage = ((GraphHopperStorage) graphStorage)
+        // .getExtendedStorage();
+        // if (extendedStorage instanceof TurnCostStorage) {
+        // Collection<ITurnCostTableEntry> entries = encodingManager
+        // .analyzeTurnRelation(turnRelation, this);
+        // for (ITurnCostTableEntry entry : entries) {
+        // ((TurnCostStorage) extendedStorage).setTurnCosts(
+        // entry.nodeVia, entry.edgeFrom, entry.edgeTo,
+        // (int) entry.flags);
+        // }
+        // }
+        // }
+        // }
+    }
 
-	public int getInternalNodeIdOfOsmNode(long nodeOsmId) {
-		int id = getNodeMap().get(nodeOsmId);
-		if (id < TOWER_NODE)
-			return -id - 3;
+    @Override
+    public String getOsmIdOfInternalEdge(int edgeId) {
+        return getEdgeIdToOsmidMap().get(edgeId);
+    }
 
-		return EMPTY;
-	}
+    @Override
+    public int getInternalNodeIdOfOsmNode(String nodeOsmId) {
+        int id = getNodeMap().get(nodeOsmId);
+        if (id < TOWER_NODE)
+            return -id - 3;
 
-	// TODO remove this ugly stuff via better preparsing phase! E.g. putting
-	// every tags etc into a helper file!
-	double getTmpLatitude(int id) {
-		if (id == EMPTY)
-			return Double.NaN;
-		if (id < TOWER_NODE) {
-			// tower node
-			id = -id - 3;
-			return nodeAccess.getLatitude(id);
-		} else if (id > -TOWER_NODE) {
-			// pillar node
-			id = id - 3;
-			return pillarInfo.getLatitude(id);
-		} else
-			// e.g. if id is not handled from preparse (e.g. was ignored via
-			// isInBounds)
-			return Double.NaN;
-	}
+        return EMPTY;
+    }
 
-	double getTmpLongitude(int id) {
-		if (id == EMPTY)
-			return Double.NaN;
-		if (id < TOWER_NODE) {
-			// tower node
-			id = -id - 3;
-			return nodeAccess.getLongitude(id);
-		} else if (id > -TOWER_NODE) {
-			// pillar node
-			id = id - 3;
-			return pillarInfo.getLon(id);
-		} else
-			// e.g. if id is not handled from preparse (e.g. was ignored via
-			// isInBounds)
-			return Double.NaN;
-	}
+    // TODO remove this ugly stuff via better preparsing phase! E.g. putting
+    // every tags etc into a helper file!
+    double getTmpLatitude(int id) {
+        if (id == EMPTY)
+            return Double.NaN;
+        if (id < TOWER_NODE) {
+            // tower node
+            id = -id - 3;
+            return nodeAccess.getLatitude(id);
+        } else if (id > -TOWER_NODE) {
+            // pillar node
+            id = id - 3;
+            return pillarInfo.getLatitude(id);
+        } else
+            // e.g. if id is not handled from preparse (e.g. was ignored via
+            // isInBounds)
+            return Double.NaN;
+    }
 
-	private void processNode(Node node) {
-		if (isInBounds(node)) {
-			addNode(node);
+    double getTmpLongitude(int id) {
+        if (id == EMPTY)
+            return Double.NaN;
+        if (id < TOWER_NODE) {
+            // tower node
+            id = -id - 3;
+            return nodeAccess.getLongitude(id);
+        } else if (id > -TOWER_NODE) {
+            // pillar node
+            id = id - 3;
+            return pillarInfo.getLon(id);
+        } else
+            // e.g. if id is not handled from preparse (e.g. was ignored via
+            // isInBounds)
+            return Double.NaN;
+    }
 
-			// analyze node tags for barriers
-			if (node.hasTags()) {
-				long nodeFlags = encodingManager.handleNodeTags(node);
-				if (nodeFlags != 0)
-					getNodeFlagsMap().put(node.getId(), nodeFlags);
-			}
+    private void processNode(OsDpnNode node) {
+        if (isInBounds(node)) {
+            addNode(node);
 
-			locations++;
-		} else {
-			skippedLocations++;
-		}
-	}
+            // analyze node tags for barriers
+            if (node.hasTags()) {
+                long nodeFlags = encodingManager.handleNodeTags(node);
+                if (nodeFlags != 0)
+                    getNodeFlagsMap().put(node.getId(), nodeFlags);
+            }
 
-	boolean addNode(Node node) {
-		int nodeType = getNodeMap().get(node.getId());
-		if (nodeType == EMPTY)
-			return false;
+            locations++;
+        } else {
+            skippedLocations++;
+        }
+    }
 
-		double lat = node.getLat();
-		double lon = node.getLon();
-		double ele = getElevation(node);
-		if (nodeType == TOWER_NODE) {
-			addTowerNode(node.getId(), lat, lon, ele);
-		} else if (nodeType == PILLAR_NODE) {
-			pillarInfo.setNode(nextPillarId, lat, lon, ele);
-			getNodeMap().put(node.getId(), nextPillarId + 3);
-			nextPillarId++;
-		}
-		return true;
-	}
+    boolean addNode(OsDpnNode node) {
+        int nodeType = getNodeMap().get(node.getId());
+        if (nodeType == EMPTY)
+            return false;
 
-	private double getElevation(Node node) {
-		return eleProvider.getEle(node.getLat(), node.getLon());
-	}
+        double lat = node.getLat();
+        double lon = node.getLon();
+        double ele = getElevation(node);
+        if (nodeType == TOWER_NODE) {
+            addTowerNode(node.getId(), lat, lon, ele);
+        } else if (nodeType == PILLAR_NODE) {
+            pillarInfo.setNode(nextPillarId, lat, lon, ele);
+            getNodeMap().put(node.getId(), nextPillarId + 3);
+            nextPillarId++;
+        }
+        return true;
+    }
 
-	void prepareWaysWithRelationInfo(OSMRelation osmRelation) {
-		// is there at least one tag interesting for the registed encoders?
-		if (encodingManager.handleRelationTags(osmRelation, 0) == 0)
-			return;
+    private double getElevation(Node node) {
+        return eleProvider.getEle(node.getLat(), node.getLon());
+    }
 
-		int size = osmRelation.getMembers().size();
-		for (int index = 0; index < size; index++) {
-			OSMRelation.Member member = osmRelation.getMembers().get(index);
-			if (member.type() != OSMRelation.Member.WAY)
-				continue;
+    /*
+     * void prepareWaysWithRelationInfo(OSMRelation osmRelation) { // is there
+     * at least one tag interesting for the registed encoders? if
+     * (encodingManager.handleRelationTags(osmRelation, 0) == 0) return;
+     * 
+     * int size = osmRelation.getMembers().size(); for (int index = 0; index <
+     * size; index++) { OSMRelation.Member member =
+     * osmRelation.getMembers().get(index); if (member.type() !=
+     * OSMRelation.Member.WAY) continue;
+     * 
+     * long osmId = member.ref(); long oldRelationFlags =
+     * getRelFlagsMap().get(osmId);
+     * 
+     * // Check if our new relation data is better comparated to the the // last
+     * one long newRelationFlags = encodingManager.handleRelationTags(
+     * osmRelation, oldRelationFlags); if (oldRelationFlags != newRelationFlags)
+     * getRelFlagsMap().put(osmId, newRelationFlags); } }
+     */
 
-			long osmId = member.ref();
-			long oldRelationFlags = getRelFlagsMap().get(osmId);
+    void prepareHighwayNode(String idStr) {
+        int tmpIndex = getNodeMap().get(idStr);
+        if (tmpIndex == EMPTY) {
+            // osmId is used exactly once
+            logger.debug("OsDpnReader.prepareHighwayNode(EMPTY->PILLAR)");
+            getNodeMap().put(idStr, PILLAR_NODE);
+        } else if (tmpIndex > EMPTY) {
+            // mark node as tower node as it occured at least twice times
+            logger.debug("OsDpnReader.prepareHighwayNode(PILLAR->TOWER)");
+            getNodeMap().put(idStr, TOWER_NODE);
+        } else {
+            // tmpIndex is already negative (already tower node)
+        }
+    }
 
-			// Check if our new relation data is better comparated to the the
-			// last one
-			long newRelationFlags = encodingManager.handleRelationTags(
-					osmRelation, oldRelationFlags);
-			if (oldRelationFlags != newRelationFlags)
-				getRelFlagsMap().put(osmId, newRelationFlags);
-		}
-	}
+    int addTowerNode(String osmId, double lat, double lon, double ele) {
+        if (nodeAccess.is3D())
+            nodeAccess.setNode(nextTowerId, lat, lon, ele);
+        else
+            nodeAccess.setNode(nextTowerId, lat, lon);
 
-	void prepareHighwayNode(long osmId) {
-		int tmpIndex = getNodeMap().get(osmId);
-		if (tmpIndex == EMPTY) {
-			// osmId is used exactly once
-			System.out.println("OsItnReader.prepareHighwayNode(EMPTY->PILLAR)");
-			getNodeMap().put(osmId, PILLAR_NODE);
-		} else if (tmpIndex > EMPTY) {
-			// mark node as tower node as it occured at least twice times
-			System.out.println("OsItnReader.prepareHighwayNode(PILLAR->TOWER)");
-			getNodeMap().put(osmId, TOWER_NODE);
-		} else {
-			// tmpIndex is already negative (already tower node)
-		}
-	}
+        int id = -(nextTowerId + 3);
+        getNodeMap().put(osmId, id);
+        nextTowerId++;
+        return id;
+    }
 
-	int addTowerNode(long osmId, double lat, double lon, double ele) {
-		if (nodeAccess.is3D())
-			nodeAccess.setNode(nextTowerId, lat, lon, ele);
-		else
-			nodeAccess.setNode(nextTowerId, lat, lon);
+    /**
+     * This method creates from an OSM way (via the osm ids) one or more edges
+     * in the graph.
+     */
+    Collection<EdgeIteratorState> addOSMWay(String[] osmNodeIds, long flags,
+            String wayOsmId) {
+        PointList pointList = new PointList(osmNodeIds.length,
+                nodeAccess.is3D());
+        List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
+        int firstNode = -1;
+        int lastIndex = osmNodeIds.length - 1;
+        int lastInBoundsPillarNode = -1;
+        try {
+            for (int i = 0; i < osmNodeIds.length; i++) {
+                String osmId = osmNodeIds[i];
+                int tmpNode = getNodeMap().get(osmId);
+                if (tmpNode == EMPTY)
+                    continue;
 
-		int id = -(nextTowerId + 3);
-		getNodeMap().put(osmId, id);
-		nextTowerId++;
-		return id;
-	}
+                // skip osmIds with no associated pillar or tower id (e.g.
+                // !OSMReader.isBounds)
+                if (tmpNode == TOWER_NODE)
+                    continue;
 
-	/**
-	 * This method creates from an OSM way (via the osm ids) one or more edges
-	 * in the graph.
-	 */
-	Collection<EdgeIteratorState> addOSMWay(TLongList osmNodeIds, long flags,
-			long wayOsmId) {
-		PointList pointList = new PointList(osmNodeIds.size(),
-				nodeAccess.is3D());
-		List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
-		int firstNode = -1;
-		int lastIndex = osmNodeIds.size() - 1;
-		int lastInBoundsPillarNode = -1;
-		try {
-			for (int i = 0; i < osmNodeIds.size(); i++) {
-				long osmId = osmNodeIds.get(i);
-				int tmpNode = getNodeMap().get(osmId);
-				if (tmpNode == EMPTY)
-					continue;
+                if (tmpNode == PILLAR_NODE) {
+                    // In some cases no node information is saved for the
+                    // specified osmId.
+                    // ie. a way references a <node> which does not exist in the
+                    // current file.
+                    // => if the node before was a pillar node then convert into
+                    // to tower node (as it is also end-standing).
+                    if (!pointList.isEmpty()
+                            && lastInBoundsPillarNode > -TOWER_NODE) {
+                        // transform the pillar node to a tower node
+                        tmpNode = lastInBoundsPillarNode;
+                        tmpNode = handlePillarNode(tmpNode, osmId, null, true);
+                        tmpNode = -tmpNode - 3;
+                        if (pointList.getSize() > 1 && firstNode >= 0) {
+                            // TOWER node
+                            newEdges.add(addEdge(firstNode, tmpNode, pointList,
+                                    flags, wayOsmId));
+                            pointList.clear();
+                            pointList.add(nodeAccess, tmpNode);
+                        }
+                        firstNode = tmpNode;
+                        lastInBoundsPillarNode = -1;
+                    }
+                    continue;
+                }
 
-				// skip osmIds with no associated pillar or tower id (e.g.
-				// !OSMReader.isBounds)
-				if (tmpNode == TOWER_NODE)
-					continue;
+                if (tmpNode <= -TOWER_NODE && tmpNode >= TOWER_NODE)
+                    throw new AssertionError(
+                            "Mapped index not in correct bounds " + tmpNode
+                                    + ", " + osmId);
 
-				if (tmpNode == PILLAR_NODE) {
-					// In some cases no node information is saved for the
-					// specified osmId.
-					// ie. a way references a <node> which does not exist in the
-					// current file.
-					// => if the node before was a pillar node then convert into
-					// to tower node (as it is also end-standing).
-					if (!pointList.isEmpty()
-							&& lastInBoundsPillarNode > -TOWER_NODE) {
-						// transform the pillar node to a tower node
-						tmpNode = lastInBoundsPillarNode;
-						tmpNode = handlePillarNode(tmpNode, osmId, null, true);
-						tmpNode = -tmpNode - 3;
-						if (pointList.getSize() > 1 && firstNode >= 0) {
-							// TOWER node
-							newEdges.add(addEdge(firstNode, tmpNode, pointList,
-									flags, wayOsmId));
-							pointList.clear();
-							pointList.add(nodeAccess, tmpNode);
-						}
-						firstNode = tmpNode;
-						lastInBoundsPillarNode = -1;
-					}
-					continue;
-				}
+                if (tmpNode > -TOWER_NODE) {
+                    boolean convertToTowerNode = i == 0 || i == lastIndex;
+                    if (!convertToTowerNode) {
+                        lastInBoundsPillarNode = tmpNode;
+                    }
 
-				if (tmpNode <= -TOWER_NODE && tmpNode >= TOWER_NODE)
-					throw new AssertionError(
-							"Mapped index not in correct bounds " + tmpNode
-									+ ", " + osmId);
+                    // PILLAR node, but convert to towerNode if end-standing
+                    tmpNode = handlePillarNode(tmpNode, osmId, pointList,
+                            convertToTowerNode);
+                }
 
-				if (tmpNode > -TOWER_NODE) {
-					boolean convertToTowerNode = i == 0 || i == lastIndex;
-					if (!convertToTowerNode) {
-						lastInBoundsPillarNode = tmpNode;
-					}
+                if (tmpNode < TOWER_NODE) {
+                    // TOWER node
+                    tmpNode = -tmpNode - 3;
+                    pointList.add(nodeAccess, tmpNode);
+                    if (firstNode >= 0) {
+                        newEdges.add(addEdge(firstNode, tmpNode, pointList,
+                                flags, wayOsmId));
+                        pointList.clear();
+                        pointList.add(nodeAccess, tmpNode);
+                    }
+                    firstNode = tmpNode;
+                }
+            }
+        } catch (RuntimeException ex) {
+            logger.error("Couldn't properly add edge with osm ids:"
+                    + osmNodeIds, ex);
+            if (exitOnlyPillarNodeException)
+                throw ex;
+        }
+        return newEdges;
+    }
 
-					// PILLAR node, but convert to towerNode if end-standing
-					tmpNode = handlePillarNode(tmpNode, osmId, pointList,
-							convertToTowerNode);
-				}
+    EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList,
+            long flags, String wayOsmId) {
+        // sanity checks
+        if (fromIndex < 0 || toIndex < 0)
+            throw new AssertionError(
+                    "to or from index is invalid for this edge " + fromIndex
+                            + "->" + toIndex + ", points:" + pointList);
+        if (pointList.getDimension() != nodeAccess.getDimension())
+            throw new AssertionError(
+                    "Dimension does not match for pointList vs. nodeAccess "
+                            + pointList.getDimension() + " <-> "
+                            + nodeAccess.getDimension());
 
-				if (tmpNode < TOWER_NODE) {
-					// TOWER node
-					tmpNode = -tmpNode - 3;
-					pointList.add(nodeAccess, tmpNode);
-					if (firstNode >= 0) {
-						newEdges.add(addEdge(firstNode, tmpNode, pointList,
-								flags, wayOsmId));
-						pointList.clear();
-						pointList.add(nodeAccess, tmpNode);
-					}
-					firstNode = tmpNode;
-				}
-			}
-		} catch (RuntimeException ex) {
-			logger.error("Couldn't properly add edge with osm ids:"
-					+ osmNodeIds, ex);
-			if (exitOnlyPillarNodeException)
-				throw ex;
-		}
-		return newEdges;
-	}
+        double towerNodeDistance = 0;
+        double prevLat = pointList.getLatitude(0);
+        double prevLon = pointList.getLongitude(0);
+        double prevEle = pointList.is3D() ? pointList.getElevation(0)
+                : Double.NaN;
+        double lat, lon, ele = Double.NaN;
+        PointList pillarNodes = new PointList(pointList.getSize() - 2,
+                nodeAccess.is3D());
+        int nodes = pointList.getSize();
+        for (int i = 1; i < nodes; i++) {
+            // we could save some lines if we would use
+            // pointList.calcDistance(distCalc);
+            lat = pointList.getLatitude(i);
+            lon = pointList.getLongitude(i);
+            if (pointList.is3D()) {
+                ele = pointList.getElevation(i);
+                towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon,
+                        prevEle, lat, lon, ele);
+                prevEle = ele;
+            } else
+                towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat,
+                        lon);
+            prevLat = lat;
+            prevLon = lon;
+            if (nodes > 2 && i < nodes - 1) {
+                if (pillarNodes.is3D())
+                    pillarNodes.add(lat, lon, ele);
+                else
+                    pillarNodes.add(lat, lon);
+            }
+        }
+        if (towerNodeDistance == 0) {
+            // As investigation shows often two paths should have crossed via
+            // one identical point
+            // but end up in two very release points.
+            zeroCounter++;
+            towerNodeDistance = 0.0001;
+        }
 
-	EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList,
-			long flags, long wayOsmId) {
-		// sanity checks
-		if (fromIndex < 0 || toIndex < 0)
-			throw new AssertionError(
-					"to or from index is invalid for this edge " + fromIndex
-							+ "->" + toIndex + ", points:" + pointList);
-		if (pointList.getDimension() != nodeAccess.getDimension())
-			throw new AssertionError(
-					"Dimension does not match for pointList vs. nodeAccess "
-							+ pointList.getDimension() + " <-> "
-							+ nodeAccess.getDimension());
+        EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex)
+                .setDistance(towerNodeDistance).setFlags(flags);
+        if (nodes > 2) {
+            if (doSimplify)
+                simplifyAlgo.simplify(pillarNodes);
 
-		double towerNodeDistance = 0;
-		double prevLat = pointList.getLatitude(0);
-		double prevLon = pointList.getLongitude(0);
-		double prevEle = pointList.is3D() ? pointList.getElevation(0)
-				: Double.NaN;
-		double lat, lon, ele = Double.NaN;
-		PointList pillarNodes = new PointList(pointList.getSize() - 2,
-				nodeAccess.is3D());
-		int nodes = pointList.getSize();
-		for (int i = 1; i < nodes; i++) {
-			// we could save some lines if we would use
-			// pointList.calcDistance(distCalc);
-			lat = pointList.getLatitude(i);
-			lon = pointList.getLongitude(i);
-			if (pointList.is3D()) {
-				ele = pointList.getElevation(i);
-				towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon,
-						prevEle, lat, lon, ele);
-				prevEle = ele;
-			} else
-				towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat,
-						lon);
-			prevLat = lat;
-			prevLon = lon;
-			if (nodes > 2 && i < nodes - 1) {
-				if (pillarNodes.is3D())
-					pillarNodes.add(lat, lon, ele);
-				else
-					pillarNodes.add(lat, lon);
-			}
-		}
-		if (towerNodeDistance == 0) {
-			// As investigation shows often two paths should have crossed via
-			// one identical point
-			// but end up in two very release points.
-			zeroCounter++;
-			towerNodeDistance = 0.0001;
-		}
+            iter.setWayGeometry(pillarNodes);
+        }
+        storeOSMWayID(iter.getEdge(), wayOsmId);
+        return iter;
+    }
 
-		EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex)
-				.setDistance(towerNodeDistance).setFlags(flags);
-		if (nodes > 2) {
-			if (doSimplify)
-				simplifyAlgo.simplify(pillarNodes);
+    private void storeOSMWayID(int edgeId, String osmWayID) {
+        if (getOsmIdStoreRequiredSet().contains(osmWayID)) {
+            getEdgeIdToOsmidMap().put(edgeId, osmWayID);
+        }
+    }
 
-			iter.setWayGeometry(pillarNodes);
-		}
-		storeOSMWayID(iter.getEdge(), wayOsmId);
-		return iter;
-	}
+    /**
+     * @return converted tower node
+     */
+    private int handlePillarNode(int tmpNode, String osmId,
+            PointList pointList, boolean convertToTowerNode) {
+        logger.info("Converting Pillar " + osmId, " to pillar? "
+                + convertToTowerNode);
+        tmpNode = tmpNode - 3;
+        double lat = pillarInfo.getLatitude(tmpNode);
+        double lon = pillarInfo.getLongitude(tmpNode);
+        double ele = pillarInfo.getElevation(tmpNode);
+        if (lat == Double.MAX_VALUE || lon == Double.MAX_VALUE)
+            throw new RuntimeException(
+                    "Conversion pillarNode to towerNode already happended!? "
+                            + "osmId:" + osmId + " pillarIndex:" + tmpNode);
 
-	private void storeOSMWayID(int edgeId, long osmWayID) {
-		if (getOsmIdStoreRequiredSet().contains(osmWayID)) {
-			getEdgeIdToOsmidMap().put(edgeId, osmWayID);
-		}
-	}
+        if (convertToTowerNode) {
+            // convert pillarNode type to towerNode, make pillar values invalid
+            pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE,
+                    Double.MAX_VALUE);
+            tmpNode = addTowerNode(osmId, lat, lon, ele);
+        } else {
+            if (pointList.is3D())
+                pointList.add(lat, lon, ele);
+            else
+                pointList.add(lat, lon);
+        }
 
-	/**
-	 * @return converted tower node
-	 */
-	private int handlePillarNode(int tmpNode, long osmId, PointList pointList,
-			boolean convertToTowerNode) {
-		logger.info("Converting Pillar " + osmId, " to pillar? "
-				+ convertToTowerNode);
-		tmpNode = tmpNode - 3;
-		double lat = pillarInfo.getLatitude(tmpNode);
-		double lon = pillarInfo.getLongitude(tmpNode);
-		double ele = pillarInfo.getElevation(tmpNode);
-		if (lat == Double.MAX_VALUE || lon == Double.MAX_VALUE)
-			throw new RuntimeException(
-					"Conversion pillarNode to towerNode already happended!? "
-							+ "osmId:" + osmId + " pillarIndex:" + tmpNode);
+        return tmpNode;
+    }
 
-		if (convertToTowerNode) {
-			// convert pillarNode type to towerNode, make pillar values invalid
-			pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE,
-					Double.MAX_VALUE);
-			tmpNode = addTowerNode(osmId, lat, lon, ele);
-		} else {
-			if (pointList.is3D())
-				pointList.add(lat, lon, ele);
-			else
-				pointList.add(lat, lon);
-		}
+    protected void finishedReading() {
+        printInfo("way");
+        pillarInfo.clear();
+        eleProvider.release();
+        osmNodeIdToInternalNodeMap = null;
+        osmNodeIdToNodeFlagsMap = null;
+        osmWayIdToRouteWeightMap = null;
+        osmIdStoreRequiredSet = null;
+        edgeIdToOsmIdMap = null;
+    }
 
-		return (int) tmpNode;
-	}
+    /**
+     * Create a copy of the barrier node
+     */
+    String addBarrierNode(String nodeId) {
+        OsDpnNode newNode;
+        int graphIndex = getNodeMap().get(nodeId);
+        if (graphIndex < TOWER_NODE) {
+            graphIndex = -graphIndex - 3;
+            newNode = new OsDpnNode(createNewNodeId(), nodeAccess, graphIndex);
+        } else {
+            graphIndex = graphIndex - 3;
+            newNode = new OsDpnNode(createNewNodeId(), pillarInfo, graphIndex);
+        }
 
-	protected void finishedReading() {
-		printInfo("way");
-		pillarInfo.clear();
-		eleProvider.release();
-		osmNodeIdToInternalNodeMap = null;
-		osmNodeIdToNodeFlagsMap = null;
-		osmWayIdToRouteWeightMap = null;
-		osmIdStoreRequiredSet = null;
-		edgeIdToOsmIdMap = null;
-	}
+        final String id = newNode.getId();
+        prepareHighwayNode(id);
+        addNode(newNode);
+        return id;
+    }
 
-	/**
-	 * Create a copy of the barrier node
-	 */
-	long addBarrierNode(long nodeId) {
-		OSMNode newNode;
-		int graphIndex = getNodeMap().get(nodeId);
-		if (graphIndex < TOWER_NODE) {
-			graphIndex = -graphIndex - 3;
-			newNode = new OSMNode(createNewNodeId(), nodeAccess, graphIndex);
-		} else {
-			graphIndex = graphIndex - 3;
-			newNode = new OSMNode(createNewNodeId(), pillarInfo, graphIndex);
-		}
+    private String createNewNodeId() {
+        return String.valueOf(newUniqueOsmId++);
+    }
 
-		final long id = newNode.getId();
-		prepareHighwayNode(id);
-		addNode(newNode);
-		return id;
-	}
+    /**
+     * Add a zero length edge with reduced routing options to the graph.
+     */
+    Collection<EdgeIteratorState> addBarrierEdge(String fromId, String toId,
+            long flags, long nodeFlags, String wayOsmId) {
+        // clear barred directions from routing flags
+        flags &= ~nodeFlags;
+        // add edge
+        String barrierNodeIds[] = { fromId, toId };
+        return addOSMWay(barrierNodeIds, flags, wayOsmId);
+    }
 
-	private long createNewNodeId() {
-		return newUniqueOsmId++;
-	}
+    /**
+     * Creates an OSM turn relation out of an unspecified OSM relation
+     * <p>
+     * 
+     * @return the OSM turn relation, <code>null</code>, if unsupported turn
+     *         relation
+     */
+    TurnRelation createTurnRelation(Relation relation) {
+        OSMTurnRelation.Type type = OSITNTurnRelation
+                .getRestrictionType(relation.getTag("restriction"));
+        if (type != OSMTurnRelation.Type.UNSUPPORTED) {
+            long fromWayID = -1;
+            long viaNodeID = -1;
+            long toWayID = -1;
 
-	/**
-	 * Add a zero length edge with reduced routing options to the graph.
-	 */
-	Collection<EdgeIteratorState> addBarrierEdge(long fromId, long toId,
-			long flags, long nodeFlags, long wayOsmId) {
-		// clear barred directions from routing flags
-		flags &= ~nodeFlags;
-		// add edge
-		barrierNodeIds.clear();
-		barrierNodeIds.add(fromId);
-		barrierNodeIds.add(toId);
-		return addOSMWay(barrierNodeIds, flags, wayOsmId);
-	}
+            for (RelationMember member : relation.getMembers()) {
+                if (OSMElement.WAY == member.type()) {
+                    if ("from".equals(member.role())) {
+                        fromWayID = member.ref();
+                    } else if ("to".equals(member.role())) {
+                        toWayID = member.ref();
+                    }
+                } else if (OSMElement.NODE == member.type()
+                        && "via".equals(member.role())) {
+                    viaNodeID = member.ref();
+                }
+            }
+            if (type != OSMTurnRelation.Type.UNSUPPORTED && fromWayID >= 0
+                    && toWayID >= 0 && viaNodeID >= 0) {
+                return new OSMTurnRelation(fromWayID, viaNodeID, toWayID, type);
+            }
+        }
+        return null;
+    }
 
-	/**
-	 * Creates an OSM turn relation out of an unspecified OSM relation
-	 * <p>
-	 * 
-	 * @return the OSM turn relation, <code>null</code>, if unsupported turn
-	 *         relation
-	 */
-	TurnRelation createTurnRelation(Relation relation) {
-		OSMTurnRelation.Type type = OSITNTurnRelation
-				.getRestrictionType((String) relation.getTag("restriction"));
-		if (type != OSMTurnRelation.Type.UNSUPPORTED) {
-			long fromWayID = -1;
-			long viaNodeID = -1;
-			long toWayID = -1;
+    /**
+     * Filter method, override in subclass
+     */
+    boolean isInBounds(Node node) {
+        return true;
+    }
 
-			for (RelationMember member : relation.getMembers()) {
-				if (OSMElement.WAY == member.type()) {
-					if ("from".equals(member.role())) {
-						fromWayID = member.ref();
-					} else if ("to".equals(member.role())) {
-						toWayID = member.ref();
-					}
-				} else if (OSMElement.NODE == member.type()
-						&& "via".equals(member.role())) {
-					viaNodeID = member.ref();
-				}
-			}
-			if (type != OSMTurnRelation.Type.UNSUPPORTED && fromWayID >= 0
-					&& toWayID >= 0 && viaNodeID >= 0) {
-				return new OSMTurnRelation(fromWayID, viaNodeID, toWayID, type);
-			}
-		}
-		return null;
-	}
+    /**
+     * Maps OSM IDs (long) to internal node IDs (int)
+     */
+    protected TObjectIntMap<String> getNodeMap() {
+        return osmNodeIdToInternalNodeMap;
+    }
 
-	/**
-	 * Filter method, override in subclass
-	 */
-	boolean isInBounds(Node node) {
-		return true;
-	}
+    protected TObjectLongMap<String> getNodeFlagsMap() {
+        return osmNodeIdToNodeFlagsMap;
+    }
 
-	/**
-	 * Maps OSM IDs (long) to internal node IDs (int)
-	 */
-	protected LongIntMap getNodeMap() {
-		return osmNodeIdToInternalNodeMap;
-	}
+    TObjectLongHashMap<String> getRelFlagsMap() {
+        return osmWayIdToRouteWeightMap;
+    }
 
-	protected TLongLongMap getNodeFlagsMap() {
-		return osmNodeIdToNodeFlagsMap;
-	}
+    /**
+     * Specify the type of the path calculation (car, bike, ...).
+     */
+    @Override
+    public OsDpnReader setEncodingManager(EncodingManager acceptWay) {
+        this.encodingManager = acceptWay;
+        return this;
+    }
 
-	TLongLongHashMap getRelFlagsMap() {
-		return osmWayIdToRouteWeightMap;
-	}
+    @Override
+    public OsDpnReader setWayPointMaxDistance(double maxDist) {
+        doSimplify = maxDist > 0;
+        simplifyAlgo.setMaxDistance(maxDist);
+        return this;
+    }
 
-	/**
-	 * Specify the type of the path calculation (car, bike, ...).
-	 */
-	public OsDpnReader setEncodingManager(EncodingManager acceptWay) {
-		this.encodingManager = acceptWay;
-		return this;
-	}
+    @Override
+    public OsDpnReader setWorkerThreads(int numOfWorkers) {
+        this.workerThreads = numOfWorkers;
+        return this;
+    }
 
-	public OsDpnReader setWayPointMaxDistance(double maxDist) {
-		doSimplify = maxDist > 0;
-		simplifyAlgo.setMaxDistance(maxDist);
-		return this;
-	}
+    @Override
+    public OsDpnReader setElevationProvider(ElevationProvider eleProvider) {
+        if (eleProvider == null)
+            throw new IllegalStateException(
+                    "Use the NOOP elevation provider instead of null or don't call setElevationProvider");
 
-	public OsDpnReader setWorkerThreads(int numOfWorkers) {
-		this.workerThreads = numOfWorkers;
-		return this;
-	}
+        if (!nodeAccess.is3D() && ElevationProvider.NOOP != eleProvider)
+            throw new IllegalStateException(
+                    "Make sure you graph accepts 3D data");
 
-	public OsDpnReader setElevationProvider(ElevationProvider eleProvider) {
-		if (eleProvider == null)
-			throw new IllegalStateException(
-					"Use the NOOP elevation provider instead of null or don't call setElevationProvider");
+        this.eleProvider = eleProvider;
+        return this;
+    }
 
-		if (!nodeAccess.is3D() && ElevationProvider.NOOP != eleProvider)
-			throw new IllegalStateException(
-					"Make sure you graph accepts 3D data");
+    @Override
+    public OsDpnReader setOSMFile(File osmFile) {
+        this.routingFile = osmFile;
+        return this;
+    }
 
-		this.eleProvider = eleProvider;
-		return this;
-	}
+    private void printInfo(String str) {
+        LoggerFactory.getLogger(getClass()).info(
+                "finished " + str + " processing." + " nodes: "
+                        + graphStorage.getNodes() + ", osmIdMap.size:"
+                        + getNodeMap().size() + ", osmIdMap:"
+                        + ", nodeFlagsMap.size:" + getNodeFlagsMap().size()
+                        + ", relFlagsMap.size:" + getRelFlagsMap().size() + " "
+                        + Helper.getMemInfo());
+    }
 
-	public OsDpnReader setOSMFile(File osmFile) {
-		this.routingFile = osmFile;
-		return this;
-	}
+    @Override
+    public String toString() {
+        return getClass().getSimpleName();
+    }
 
-	private void printInfo(String str) {
-		LoggerFactory.getLogger(getClass()).info(
-				"finished " + str + " processing." + " nodes: "
-						+ graphStorage.getNodes() + ", osmIdMap.size:"
-						+ getNodeMap().getSize() + ", osmIdMap:"
-						+ getNodeMap().getMemoryUsage() + "MB"
-						+ ", nodeFlagsMap.size:" + getNodeFlagsMap().size()
-						+ ", relFlagsMap.size:" + getRelFlagsMap().size() + " "
-						+ Helper.getMemInfo());
-	}
-
-	@Override
-	public String toString() {
-		return getClass().getSimpleName();
-	}
-
-	public GraphStorage getGraphStorage() {
-		return graphStorage;
-	}
+    @Override
+    public GraphStorage getGraphStorage() {
+        return graphStorage;
+    }
 }
Index: core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
===================================================================
--- core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java	(revision 2400)
+++ core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java	(working copy)
@@ -1,13 +1,15 @@
 package com.graphhopper.reader;
 
+import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 
+import com.graphhopper.reader.osgb.OsItnReader;
 import com.graphhopper.routing.util.TurnCostEncoder;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
-import java.util.*;
 
 /**
  * Helper object which gives node cost entries for a given OSM-relation of type "restriction"
@@ -18,30 +20,28 @@
 {
     public enum Type
     {
-        UNSUPPORTED, NOT, ONLY;
+	UNSUPPORTED, NOT, ONLY;
 
-        private static final Map<String, Type> tags = new HashMap<String, Type>();
+	private static final Map<String, Type> tags = new HashMap<String, Type>();
 
-        static
-        {
-            tags.put("no_left_turn", NOT);
-            tags.put("no_right_turn", NOT);
-            tags.put("no_straight_on", NOT);
-            tags.put("no_u_turn", NOT);
-            tags.put("only_right_turn", ONLY);
-            tags.put("only_left_turn", ONLY);
-            tags.put("only_straight_on", ONLY);
-        }
+	static
+	{
+	    tags.put("no_left_turn", NOT);
+	    tags.put("no_right_turn", NOT);
+	    tags.put("no_straight_on", NOT);
+	    tags.put("no_u_turn", NOT);
+	    tags.put("only_right_turn", ONLY);
+	    tags.put("only_left_turn", ONLY);
+	    tags.put("only_straight_on", ONLY);
+	}
 
-        public static Type getRestrictionType( String tag )
-        {
-            Type result = null;
-            if (tag != null)
-            {
-                result = tags.get(tag);
-            }
-            return (result != null) ? result : UNSUPPORTED;
-        }
+	public static Type getRestrictionType(String tag)
+	{
+	    Type result = null;
+	    if (tag != null)
+		result = tags.get(tag);
+	    return result != null ? result : UNSUPPORTED;
+	}
     }
 
     private final long fromOsmWayId;
@@ -49,101 +49,114 @@
     private final long toOsmWayId;
     private final Type restriction;
 
-    public OSMTurnRelation( long fromWayID, long viaNodeID, long toWayID, Type restrictionType )
+    public OSMTurnRelation(long fromWayID, long viaNodeID, long toWayID, Type restrictionType)
     {
-        this.fromOsmWayId = fromWayID;
-        this.viaOsmNodeId = viaNodeID;
-        this.toOsmWayId = toWayID;
-        this.restriction = restrictionType;
+	this.fromOsmWayId = fromWayID;
+	this.viaOsmNodeId = viaNodeID;
+	this.toOsmWayId = toWayID;
+	this.restriction = restrictionType;
     }
 
-    /* (non-Javadoc)
-	 * @see com.graphhopper.reader.TurnRelation#getOsmIdFrom()
-	 */
+    /*
+     * (non-Javadoc)
+     * 
+     * @see com.graphhopper.reader.TurnRelation#getOsmIdFrom()
+     */
     @Override
-	public long getOsmIdFrom()
+    public long getOsmIdFrom()
     {
-        return fromOsmWayId;
+	return fromOsmWayId;
     }
 
-    /* (non-Javadoc)
-	 * @see com.graphhopper.reader.TurnRelation#getOsmIdTo()
-	 */
+    /*
+     * (non-Javadoc)
+     * 
+     * @see com.graphhopper.reader.TurnRelation#getOsmIdTo()
+     */
     @Override
-	public long getOsmIdTo()
+    public long getOsmIdTo()
     {
-        return toOsmWayId;
+	return toOsmWayId;
     }
 
     /**
      * Transforms this relation into a collection of turn cost entries
      * <p>
-     * @param edgeOutExplorer an edge filter which only allows outgoing edges
-     * @param edgeInExplorer an edge filter which only allows incoming edges
+     * 
+     * @param edgeOutExplorer
+     *            an edge filter which only allows outgoing edges
+     * @param edgeInExplorer
+     *            an edge filter which only allows incoming edges
      * @return a collection of node cost entries which can be added to the graph later
      */
-    public Collection<ITurnCostTableEntry> getRestrictionAsEntries( TurnCostEncoder encoder,
-            EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, DataReader osmReader )
+    @Override
+    public Collection<ITurnCostTableEntry> getRestrictionAsEntries(TurnCostEncoder encoder,
+		    EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, DataReader dataReader)
     {
-        int viaNodeId = osmReader.getInternalNodeIdOfOsmNode(this.viaOsmNodeId);
+	OsItnReader itnReader = (OsItnReader) dataReader;
+	int viaNodeId = itnReader.getInternalNodeIdOfOsmNode(this.viaOsmNodeId);
 
-        try
-        {
-            // street with restriction was not included (access or tag limits etc)
-            if (viaNodeId == OSMReader.EMPTY)
-                return Collections.emptyList();
+	try
+	{
+	    // street with restriction was not included (access or tag limits
+	    // etc)
+	    if (viaNodeId == OSMReader.EMPTY)
+		return Collections.emptyList();
 
-            int edgeIdFrom = EdgeIterator.NO_EDGE;
+	    int edgeIdFrom = EdgeIterator.NO_EDGE;
 
-            // get all incoming edges and receive the edge which is defined by fromOsm
-            EdgeIterator iter = edgeInExplorer.setBaseNode(viaNodeId);
+	    // get all incoming edges and receive the edge which is defined by
+	    // fromOsm
+	    EdgeIterator iter = edgeInExplorer.setBaseNode(viaNodeId);
 
-            while (iter.next())
-            {
-                if (osmReader.getOsmIdOfInternalEdge(iter.getEdge()) == this.fromOsmWayId)
-                {
-                    edgeIdFrom = iter.getEdge();
-                    break;
-                }
-            }
+	    while (iter.next())
+		if (itnReader.getOsmIdOfInternalEdge(iter.getEdge()) == this.fromOsmWayId)
+		{
+		    edgeIdFrom = iter.getEdge();
+		    break;
+		}
 
-            if (edgeIdFrom == EdgeIterator.NO_EDGE)
-                return Collections.emptyList();
+	    if (edgeIdFrom == EdgeIterator.NO_EDGE)
+		return Collections.emptyList();
 
-            final Collection<ITurnCostTableEntry> entries = new ArrayList<ITurnCostTableEntry>();
-            // get all outgoing edges of the via node 
-            iter = edgeOutExplorer.setBaseNode(viaNodeId);
-            // for TYPE_ONLY_* we add ALL restrictions (from, via, * ) EXCEPT the given turn
-            // for TYPE_NOT_*  we add ONE restriction  (from, via, to)
-            while (iter.next())
-            {
-                int edgeId = iter.getEdge();
-                long wayId = osmReader.getOsmIdOfInternalEdge(edgeId);
-                if (edgeId != edgeIdFrom && this.restriction == Type.ONLY && wayId != this.toOsmWayId
-                        || this.restriction == Type.NOT && wayId == this.toOsmWayId && wayId >= 0)
-                {
-                    final TurnCostTableEntry entry = new TurnCostTableEntry();
-                    entry.nodeViaNode = viaNodeId;
-                    entry.edgeFrom = edgeIdFrom;
-                    entry.edgeTo = iter.getEdge();
-                    entry.flags = encoder.getTurnFlags(true, 0);
-                    entries.add(entry);
+	    final Collection<ITurnCostTableEntry> entries = new ArrayList<ITurnCostTableEntry>();
+	    // get all outgoing edges of the via node
+	    iter = edgeOutExplorer.setBaseNode(viaNodeId);
+	    // for TYPE_ONLY_* we add ALL restrictions (from, via, * ) EXCEPT
+	    // the given turn
+	    // for TYPE_NOT_* we add ONE restriction (from, via, to)
+	    while (iter.next())
+	    {
+		int edgeId = iter.getEdge();
+		long wayId = itnReader.getOsmIdOfInternalEdge(edgeId);
+		if (edgeId != edgeIdFrom && this.restriction == Type.ONLY
+				&& wayId != this.toOsmWayId || this.restriction == Type.NOT
+				&& wayId == this.toOsmWayId && wayId >= 0)
+		{
+		    final TurnCostTableEntry entry = new TurnCostTableEntry();
+		    entry.nodeViaNode = viaNodeId;
+		    entry.edgeFrom = edgeIdFrom;
+		    entry.edgeTo = iter.getEdge();
+		    entry.flags = encoder.getTurnFlags(true, 0);
+		    entries.add(entry);
 
-                    if (this.restriction == Type.NOT)
-                        break;
-                }
-            }
-            return entries;
-        } catch (Exception e)
-        {
-            throw new IllegalStateException("Could not built turn table entry for relation of node with osmId:" + this.viaOsmNodeId, e);
-        }
+		    if (this.restriction == Type.NOT)
+			break;
+		}
+	    }
+	    return entries;
+	} catch (Exception e)
+	{
+	    throw new IllegalStateException(
+			    "Could not built turn table entry for relation of node with osmId:"
+					    + this.viaOsmNodeId, e);
+	}
     }
 
     @Override
     public String toString()
     {
-        return "*-(" + fromOsmWayId + ")->" + viaOsmNodeId + "-(" + toOsmWayId + ")->*";
+	return "*-(" + fromOsmWayId + ")->" + viaOsmNodeId + "-(" + toOsmWayId + ")->*";
     }
 
     /**
@@ -151,50 +164,56 @@
      */
     public static class TurnCostTableEntry implements ITurnCostTableEntry
     {
-        public int edgeFrom;
-        public int nodeViaNode;
-        public int edgeTo;
-        public long flags;
+	public int edgeFrom;
+	public int nodeViaNode;
+	public int edgeTo;
+	public long flags;
 
-        /**
-         * @return an unique id (edgeFrom, edgeTo) to avoid duplicate entries if multiple encoders
-         * are involved.
-         */
-        public long getItemId()
-        {
-            return ((long) edgeFrom) << 32 | ((long) edgeTo);
-        }
-        
-        @Override
-		public int getEdgeFrom() {
-			return edgeFrom;
-		}
+	/**
+	 * @return an unique id (edgeFrom, edgeTo) to avoid duplicate entries if multiple encoders
+	 *         are involved.
+	 */
+	@Override
+	public long getItemId()
+	{
+	    return (long) edgeFrom << 32 | edgeTo;
+	}
 
-		@Override
-		public int getEdgeTo() {
-			return edgeTo;
-		}
+	@Override
+	public int getEdgeFrom()
+	{
+	    return edgeFrom;
+	}
 
-		@Override
-		public int getVia() {
-			return nodeViaNode;
-		}
+	@Override
+	public int getEdgeTo()
+	{
+	    return edgeTo;
+	}
 
-		@Override
-		public long getFlags() {
-			return flags;
-		}
+	@Override
+	public int getVia()
+	{
+	    return nodeViaNode;
+	}
 
-		@Override
-		public void setFlags(long flags) {
-			this.flags = flags;
-		}
+	@Override
+	public long getFlags()
+	{
+	    return flags;
+	}
 
-        @Override
-        public String toString()
-        {
-            return "*-(" + edgeFrom + ")->" + nodeViaNode + "-(" + edgeTo + ")->*";
-        }
+	@Override
+	public void setFlags(long flags)
+	{
+	    this.flags = flags;
+	}
+
+	@Override
+	public String toString()
+	{
+	    return "*-(" + edgeFrom + ")->" + nodeViaNode + "-(" + edgeTo + ")->*";
+	}
     }
 
 }
Index: core/src/main/java/com/graphhopper/reader/osgb/OSITNElement.java
===================================================================
--- core/src/main/java/com/graphhopper/reader/osgb/OSITNElement.java	(revision 2400)
+++ core/src/main/java/com/graphhopper/reader/osgb/OSITNElement.java	(working copy)
@@ -220,10 +220,10 @@
     private String resolveNature(String elementText) {
         logger.info("OSITNElement.resolveNature( " + elementText + ")");
         switch (elementText) {
-        case "Single Carriageway":
-        case "Dual Carriageway":
-        case "Slip Road":
-            return elementText;
+            case "Single Carriageway":
+            case "Dual Carriageway":
+            case "Slip Road":
+                return elementText;
         }
         return null;
     }
@@ -456,6 +456,7 @@
         return (String) properties.get(name);
     }
 
+    @Override
     @SuppressWarnings("unchecked")
     public <T> T getTag(String key, T defaultValue) {
         T val = (T) properties.get(key);
@@ -464,6 +465,7 @@
         return val;
     }
 
+    @Override
     public void setTag(String name, Object value) {
         // if(name.equals("highway")) {
         // System.err.println("HIGHWAY:" + value);
@@ -474,6 +476,7 @@
     /**
      * Chaeck that the object has a given tag with a given value.
      */
+    @Override
     public boolean hasTag(String key, Object value) {
         return value.equals(properties.get(key));
     }
@@ -482,6 +485,7 @@
      * Check that a given tag has one of the specified values. If no values are
      * given, just checks for presence of the tag
      */
+    @Override
     public boolean hasTag(String key, String... values) {
         Object osmValue = properties.get(key);
         if (osmValue == null)
@@ -501,6 +505,7 @@
     /**
      * Check that a given tag has one of the specified values.
      */
+    @Override
     public final boolean hasTag(String key, Set<String> values) {
         return values.contains(properties.get(key));
     }
@@ -509,10 +514,10 @@
      * Check a number of tags in the given order for the any of the given
      * values. Used to parse hierarchical access restrictions
      */
+    @Override
     public boolean hasTag(List<String> keyList, Set<String> values) {
         for (String key : keyList) {
-            Object value = properties.get(key);
-            if (values.contains(value))
+            if (values.contains(properties.get(key)))
                 return true;
         }
         return false;
@@ -526,10 +531,12 @@
         properties.clear();
     }
 
+    @Override
     public int getType() {
         return type;
     }
 
+    @Override
     public boolean isType(int type) {
         return this.type == type;
     }
Index: core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
===================================================================
--- core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java	(revision 2400)
+++ core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java	(working copy)
@@ -18,6 +18,15 @@
  */
 package com.graphhopper.reader;
 
+import static org.junit.Assert.assertEquals;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+import org.junit.Test;
+
 import com.graphhopper.reader.OSMTurnRelation.Type;
 import com.graphhopper.routing.EdgeBasedRoutingAlgorithmTest;
 import com.graphhopper.routing.util.CarFlagEncoder;
@@ -25,15 +34,9 @@
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphStorage;
 import com.graphhopper.util.EdgeExplorer;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-import org.junit.Test;
-import static org.junit.Assert.*;
 
 /**
- *
+ * 
  * @author Peter Karich
  */
 public class OSMTurnRelationTest
@@ -44,29 +47,27 @@
         CarFlagEncoder encoder = new CarFlagEncoder(5, 5, 3);
         final Map<Long, Integer> osmNodeToInternal = new HashMap<Long, Integer>();
         final Map<Integer, Long> internalToOSMEdge = new HashMap<Integer, Long>();
-                
+
         osmNodeToInternal.put(3L, 3);
         // edge ids are only stored if they occured before in an OSMRelation
-        internalToOSMEdge.put(3, 3L);        
-        internalToOSMEdge.put(4, 4L);        
+        internalToOSMEdge.put(3, 3L);
+        internalToOSMEdge.put(4, 4L);
 
-        GraphStorage graph = new GraphBuilder(new EncodingManager(encoder)).create();
+        GraphStorage graph = new GraphBuilder(new EncodingManager(encoder))
+                .create();
         EdgeBasedRoutingAlgorithmTest.initGraph(graph);
-        OSMReader osmReader = new OSMReader(graph)
-        {
+        OSMReader osmReader = new OSMReader(graph) {
 
             @Override
-            public int getInternalNodeIdOfOsmNode( long nodeOsmId )
-            {
+            public int getInternalNodeIdOfOsmNode(Long nodeOsmId) {
                 return osmNodeToInternal.get(nodeOsmId);
             }
 
             @Override
-            public long getOsmIdOfInternalEdge( int edgeId )
-            {
+            public Long getOsmIdOfInternalEdge(int edgeId) {
                 Long l = internalToOSMEdge.get(edgeId);
-                if(l == null)
-                    return -1;
+                if (l == null)
+                    return -1L;
                 return l;
             }
         };
@@ -75,8 +76,9 @@
 
         // TYPE == ONLY
         OSMTurnRelation instance = new OSMTurnRelation(4, 3, 3, Type.ONLY);
-        Collection<ITurnCostTableEntry> result
-                = instance.getRestrictionAsEntries(encoder, edgeExplorer, edgeExplorer, osmReader);
+        Collection<ITurnCostTableEntry> result = instance
+                .getRestrictionAsEntries(encoder, edgeExplorer, edgeExplorer,
+                        osmReader);
 
         assertEquals(2, result.size());
         Iterator<ITurnCostTableEntry> iter = result.iterator();
@@ -84,23 +86,23 @@
         assertEquals(4, entry.getEdgeFrom());
         assertEquals(6, entry.getEdgeTo());
         assertEquals(3, entry.getVia());
-        
+
         entry = iter.next();
         assertEquals(4, entry.getEdgeFrom());
         assertEquals(2, entry.getEdgeTo());
         assertEquals(3, entry.getVia());
-        
-        
+
         // TYPE == NOT
         instance = new OSMTurnRelation(4, 3, 3, Type.NOT);
-        result = instance.getRestrictionAsEntries(encoder, edgeExplorer, edgeExplorer, osmReader);
+        result = instance.getRestrictionAsEntries(encoder, edgeExplorer,
+                edgeExplorer, osmReader);
 
         assertEquals(1, result.size());
         iter = result.iterator();
         entry = iter.next();
         assertEquals(4, entry.getEdgeFrom());
         assertEquals(3, entry.getEdgeTo());
-        assertEquals(3, entry.getVia());       
+        assertEquals(3, entry.getVia());
     }
 
 }
Index: core/src/main/java/com/graphhopper/reader/DataReader.java
===================================================================
--- core/src/main/java/com/graphhopper/reader/DataReader.java	(revision 2400)
+++ core/src/main/java/com/graphhopper/reader/DataReader.java	(working copy)
@@ -29,25 +29,24 @@
  * @author Peter Karich
  * @author Stuart Adam
  */
-public interface DataReader
-{
+public interface DataReader<E> {
 
     void readGraph() throws IOException;
 
     GraphStorage getGraphStorage();
 
-	int getInternalNodeIdOfOsmNode(long viaOsm);
+    int getInternalNodeIdOfOsmNode(E viaOsm);
 
-	long getOsmIdOfInternalEdge(int edge);
+    E getOsmIdOfInternalEdge(int edge);
 
-	DataReader setOSMFile(File srcFile);
+    DataReader setOSMFile(File srcFile);
 
-	DataReader setElevationProvider(ElevationProvider eleProvider);
+    DataReader setElevationProvider(ElevationProvider eleProvider);
 
-	DataReader setWorkerThreads(int workerThreads);
+    DataReader setWorkerThreads(int workerThreads);
 
-	DataReader setEncodingManager(EncodingManager encodingManager);
+    DataReader setEncodingManager(EncodingManager encodingManager);
 
-	DataReader setWayPointMaxDistance(double wayPointMaxDistance);
+    DataReader setWayPointMaxDistance(double wayPointMaxDistance);
 
 }
Index: core/src/main/java/com/graphhopper/GraphHopper.java
===================================================================
--- core/src/main/java/com/graphhopper/GraphHopper.java	(revision 2400)
+++ core/src/main/java/com/graphhopper/GraphHopper.java	(working copy)
@@ -36,6 +36,7 @@
 import com.graphhopper.reader.dem.ElevationProvider;
 import com.graphhopper.reader.dem.SRTMProvider;
 import com.graphhopper.reader.osgb.OsItnReader;
+import com.graphhopper.reader.osgb.dpn.OsDpnReader;
 import com.graphhopper.routing.Path;
 import com.graphhopper.routing.RoutingAlgorithm;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
@@ -89,7 +90,7 @@
 public class GraphHopper implements GraphHopperAPI
 {
     private static final String READER_UNAVAILABLE = "DataReader implementation %s not available check your setting for reader.implementation.  Allowed options are OSM or OSITN";
-	private final Logger logger = LoggerFactory.getLogger(getClass());
+    private final Logger logger = LoggerFactory.getLogger(getClass());
     // for graph:
     private GraphStorage graph;
     private EncodingManager encodingManager;
@@ -128,11 +129,11 @@
     private double osmReaderWayPointMaxDistance = 1;
     private int workerThreads = -1;
     private boolean calcPoints = true;
-    // utils    
+    // utils
     private final TranslationMap trMap = new TranslationMap().doImport();
     private ElevationProvider eleProvider = ElevationProvider.NOOP;
     private final AtomicLong visitedSum = new AtomicLong(0);
-	private String dataReader = "OSM";
+    private String dataReader = "OSM";
 
     public GraphHopper()
     {
@@ -141,38 +142,38 @@
     /**
      * For testing only
      */
-    protected GraphHopper loadGraph( GraphStorage g )
+    protected GraphHopper loadGraph(GraphStorage g)
     {
-        this.graph = g;
-        fullyLoaded = true;
-        initLocationIndex();
-        return this;
+	this.graph = g;
+	fullyLoaded = true;
+	initLocationIndex();
+	return this;
     }
 
     /**
      * Specify which vehicles can be read by this GraphHopper instance. An encoding manager defines
      * how data from every vehicle is written (und read) into edges of the graph.
      */
-    public GraphHopper setEncodingManager( EncodingManager em )
+    public GraphHopper setEncodingManager(EncodingManager em)
     {
-        ensureNotLoaded();
-        this.encodingManager = em;
-        return this;
+	ensureNotLoaded();
+	this.encodingManager = em;
+	return this;
     }
 
     public EncodingManager getEncodingManager()
     {
-        return encodingManager;
+	return encodingManager;
     }
 
-    public GraphHopper setElevationProvider( ElevationProvider eleProvider )
+    public GraphHopper setElevationProvider(ElevationProvider eleProvider)
     {
-        if (eleProvider == null || eleProvider == ElevationProvider.NOOP)
-            setElevation(false);
-        else
-            setElevation(true);
-        this.eleProvider = eleProvider;
-        return this;
+	if (eleProvider == null || eleProvider == ElevationProvider.NOOP)
+	    setElevation(false);
+	else
+	    setElevation(true);
+	this.eleProvider = eleProvider;
+	return this;
     }
 
     /**
@@ -180,7 +181,7 @@
      */
     protected int getWorkerThreads()
     {
-        return workerThreads;
+	return workerThreads;
     }
 
     /**
@@ -188,31 +189,31 @@
      */
     protected double getWayPointMaxDistance()
     {
-        return osmReaderWayPointMaxDistance;
+	return osmReaderWayPointMaxDistance;
     }
 
     /**
      * This parameter specifies how to reduce points via douglas peucker while OSM import. Higher
      * value means more details, unit is meter. Default is 1. Disable via 0.
      */
-    public GraphHopper setWayPointMaxDistance( double wayPointMaxDistance )
+    public GraphHopper setWayPointMaxDistance(double wayPointMaxDistance)
     {
-        this.osmReaderWayPointMaxDistance = wayPointMaxDistance;
-        return this;
+	this.osmReaderWayPointMaxDistance = wayPointMaxDistance;
+	return this;
     }
 
     /**
      * Sets the default traversal mode used for the algorithms and preparation.
      */
-    public GraphHopper setTraversalMode( TraversalMode traversalMode )
+    public GraphHopper setTraversalMode(TraversalMode traversalMode)
     {
-        this.traversalMode = traversalMode;
-        return this;
+	this.traversalMode = traversalMode;
+	return this;
     }
 
     public TraversalMode getTraversalMode()
     {
-        return traversalMode;
+	return traversalMode;
     }
 
     /**
@@ -220,9 +221,9 @@
      */
     public GraphHopper forServer()
     {
-        // simplify to reduce network IO
-        setSimplifyResponse(true);
-        return setInMemory();
+	// simplify to reduce network IO
+	setSimplifyResponse(true);
+	return setInMemory();
     }
 
     /**
@@ -231,8 +232,8 @@
      */
     public GraphHopper forDesktop()
     {
-        setSimplifyResponse(false);
-        return setInMemory();
+	setSimplifyResponse(false);
+	return setInMemory();
     }
 
     /**
@@ -241,8 +242,8 @@
      */
     public GraphHopper forMobile()
     {
-        setSimplifyResponse(false);
-        return setMemoryMapped();
+	setSimplifyResponse(false);
+	return setMemoryMapped();
     }
 
     /**
@@ -250,11 +251,11 @@
      * probably slower query times, which would be e.g. not suitable for Android. The resolution
      * specifies the tile width (in meter).
      */
-    public GraphHopper setPreciseIndexResolution( int precision )
+    public GraphHopper setPreciseIndexResolution(int precision)
     {
-        ensureNotLoaded();
-        preciseIndexResolution = precision;
-        return this;
+	ensureNotLoaded();
+	preciseIndexResolution = precision;
+	return this;
     }
 
     /**
@@ -262,9 +263,9 @@
      */
     public GraphHopper setInMemory()
     {
-        ensureNotLoaded();
-        dataAccessType = DAType.RAM_STORE;
-        return this;
+	ensureNotLoaded();
+	dataAccessType = DAType.RAM_STORE;
+	return this;
     }
 
     /**
@@ -272,16 +273,17 @@
      * tests. Specify storeOnFlush to true if you want that existing data will be loaded FROM disc
      * and all in-memory data will be flushed TO disc after flush is called e.g. while OSM import.
      * <p>
-     * @param storeOnFlush true by default
+     * @param storeOnFlush
+     *            true by default
      */
-    public GraphHopper setStoreOnFlush( boolean storeOnFlush )
+    public GraphHopper setStoreOnFlush(boolean storeOnFlush)
     {
-        ensureNotLoaded();
-        if (storeOnFlush)
-            dataAccessType = DAType.RAM_STORE;
-        else
-            dataAccessType = DAType.RAM;
-        return this;
+	ensureNotLoaded();
+	if (storeOnFlush)
+	    dataAccessType = DAType.RAM_STORE;
+	else
+	    dataAccessType = DAType.RAM;
+	return this;
     }
 
     /**
@@ -289,9 +291,9 @@
      */
     public GraphHopper setMemoryMapped()
     {
-        ensureNotLoaded();
-        dataAccessType = DAType.MMAP;
-        return this;
+	ensureNotLoaded();
+	dataAccessType = DAType.MMAP;
+	return this;
     }
 
     /**
@@ -299,51 +301,52 @@
      */
     private GraphHopper setUnsafeMemory()
     {
-        ensureNotLoaded();
-        dataAccessType = DAType.UNSAFE_STORE;
-        return this;
+	ensureNotLoaded();
+	dataAccessType = DAType.UNSAFE_STORE;
+	return this;
     }
 
     /**
      * Disables "CH-preparation". Use only if you know what you do.
      */
-    public GraphHopper setDoPrepare( boolean doPrepare )
+    public GraphHopper setDoPrepare(boolean doPrepare)
     {
-        this.doPrepare = doPrepare;
-        return this;
+	this.doPrepare = doPrepare;
+	return this;
     }
 
     /**
      * Enables the use of contraction hierarchies to reduce query times. Enabled by default.
      * <p/>
-     * @param weighting can be "fastest", "shortest" or your own weight-calculation type.
+     * @param weighting
+     *            can be "fastest", "shortest" or your own weight-calculation type.
      * @see #setCHEnable(boolean)
      */
-    public GraphHopper setCHWeighting( String weighting )
+    public GraphHopper setCHWeighting(String weighting)
     {
-        ensureNotLoaded();
-        chWeighting = weighting;
-        return this;
+	ensureNotLoaded();
+	chWeighting = weighting;
+	return this;
     }
 
     public String getCHWeighting()
     {
-        return chWeighting;
+	return chWeighting;
     }
 
     /**
      * Enables or disables contraction hierarchies. Enabled by default.
      */
-    public GraphHopper setCHEnable( boolean enable )
+    public GraphHopper setCHEnable(boolean enable)
     {
-        ensureNotLoaded();
-        chEnabled = enable;
-        return this;
+	ensureNotLoaded();
+	chEnabled = enable;
+	return this;
     }
 
     public boolean isCHEnabled()
     {
-        return chEnabled;
+	return chEnabled;
     }
 
     /**
@@ -351,154 +354,156 @@
      */
     public boolean hasElevation()
     {
-        return elevation;
+	return elevation;
     }
 
     /**
      * Enable storing and fetching elevation data. Default is false
      */
-    public GraphHopper setElevation( boolean includeElevation )
+    public GraphHopper setElevation(boolean includeElevation)
     {
-        this.elevation = includeElevation;
-        return this;
+	this.elevation = includeElevation;
+	return this;
     }
 
     /**
      * This method specifies if the import should include way names to be able to return
      * instructions for a route.
      */
-    public GraphHopper setEnableInstructions( boolean b )
+    public GraphHopper setEnableInstructions(boolean b)
     {
-        ensureNotLoaded();
-        enableInstructions = b;
-        return this;
+	ensureNotLoaded();
+	enableInstructions = b;
+	return this;
     }
 
     /**
      * This methods enables gps point calculation. If disabled only distance will be calculated.
      */
-    public GraphHopper setEnableCalcPoints( boolean b )
+    public GraphHopper setEnableCalcPoints(boolean b)
     {
-        calcPoints = b;
-        return this;
+	calcPoints = b;
+	return this;
     }
 
     /**
      * This method specifies if the returned path should be simplified or not, via douglas-peucker
      * or similar algorithm.
      */
-    private GraphHopper setSimplifyResponse( boolean doSimplify )
+    private GraphHopper setSimplifyResponse(boolean doSimplify)
     {
-        this.simplifyResponse = doSimplify;
-        return this;
+	this.simplifyResponse = doSimplify;
+	return this;
     }
 
     /**
      * Sets the graphhopper folder.
      */
-    public GraphHopper setGraphHopperLocation( String ghLocation )
+    public GraphHopper setGraphHopperLocation(String ghLocation)
     {
-        ensureNotLoaded();
-        if (ghLocation == null)
-            throw new IllegalArgumentException("graphhopper location cannot be null");
+	ensureNotLoaded();
+	if (ghLocation == null)
+	    throw new IllegalArgumentException("graphhopper location cannot be null");
 
-        this.ghLocation = ghLocation;
-        return this;
+	this.ghLocation = ghLocation;
+	return this;
     }
 
     public String getGraphHopperLocation()
     {
-        return ghLocation;
+	return ghLocation;
     }
 
     /**
      * This file can be an osm xml (.osm), a compressed xml (.osm.zip or .osm.gz) or a protobuf file
      * (.pbf).
      */
-    public GraphHopper setOSMFile( String osmFileStr )
+    public GraphHopper setOSMFile(String osmFileStr)
     {
-        ensureNotLoaded();
-        if (Helper.isEmpty(osmFileStr))
-            throw new IllegalArgumentException("OSM file cannot be empty.");
+	ensureNotLoaded();
+	if (Helper.isEmpty(osmFileStr))
+	    throw new IllegalArgumentException("OSM file cannot be empty.");
 
-        osmFile = osmFileStr;
-        return this;
+	osmFile = osmFileStr;
+	return this;
     }
 
     public String getOSMFile()
     {
-        return osmFile;
+	return osmFile;
     }
 
     /**
      * The underlying graph used in algorithms.
      * <p>
-     * @throws IllegalStateException if graph is not instantiated.
+     * @throws IllegalStateException
+     *             if graph is not instantiated.
      */
     public GraphStorage getGraph()
     {
-        if (graph == null)
-            throw new IllegalStateException("Graph not initialized");
+	if (graph == null)
+	    throw new IllegalStateException("Graph not initialized");
 
-        return graph;
+	return graph;
     }
 
-    public void setGraph( GraphStorage graph )
+    public void setGraph(GraphStorage graph)
     {
-        this.graph = graph;
+	this.graph = graph;
     }
 
-    protected void setLocationIndex( LocationIndex locationIndex )
+    protected void setLocationIndex(LocationIndex locationIndex)
     {
-        this.locationIndex = locationIndex;
+	this.locationIndex = locationIndex;
     }
 
     /**
      * The location index created from the graph.
      * <p>
-     * @throws IllegalStateException if index is not initialized
+     * @throws IllegalStateException
+     *             if index is not initialized
      */
     public LocationIndex getLocationIndex()
     {
-        if (locationIndex == null)
-            throw new IllegalStateException("Location index not initialized");
+	if (locationIndex == null)
+	    throw new IllegalStateException("Location index not initialized");
 
-        return locationIndex;
+	return locationIndex;
     }
 
     public AlgorithmPreparation getPreparation()
     {
-        return prepare;
+	return prepare;
     }
 
     /**
      * Sorts the graph which requires more RAM while import. See #12
      */
-    public GraphHopper setSortGraph( boolean sortGraph )
+    public GraphHopper setSortGraph(boolean sortGraph)
     {
-        ensureNotLoaded();
-        this.sortGraph = sortGraph;
-        return this;
+	ensureNotLoaded();
+	this.sortGraph = sortGraph;
+	return this;
     }
 
     /**
      * Specifies if it is allowed for GraphHopper to write. E.g. for read only filesystems it is not
      * possible to create a lock file and so we can avoid write locks.
      */
-    public GraphHopper setAllowWrites( boolean allowWrites )
+    public GraphHopper setAllowWrites(boolean allowWrites)
     {
-        this.allowWrites = allowWrites;
-        return this;
+	this.allowWrites = allowWrites;
+	return this;
     }
 
     public boolean isAllowWrites()
     {
-        return allowWrites;
+	return allowWrites;
     }
 
     public TranslationMap getTranslationMap()
     {
-        return trMap;
+	return trMap;
     }
 
     /**
@@ -506,99 +511,101 @@
      * args) ala CmdArgs.read(args) or via configuration file ala
      * CmdArgs.readFromConfig("config.properties", "graphhopper.config")
      */
-    public GraphHopper init( CmdArgs args )
+    public GraphHopper init(CmdArgs args)
     {
-        args = CmdArgs.readFromConfigAndMerge(args, "config", "graphhopper.config");
-        String tmpOsmFile = args.get("osmreader.osm", "");
-        if (!Helper.isEmpty(tmpOsmFile))
-            osmFile = tmpOsmFile;
-        
-        dataReader = args.get("reader.implementation", dataReader);
+	args = CmdArgs.readFromConfigAndMerge(args, "config", "graphhopper.config");
+	String tmpOsmFile = args.get("osmreader.osm", "");
+	if (!Helper.isEmpty(tmpOsmFile))
+	    osmFile = tmpOsmFile;
+
+	dataReader = args.get("reader.implementation", dataReader);
 
-        String graphHopperFolder = args.get("graph.location", "");
-        if (Helper.isEmpty(graphHopperFolder) && Helper.isEmpty(ghLocation))
-        {
-            if (Helper.isEmpty(osmFile))
-                throw new IllegalArgumentException("You need to specify an OSM file.");
+	String graphHopperFolder = args.get("graph.location", "");
+	if (Helper.isEmpty(graphHopperFolder) && Helper.isEmpty(ghLocation))
+	{
+	    if (Helper.isEmpty(osmFile))
+		throw new IllegalArgumentException("You need to specify an OSM file.");
 
-            graphHopperFolder = Helper.pruneFileEnd(osmFile) + "-gh";
-        }
+	    graphHopperFolder = Helper.pruneFileEnd(osmFile) + "-gh";
+	}
 
-        // graph
-        setGraphHopperLocation(graphHopperFolder);
-        defaultSegmentSize = args.getInt("graph.dataaccess.segmentSize", defaultSegmentSize);
+	// graph
+	setGraphHopperLocation(graphHopperFolder);
+	defaultSegmentSize = args.getInt("graph.dataaccess.segmentSize", defaultSegmentSize);
 
-        String graphDATypeStr = args.get("graph.dataaccess", "RAM_STORE");
-        dataAccessType = DAType.fromString(graphDATypeStr);
+	String graphDATypeStr = args.get("graph.dataaccess", "RAM_STORE");
+	dataAccessType = DAType.fromString(graphDATypeStr);
 
-        sortGraph = args.getBool("graph.doSort", sortGraph);
-        removeZipped = args.getBool("graph.removeZipped", removeZipped);
-        int bytesForFlags = args.getInt("graph.bytesForFlags", 4);
-        if (args.get("graph.locktype", "native").equals("simple"))
-            lockFactory = new SimpleFSLockFactory();
-        else
-            lockFactory = new NativeFSLockFactory();
+	sortGraph = args.getBool("graph.doSort", sortGraph);
+	removeZipped = args.getBool("graph.removeZipped", removeZipped);
+	int bytesForFlags = args.getInt("graph.bytesForFlags", 4);
+	if (args.get("graph.locktype", "native").equals("simple"))
+	    lockFactory = new SimpleFSLockFactory();
+	else
+	    lockFactory = new NativeFSLockFactory();
 
-        // elevation
-        String eleProviderStr = args.get("graph.elevation.provider", "noop").toLowerCase();
-        boolean eleCalcMean = args.getBool("graph.elevation.calcmean", false);
-        String cacheDirStr = args.get("graph.elevation.cachedir", "");
-        String baseURL = args.get("graph.elevation.baseurl", "");
-        DAType elevationDAType = DAType.fromString(args.get("graph.elevation.dataaccess", "MMAP"));
-        ElevationProvider tmpProvider = ElevationProvider.NOOP;
-        if (eleProviderStr.equalsIgnoreCase("srtm"))
-        {
-            tmpProvider = new SRTMProvider();
-        } else if (eleProviderStr.equalsIgnoreCase("cgiar"))
-        {
-            CGIARProvider cgiarProvider = new CGIARProvider();
-            cgiarProvider.setAutoRemoveTemporaryFiles(args.getBool("graph.elevation.cgiar.clear", true));
-            tmpProvider = cgiarProvider;
-        }
+	// elevation
+	String eleProviderStr = args.get("graph.elevation.provider", "noop").toLowerCase();
+	boolean eleCalcMean = args.getBool("graph.elevation.calcmean", false);
+	String cacheDirStr = args.get("graph.elevation.cachedir", "");
+	String baseURL = args.get("graph.elevation.baseurl", "");
+	DAType elevationDAType = DAType.fromString(args.get("graph.elevation.dataaccess", "MMAP"));
+	ElevationProvider tmpProvider = ElevationProvider.NOOP;
+	if (eleProviderStr.equalsIgnoreCase("srtm"))
+	    tmpProvider = new SRTMProvider();
+	else if (eleProviderStr.equalsIgnoreCase("cgiar"))
+	{
+	    CGIARProvider cgiarProvider = new CGIARProvider();
+	    cgiarProvider.setAutoRemoveTemporaryFiles(args.getBool("graph.elevation.cgiar.clear",
+			    true));
+	    tmpProvider = cgiarProvider;
+	}
 
-        tmpProvider.setCalcMean(eleCalcMean);
-        tmpProvider.setCacheDir(new File(cacheDirStr));
-        if (!baseURL.isEmpty())
-            tmpProvider.setBaseURL(baseURL);
-        tmpProvider.setDAType(elevationDAType);
-        setElevationProvider(tmpProvider);
+	tmpProvider.setCalcMean(eleCalcMean);
+	tmpProvider.setCacheDir(new File(cacheDirStr));
+	if (!baseURL.isEmpty())
+	    tmpProvider.setBaseURL(baseURL);
+	tmpProvider.setDAType(elevationDAType);
+	setElevationProvider(tmpProvider);
 
-        // optimizable prepare
-        minNetworkSize = args.getInt("prepare.minNetworkSize", minNetworkSize);
-        minOnewayNetworkSize = args.getInt("prepare.minOnewayNetworkSize", minOnewayNetworkSize);
+	// optimizable prepare
+	minNetworkSize = args.getInt("prepare.minNetworkSize", minNetworkSize);
+	minOnewayNetworkSize = args.getInt("prepare.minOnewayNetworkSize", minOnewayNetworkSize);
 
-        // prepare CH
-        doPrepare = args.getBool("prepare.doPrepare", doPrepare);
-        String tmpCHWeighting = args.get("prepare.chWeighting", "fastest");
-        chEnabled = "fastest".equals(tmpCHWeighting) || "shortest".equals(tmpCHWeighting);
-        if (chEnabled)
-            setCHWeighting(tmpCHWeighting);
+	// prepare CH
+	doPrepare = args.getBool("prepare.doPrepare", doPrepare);
+	String tmpCHWeighting = args.get("prepare.chWeighting", "fastest");
+	chEnabled = "fastest".equals(tmpCHWeighting) || "shortest".equals(tmpCHWeighting);
+	if (chEnabled)
+	    setCHWeighting(tmpCHWeighting);
 
-        periodicUpdates = args.getInt("prepare.updates.periodic", periodicUpdates);
-        lazyUpdates = args.getInt("prepare.updates.lazy", lazyUpdates);
-        neighborUpdates = args.getInt("prepare.updates.neighbor", neighborUpdates);
-        logMessages = args.getDouble("prepare.logmessages", logMessages);
+	periodicUpdates = args.getInt("prepare.updates.periodic", periodicUpdates);
+	lazyUpdates = args.getInt("prepare.updates.lazy", lazyUpdates);
+	neighborUpdates = args.getInt("prepare.updates.neighbor", neighborUpdates);
+	logMessages = args.getDouble("prepare.logmessages", logMessages);
 
-        // osm import
-        osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance", osmReaderWayPointMaxDistance);
-        String flagEncoders = args.get("graph.flagEncoders", "CAR");
-        if (flagEncoders.toLowerCase().contains("turncosts=true"))
-            traversalMode = TraversalMode.EDGE_BASED_2DIR;
-        encodingManager = new EncodingManager(flagEncoders, bytesForFlags);
-        workerThreads = args.getInt("osmreader.workerThreads", workerThreads);
-        enableInstructions = args.getBool("osmreader.instructions", enableInstructions);
+	// osm import
+	osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance",
+			osmReaderWayPointMaxDistance);
+	String flagEncoders = args.get("graph.flagEncoders", "CAR");
+	if (flagEncoders.toLowerCase().contains("turncosts=true"))
+	    traversalMode = TraversalMode.EDGE_BASED_2DIR;
+	encodingManager = new EncodingManager(flagEncoders, bytesForFlags);
+	workerThreads = args.getInt("osmreader.workerThreads", workerThreads);
+	enableInstructions = args.getBool("osmreader.instructions", enableInstructions);
 
-        // index
-        preciseIndexResolution = args.getInt("index.highResolution", preciseIndexResolution);
-        maxRegionSearch = args.getInt("index.maxRegionSearch", maxRegionSearch);
-        return this;
+	// index
+	preciseIndexResolution = args.getInt("index.highResolution", preciseIndexResolution);
+	maxRegionSearch = args.getInt("index.maxRegionSearch", maxRegionSearch);
+	return this;
     }
 
     private void printInfo()
     {
-        logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " (" + Constants.getVersions() + ")");
-        if (graph != null)
-            logger.info("graph " + graph.toString() + ", details:" + graph.toDetailsString());
+	logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " ("
+			+ Constants.getVersions() + ")");
+	if (graph != null)
+	    logger.info("graph " + graph.toString() + ", details:" + graph.toDetailsString());
     }
 
     /**
@@ -608,186 +615,187 @@
      */
     public GraphHopper importOrLoad()
     {
-        if (!load(ghLocation))
-        {
-            printInfo();
-            process(ghLocation);
-        } else
-        {
-            printInfo();
-        }
-        return this;
+	if (!load(ghLocation))
+	{
+	    printInfo();
+	    process(ghLocation);
+	} else
+	    printInfo();
+	return this;
     }
 
     /**
      * Creates the graph from OSM data.
      */
-    private GraphHopper process( String graphHopperLocation )
+    private GraphHopper process(String graphHopperLocation)
     {
-        setGraphHopperLocation(graphHopperLocation);
-        Lock lock = null;
-        try
-        {
-            if (graph.getDirectory().getDefaultType().isStoring())
-            {
-                lockFactory.setLockDir(new File(graphHopperLocation));
-                lock = lockFactory.create(fileLockName, true);
-                if (!lock.tryLock())
-                    throw new RuntimeException("To avoid multiple writers we need to obtain a write lock but it failed. In " + graphHopperLocation, lock.getObtainFailedReason());
-            }
+	setGraphHopperLocation(graphHopperLocation);
+	Lock lock = null;
+	try
+	{
+	    if (graph.getDirectory().getDefaultType().isStoring())
+	    {
+		lockFactory.setLockDir(new File(graphHopperLocation));
+		lock = lockFactory.create(fileLockName, true);
+		if (!lock.tryLock())
+		    throw new RuntimeException(
+				    "To avoid multiple writers we need to obtain a write lock but it failed. In "
+						    + graphHopperLocation,
+				    lock.getObtainFailedReason());
+	    }
 
-            try
-            {
-                importData();
-                graph.getProperties().put("osmreader.import.date", formatDateTime(new Date()));
-            } catch (IOException ex)
-            {
-                throw new RuntimeException("Cannot parse OSM file " + getOSMFile(), ex);
-            }
-            cleanUp();
-            optimize();
-            postProcessing();
-            flush();
-        } finally
-        {
-            if (lock != null)
-                lock.release();
-        }
-        return this;
+	    try
+	    {
+		importData();
+		graph.getProperties().put("osmreader.import.date", formatDateTime(new Date()));
+	    } catch (IOException ex)
+	    {
+		throw new RuntimeException("Cannot parse OSM file " + getOSMFile(), ex);
+	    }
+	    cleanUp();
+	    optimize();
+	    postProcessing();
+	    flush();
+	} finally
+	{
+	    if (lock != null)
+		lock.release();
+	}
+	return this;
     }
 
     protected DataReader importData() throws IOException
     {
-        ensureWriteAccess();
-        if (graph == null)
-            throw new IllegalStateException("Load graph before importing OSM data");
+	ensureWriteAccess();
+	if (graph == null)
+	    throw new IllegalStateException("Load graph before importing OSM data");
 
-        if (osmFile == null)
-            throw new IllegalStateException("Couldn't load from existing folder: " + ghLocation
-                    + " but also cannot import from OSM file as it wasn't specified!");
+	if (osmFile == null)
+	    throw new IllegalStateException("Couldn't load from existing folder: " + ghLocation
+			    + " but also cannot import from OSM file as it wasn't specified!");
 
-        encodingManager.setEnableInstructions(enableInstructions);
-        DataReader reader = createReader(graph);
-        logger.info("using " + graph.toString() + ", memory:" + Helper.getMemInfo());
-        reader.readGraph();
-        return reader;
+	encodingManager.setEnableInstructions(enableInstructions);
+	DataReader reader = createReader(graph);
+	logger.info("using " + graph.toString() + ", memory:" + Helper.getMemInfo());
+	reader.readGraph();
+	return reader;
     }
 
-    protected DataReader createReader( GraphStorage tmpGraph )
+    protected DataReader createReader(GraphStorage tmpGraph)
     {
-    	DataReader reader;
-    	if ("OSM".equals(dataReader)) {
-    		reader = new OSMReader(tmpGraph);
-    	}
-    	else if ("OSITN".equals(dataReader)) {
-    		reader = new OsItnReader(tmpGraph);
-    	} else {
-    		String exceptionMessage = String.format(READER_UNAVAILABLE, dataReader);
-    		throw new IllegalArgumentException(exceptionMessage);
-    	}
-        return initReader(reader);
+	DataReader reader;
+	if ("OSM".equals(dataReader))
+	    reader = new OSMReader(tmpGraph);
+	else if ("OSITN".equals(dataReader))
+	    reader = new OsItnReader(tmpGraph);
+	else if ("OSDPN".equals(dataReader))
+	    reader = new OsDpnReader(tmpGraph);
+	else
+	{
+	    String exceptionMessage = String.format(READER_UNAVAILABLE, dataReader);
+	    throw new IllegalArgumentException(exceptionMessage);
+	}
+	return initReader(reader);
     }
 
-    protected DataReader initReader(DataReader reader )
+    protected DataReader initReader(DataReader reader)
     {
-        if (osmFile == null)
-            throw new IllegalArgumentException("No OSM file specified");
+	if (osmFile == null)
+	    throw new IllegalArgumentException("No OSM file specified");
 
-        logger.info("start creating graph from " + osmFile);
-        File osmTmpFile = new File(osmFile);
-        return reader.setOSMFile(osmTmpFile).
-                setElevationProvider(eleProvider).
-                setWorkerThreads(workerThreads).
-                setEncodingManager(encodingManager).
-                setWayPointMaxDistance(osmReaderWayPointMaxDistance);
+	logger.info("start creating graph from " + osmFile);
+	File osmTmpFile = new File(osmFile);
+	return reader.setOSMFile(osmTmpFile).setElevationProvider(eleProvider)
+			.setWorkerThreads(workerThreads).setEncodingManager(encodingManager)
+			.setWayPointMaxDistance(osmReaderWayPointMaxDistance);
     }
 
     /**
      * Opens existing graph.
      * <p/>
-     * @param graphHopperFolder is the folder containing graphhopper files (which can be compressed
-     * too)
+     * @param graphHopperFolder
+     *            is the folder containing graphhopper files (which can be compressed too)
      */
     @Override
-    public boolean load( String graphHopperFolder )
+    public boolean load(String graphHopperFolder)
     {
-        if (Helper.isEmpty(graphHopperFolder))
-            throw new IllegalStateException("graphHopperLocation is not specified. call init before");
+	if (Helper.isEmpty(graphHopperFolder))
+	    throw new IllegalStateException(
+			    "graphHopperLocation is not specified. call init before");
 
-        if (fullyLoaded)
-            throw new IllegalStateException("graph is already successfully loaded");
+	if (fullyLoaded)
+	    throw new IllegalStateException("graph is already successfully loaded");
 
-        if (graphHopperFolder.endsWith("-gh"))
-        {
-            // do nothing  
-        } else if (graphHopperFolder.endsWith(".osm") || graphHopperFolder.endsWith(".xml"))
-        {
-            throw new IllegalArgumentException("To import an osm file you need to use importOrLoad");
-        } else if (!graphHopperFolder.contains("."))
-        {
-            if (new File(graphHopperFolder + "-gh").exists())
-                graphHopperFolder += "-gh";
-        } else
-        {
-            File compressed = new File(graphHopperFolder + ".ghz");
-            if (compressed.exists() && !compressed.isDirectory())
-            {
-                try
-                {
-                    new Unzipper().unzip(compressed.getAbsolutePath(), graphHopperFolder, removeZipped);
-                } catch (IOException ex)
-                {
-                    throw new RuntimeException("Couldn't extract file " + compressed.getAbsolutePath()
-                            + " to " + graphHopperFolder, ex);
-                }
-            }
-        }
+	if (graphHopperFolder.endsWith("-gh"))
+	{
+	    // do nothing
+	} else if (graphHopperFolder.endsWith(".osm") || graphHopperFolder.endsWith(".xml"))
+	    throw new IllegalArgumentException("To import an osm file you need to use importOrLoad");
+	else if (!graphHopperFolder.contains("."))
+	{
+	    if (new File(graphHopperFolder + "-gh").exists())
+		graphHopperFolder += "-gh";
+	} else
+	{
+	    File compressed = new File(graphHopperFolder + ".ghz");
+	    if (compressed.exists() && !compressed.isDirectory())
+		try
+		{
+		    new Unzipper().unzip(compressed.getAbsolutePath(), graphHopperFolder,
+				    removeZipped);
+		} catch (IOException ex)
+		{
+		    throw new RuntimeException("Couldn't extract file "
+				    + compressed.getAbsolutePath() + " to " + graphHopperFolder, ex);
+		}
+	}
 
-        setGraphHopperLocation(graphHopperFolder);
+	setGraphHopperLocation(graphHopperFolder);
 
-        if (encodingManager == null)
-            encodingManager = EncodingManager.create(ghLocation);
+	if (encodingManager == null)
+	    encodingManager = EncodingManager.create(ghLocation);
 
-        if (!allowWrites && dataAccessType.isMMap())
-            dataAccessType = DAType.MMAP_RO;
+	if (!allowWrites && dataAccessType.isMMap())
+	    dataAccessType = DAType.MMAP_RO;
 
-        GHDirectory dir = new GHDirectory(ghLocation, dataAccessType);
-        if (chEnabled) {
-            graph = new LevelGraphStorage(dir, encodingManager, hasElevation());
-        }
-        else if (encodingManager.needsTurnCostsSupport()) {
-            graph = new GraphHopperStorage(dir, encodingManager, hasElevation(), new TurnCostStorage());
-        }
-        else {
-            graph = new GraphHopperStorage(dir, encodingManager, hasElevation());
-        }
-        
-        graph.setSegmentSize(defaultSegmentSize);
+	GHDirectory dir = new GHDirectory(ghLocation, dataAccessType);
+	if (chEnabled)
+	    graph = new LevelGraphStorage(dir, encodingManager, hasElevation());
+	else if (encodingManager.needsTurnCostsSupport())
+	    graph = new GraphHopperStorage(dir, encodingManager, hasElevation(),
+			    new TurnCostStorage());
+	else
+	    graph = new GraphHopperStorage(dir, encodingManager, hasElevation());
 
-        Lock lock = null;
-        try
-        {
-            // create locks only if writes are allowed, if they are not allowed a lock cannot be created 
-            // (e.g. on a read only filesystem locks would fail)
-            if (graph.getDirectory().getDefaultType().isStoring() && isAllowWrites())
-            {
-                lockFactory.setLockDir(new File(ghLocation));
-                lock = lockFactory.create(fileLockName, false);
-                if (!lock.tryLock())
-                    throw new RuntimeException("To avoid reading partial data we need to obtain the read lock but it failed. In " + ghLocation, lock.getObtainFailedReason());
-            }
+	graph.setSegmentSize(defaultSegmentSize);
 
-            if (!graph.loadExisting())
-                return false;
+	Lock lock = null;
+	try
+	{
+	    // create locks only if writes are allowed, if they are not allowed
+	    // a lock cannot be created
+	    // (e.g. on a read only filesystem locks would fail)
+	    if (graph.getDirectory().getDefaultType().isStoring() && isAllowWrites())
+	    {
+		lockFactory.setLockDir(new File(ghLocation));
+		lock = lockFactory.create(fileLockName, false);
+		if (!lock.tryLock())
+		    throw new RuntimeException(
+				    "To avoid reading partial data we need to obtain the read lock but it failed. In "
+						    + ghLocation, lock.getObtainFailedReason());
+	    }
 
-            postProcessing();
-            fullyLoaded = true;
-            return true;
-        } finally
-        {
-            if (lock != null)
-                lock.release();
-        }
+	    if (!graph.loadExisting())
+		return false;
+
+	    postProcessing();
+	    fullyLoaded = true;
+	    return true;
+	} finally
+	{
+	    if (lock != null)
+		lock.release();
+	}
     }
 
     /**
@@ -795,32 +803,30 @@
      */
     protected void postProcessing()
     {
-        encodingManager = graph.getEncodingManager();
-        if (chEnabled)
-            initCHPrepare();
+	encodingManager = graph.getEncodingManager();
+	if (chEnabled)
+	    initCHPrepare();
 
-        if (!isPrepared())
-            prepare();
-        initLocationIndex();
+	if (!isPrepared())
+	    prepare();
+	initLocationIndex();
     }
 
     private boolean isPrepared()
     {
-        return "true".equals(graph.getProperties().get("prepare.done"));
+	return "true".equals(graph.getProperties().get("prepare.done"));
     }
 
     protected void initCHPrepare()
     {
-        FlagEncoder encoder = encodingManager.getSingle();
-        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(encoder,
-                createWeighting(new WeightingMap(chWeighting), encoder), traversalMode);
-        tmpPrepareCH.setPeriodicUpdates(periodicUpdates).
-                setLazyUpdates(lazyUpdates).
-                setNeighborUpdates(neighborUpdates).
-                setLogMessages(logMessages);
+	FlagEncoder encoder = encodingManager.getSingle();
+	PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(encoder,
+			createWeighting(new WeightingMap(chWeighting), encoder), traversalMode);
+	tmpPrepareCH.setPeriodicUpdates(periodicUpdates).setLazyUpdates(lazyUpdates)
+			.setNeighborUpdates(neighborUpdates).setLogMessages(logMessages);
 
-        prepare = tmpPrepareCH;
-        prepare.setGraph(graph);
+	prepare = tmpPrepareCH;
+	prepare.setGraph(graph);
     }
 
     /**
@@ -828,193 +834,196 @@
      * created. Note that all URL parameters are available in the weightingParameters as String if
      * you use the GraphHopper Web module.
      * <p>
+     * 
      * @see Weighting.Params.create
-     * @param wMap all parameters influencing the weighting. E.g. URL parameters coming via
-     * GHRequest
-     * @param encoder the required vehicle
+     * @param wMap
+     *            all parameters influencing the weighting. E.g. URL parameters coming via GHRequest
+     * @param encoder
+     *            the required vehicle
      * @return the weighting to be used for route calculation
      */
-    public Weighting createWeighting( WeightingMap wMap, FlagEncoder encoder )
+    public Weighting createWeighting(WeightingMap wMap, FlagEncoder encoder)
     {
-        String weighting = wMap.getWeighting();
-        Weighting result;
+	String weighting = wMap.getWeighting();
+	Weighting result;
 
-        if ("shortest".equalsIgnoreCase(weighting))
-        {
-            result = new ShortestWeighting();
-        } else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty())
-        {
-            if (encoder.supports(PriorityWeighting.class))
-                result = new PriorityWeighting(encoder);
-            else
-                result = new FastestWeighting(encoder);
-        } else
-        {
-            throw new UnsupportedOperationException("weighting " + weighting + " not supported");
-        }
+	if ("shortest".equalsIgnoreCase(weighting))
+	    result = new ShortestWeighting();
+	else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty())
+	{
+	    if (encoder.supports(PriorityWeighting.class))
+		result = new PriorityWeighting(encoder);
+	    else
+		result = new FastestWeighting(encoder);
+	} else
+	    throw new UnsupportedOperationException("weighting " + weighting + " not supported");
 
-        if (encoder.supports(TurnWeighting.class))
-        {
-            result = new TurnWeighting(result, encoder, (TurnCostStorage) graph.getExtendedStorage());
-        }
-        return result;
+	if (encoder.supports(TurnWeighting.class))
+	    result = new TurnWeighting(result, encoder,
+			    (TurnCostStorage) graph.getExtendedStorage());
+	return result;
     }
 
     @Override
-    public GHResponse route( GHRequest request )
+    public GHResponse route(GHRequest request)
     {
-        if (graph == null || !fullyLoaded)
-            throw new IllegalStateException("Call load or importOrLoad before routing");
+	if (graph == null || !fullyLoaded)
+	    throw new IllegalStateException("Call load or importOrLoad before routing");
 
-        if (graph.isClosed())
-            throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
+	if (graph.isClosed())
+	    throw new IllegalStateException(
+			    "You need to create a new GraphHopper instance as it is already closed");
 
-        GHResponse response = new GHResponse();
-        List<Path> paths = getPaths(request, response);
-        if (response.hasErrors())
-            return response;
+	GHResponse response = new GHResponse();
+	List<Path> paths = getPaths(request, response);
+	if (response.hasErrors())
+	    return response;
 
-        enableInstructions = request.getHints().getBool("instructions", enableInstructions);
-        calcPoints = request.getHints().getBool("calcPoints", calcPoints);
-        double wayPointMaxDistance = request.getHints().getDouble("wayPointMaxDistance", 1d);
-        Locale locale = request.getLocale();
-        DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
+	enableInstructions = request.getHints().getBool("instructions", enableInstructions);
+	calcPoints = request.getHints().getBool("calcPoints", calcPoints);
+	double wayPointMaxDistance = request.getHints().getDouble("wayPointMaxDistance", 1d);
+	Locale locale = request.getLocale();
+	DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
 
-        new PathMerger().
-                setCalcPoints(calcPoints).
-                setDouglasPeucker(peucker).
-                setEnableInstructions(enableInstructions).
-                setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0).
-                doWork(response, paths, trMap.getWithFallBack(locale));
-        return response;
+	new PathMerger().setCalcPoints(calcPoints).setDouglasPeucker(peucker)
+			.setEnableInstructions(enableInstructions)
+			.setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0)
+			.doWork(response, paths, trMap.getWithFallBack(locale));
+	return response;
     }
 
-    protected List<Path> getPaths( GHRequest request, GHResponse rsp )
+    protected List<Path> getPaths(GHRequest request, GHResponse rsp)
     {
-        String vehicle = request.getVehicle();
-        if (vehicle.isEmpty())
-            vehicle = encodingManager.getSingle().toString();
+	String vehicle = request.getVehicle();
+	if (vehicle.isEmpty())
+	    vehicle = encodingManager.getSingle().toString();
 
-        if (!encodingManager.supports(vehicle))
-        {
-            rsp.addError(new IllegalArgumentException("Vehicle " + vehicle + " unsupported. "
-                    + "Supported are: " + getEncodingManager()));
-            return Collections.emptyList();
-        }
+	if (!encodingManager.supports(vehicle))
+	{
+	    rsp.addError(new IllegalArgumentException("Vehicle " + vehicle + " unsupported. "
+			    + "Supported are: " + getEncodingManager()));
+	    return Collections.emptyList();
+	}
 
-        TraversalMode tMode;
-        String tModeStr = request.getHints().get("traversal_mode", traversalMode.toString());
-        try
-        {
-            tMode = TraversalMode.fromString(tModeStr);
-        } catch (Exception ex)
-        {
-            rsp.addError(ex);
-            return Collections.emptyList();
-        }
+	TraversalMode tMode;
+	String tModeStr = request.getHints().get("traversal_mode", traversalMode.toString());
+	try
+	{
+	    tMode = TraversalMode.fromString(tModeStr);
+	} catch (Exception ex)
+	{
+	    rsp.addError(ex);
+	    return Collections.emptyList();
+	}
 
-        List<GHPoint> points = request.getPoints();
-        if (points.size() < 2)
-        {
-            rsp.addError(new IllegalStateException("At least 2 points has to be specified, but was:" + points.size()));
-            return Collections.emptyList();
-        }
+	List<GHPoint> points = request.getPoints();
+	if (points.size() < 2)
+	{
+	    rsp.addError(new IllegalStateException(
+			    "At least 2 points has to be specified, but was:" + points.size()));
+	    return Collections.emptyList();
+	}
 
-        FlagEncoder encoder = encodingManager.getEncoder(vehicle);
-        EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
-        GHPoint startPoint = points.get(0);
-        StopWatch sw = new StopWatch().start();
-        QueryResult fromRes = locationIndex.findClosest(startPoint.lat, startPoint.lon, edgeFilter);
-        String debug = "idLookup[0]:" + sw.stop().getSeconds() + "s";
-        sw.stop();
-        if (!fromRes.isValid())
-        {
-            rsp.addError(new IllegalArgumentException("Cannot find point 0: " + startPoint));
-            return Collections.emptyList();
-        }
+	FlagEncoder encoder = encodingManager.getEncoder(vehicle);
+	EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
+	GHPoint startPoint = points.get(0);
+	StopWatch sw = new StopWatch().start();
+	QueryResult fromRes = locationIndex.findClosest(startPoint.lat, startPoint.lon, edgeFilter);
+	String debug = "idLookup[0]:" + sw.stop().getSeconds() + "s";
+	sw.stop();
+	if (!fromRes.isValid())
+	{
+	    rsp.addError(new IllegalArgumentException("Cannot find point 0: " + startPoint));
+	    return Collections.emptyList();
+	}
 
-        List<Path> paths = new ArrayList<Path>(points.size() - 1);
-        for (int placeIndex = 1; placeIndex < points.size(); placeIndex++)
-        {
-            GHPoint point = points.get(placeIndex);
-            sw = new StopWatch().start();
-            QueryResult toRes = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
-            debug += ", [" + placeIndex + "] idLookup:" + sw.stop().getSeconds() + "s";
-            if (!toRes.isValid())
-            {
-                rsp.addError(new IllegalArgumentException("Cannot find point " + placeIndex + ": " + point));
-                break;
-            }
+	List<Path> paths = new ArrayList<Path>(points.size() - 1);
+	for (int placeIndex = 1; placeIndex < points.size(); placeIndex++)
+	{
+	    GHPoint point = points.get(placeIndex);
+	    sw = new StopWatch().start();
+	    QueryResult toRes = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
+	    debug += ", [" + placeIndex + "] idLookup:" + sw.stop().getSeconds() + "s";
+	    if (!toRes.isValid())
+	    {
+		rsp.addError(new IllegalArgumentException("Cannot find point " + placeIndex + ": "
+				+ point));
+		break;
+	    }
 
-            sw = new StopWatch().start();
-            String algoStr = request.getAlgorithm().isEmpty() ? "dijkstrabi" : request.getAlgorithm();
-            RoutingAlgorithm algo = null;
-            if (chEnabled)
-            {
-                if (prepare == null)
-                    throw new IllegalStateException("Preparation object is null. CH-preparation wasn't done or did you "
-                            + "forget to call setCHEnable(false)?");
+	    sw = new StopWatch().start();
+	    String algoStr = request.getAlgorithm().isEmpty() ? "dijkstrabi" : request
+			    .getAlgorithm();
+	    RoutingAlgorithm algo = null;
+	    if (chEnabled)
+	    {
+		if (prepare == null)
+		    throw new IllegalStateException(
+				    "Preparation object is null. CH-preparation wasn't done or did you "
+						    + "forget to call setCHEnable(false)?");
 
-                if (algoStr.equals("dijkstrabi"))
-                    algo = prepare.createAlgo();
-                else if (algoStr.equals("astarbi"))
-                    algo = ((PrepareContractionHierarchies) prepare).createAStar();
-                else
-                {
-                    rsp.addError(new IllegalStateException(
-                            "Only dijkstrabi and astarbi is supported for LevelGraph (using contraction hierarchies)!"));
-                    break;
-                }
-            } else
-            {
-                Weighting weighting = createWeighting(request.getHints(), encoder);
-                prepare = NoOpAlgorithmPreparation.createAlgoPrepare(graph, algoStr, encoder, weighting, tMode);
-                algo = prepare.createAlgo();
-            }
+		if (algoStr.equals("dijkstrabi"))
+		    algo = prepare.createAlgo();
+		else if (algoStr.equals("astarbi"))
+		    algo = ((PrepareContractionHierarchies) prepare).createAStar();
+		else
+		{
+		    rsp.addError(new IllegalStateException(
+				    "Only dijkstrabi and astarbi is supported for LevelGraph (using contraction hierarchies)!"));
+		    break;
+		}
+	    } else
+	    {
+		Weighting weighting = createWeighting(request.getHints(), encoder);
+		prepare = NoOpAlgorithmPreparation.createAlgoPrepare(graph, algoStr, encoder,
+				weighting, tMode);
+		algo = prepare.createAlgo();
+	    }
 
-            debug += ", algoInit:" + sw.stop().getSeconds() + "s";
-            sw = new StopWatch().start();
+	    debug += ", algoInit:" + sw.stop().getSeconds() + "s";
+	    sw = new StopWatch().start();
 
-            Path path = algo.calcPath(fromRes, toRes);
-            if (path.getMillis() < 0)
-                throw new RuntimeException("Time was negative. Please report as bug and include:" + request);
+	    Path path = algo.calcPath(fromRes, toRes);
+	    if (path.getMillis() < 0)
+		throw new RuntimeException("Time was negative. Please report as bug and include:"
+				+ request);
 
-            paths.add(path);
-            debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s, " + path.getDebugInfo();
-            visitedSum.addAndGet(algo.getVisitedNodes());
-            fromRes = toRes;
-        }
+	    paths.add(path);
+	    debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s, "
+			    + path.getDebugInfo();
+	    visitedSum.addAndGet(algo.getVisitedNodes());
+	    fromRes = toRes;
+	}
 
-        if (rsp.hasErrors())
-            return Collections.emptyList();
+	if (rsp.hasErrors())
+	    return Collections.emptyList();
 
-        if (points.size() - 1 != paths.size())
-            throw new RuntimeException("There should be exactly one more places than paths. places:" + points.size() + ", paths:" + paths.size());
+	if (points.size() - 1 != paths.size())
+	    throw new RuntimeException(
+			    "There should be exactly one more places than paths. places:"
+					    + points.size() + ", paths:" + paths.size());
 
-        rsp.setDebugInfo(debug);
-        return paths;
+	rsp.setDebugInfo(debug);
+	return paths;
     }
 
-    protected LocationIndex createLocationIndex( Directory dir )
+    protected LocationIndex createLocationIndex(Directory dir)
     {
-        LocationIndex tmpIndex;
-        if (graph instanceof LevelGraph)
-        {
-            tmpIndex = new LocationIndexTreeSC((LevelGraph) graph, dir);
-        } else
-        {
-            tmpIndex = new LocationIndexTree(graph, dir);
-        }
-        tmpIndex.setResolution(preciseIndexResolution);
-        ((LocationIndexTree) tmpIndex).setMaxRegionSearch(maxRegionSearch);
+	LocationIndex tmpIndex;
+	if (graph instanceof LevelGraph)
+	    tmpIndex = new LocationIndexTreeSC((LevelGraph) graph, dir);
+	else
+	    tmpIndex = new LocationIndexTree(graph, dir);
+	tmpIndex.setResolution(preciseIndexResolution);
+	((LocationIndexTree) tmpIndex).setMaxRegionSearch(maxRegionSearch);
 
-        if (!tmpIndex.loadExisting())
-        {
-            ensureWriteAccess();
-            tmpIndex.prepareIndex();
-        }
+	if (!tmpIndex.loadExisting())
+	{
+	    ensureWriteAccess();
+	    tmpIndex.prepareIndex();
+	}
 
-        return tmpIndex;
+	return tmpIndex;
     }
 
     /**
@@ -1025,69 +1034,77 @@
      */
     protected void initLocationIndex()
     {
-        if (locationIndex != null)
-            throw new IllegalStateException("Cannot initialize locationIndex twice!");
+	if (locationIndex != null)
+	    throw new IllegalStateException("Cannot initialize locationIndex twice!");
 
-        locationIndex = createLocationIndex(graph.getDirectory());
+	locationIndex = createLocationIndex(graph.getDirectory());
     }
 
     protected void optimize()
     {
-        logger.info("optimizing ... (" + Helper.getMemInfo() + ")");
-        graph.optimize();
-        logger.info("finished optimize (" + Helper.getMemInfo() + ")");
+	logger.info("optimizing ... (" + Helper.getMemInfo() + ")");
+	graph.optimize();
+	logger.info("finished optimize (" + Helper.getMemInfo() + ")");
 
-        // Later: move this into the GraphStorage.optimize method
-        // Or: Doing it after preparation to optimize shortcuts too. But not possible yet #12
-        if (sortGraph)
-        {
-            if (graph instanceof LevelGraph && isPrepared())
-                throw new IllegalArgumentException("Sorting prepared LevelGraph is not possible yet. See #12");
+	// Later: move this into the GraphStorage.optimize method
+	// Or: Doing it after preparation to optimize shortcuts too. But not
+	// possible yet #12
+	if (sortGraph)
+	{
+	    if (graph instanceof LevelGraph && isPrepared())
+		throw new IllegalArgumentException(
+				"Sorting prepared LevelGraph is not possible yet. See #12");
 
-            GraphStorage newGraph = GHUtility.newStorage(graph);
-            GHUtility.sortDFS(graph, newGraph);
-            logger.info("graph sorted (" + Helper.getMemInfo() + ")");
-            graph = newGraph;
-        }
+	    GraphStorage newGraph = GHUtility.newStorage(graph);
+	    GHUtility.sortDFS(graph, newGraph);
+	    logger.info("graph sorted (" + Helper.getMemInfo() + ")");
+	    graph = newGraph;
+	}
     }
 
     protected void prepare()
     {
-        boolean tmpPrepare = doPrepare && prepare != null;
-        if (tmpPrepare)
-        {
-            ensureWriteAccess();
-            if (prepare instanceof PrepareContractionHierarchies && encodingManager.getVehicleCount() > 1)
-                throw new IllegalArgumentException("Contraction hierarchies preparation "
-                        + "requires (at the moment) only one vehicle. But was:" + encodingManager);
+	boolean tmpPrepare = doPrepare && prepare != null;
+	if (tmpPrepare)
+	{
+	    ensureWriteAccess();
+	    if (prepare instanceof PrepareContractionHierarchies
+			    && encodingManager.getVehicleCount() > 1)
+		throw new IllegalArgumentException("Contraction hierarchies preparation "
+				+ "requires (at the moment) only one vehicle. But was:"
+				+ encodingManager);
 
-            logger.info("calling prepare.doWork for " + encodingManager.toString() + " ... (" + Helper.getMemInfo() + ")");
-            prepare.doWork();
-            graph.getProperties().put("prepare.date", formatDateTime(new Date()));
-        }
-        graph.getProperties().put("prepare.done", tmpPrepare);
+	    logger.info("calling prepare.doWork for " + encodingManager.toString() + " ... ("
+			    + Helper.getMemInfo() + ")");
+	    prepare.doWork();
+	    graph.getProperties().put("prepare.date", formatDateTime(new Date()));
+	}
+	graph.getProperties().put("prepare.done", tmpPrepare);
     }
 
     protected void cleanUp()
     {
-        int prev = graph.getNodes();
-        PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph, encodingManager);
-        preparation.setMinNetworkSize(minNetworkSize);
-        preparation.setMinOnewayNetworkSize(this.minOnewayNetworkSize);
-        logger.info("start finding subnetworks, " + Helper.getMemInfo());
-        preparation.doWork();
-        int n = graph.getNodes();
-        // calculate remaining subnetworks
-        int remainingSubnetworks = preparation.findSubnetworks().size();
-        logger.info("edges: " + graph.getAllEdges().getMaxId() + ", nodes " + n + ", there were " + preparation.getSubNetworks()
-                + " subnetworks. removed them => " + (prev - n) + " less nodes. Remaining subnetworks:" + remainingSubnetworks);
+	int prev = graph.getNodes();
+	PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph,
+			encodingManager);
+	preparation.setMinNetworkSize(minNetworkSize);
+	preparation.setMinOnewayNetworkSize(this.minOnewayNetworkSize);
+	logger.info("start finding subnetworks, " + Helper.getMemInfo());
+	preparation.doWork();
+	int n = graph.getNodes();
+	// calculate remaining subnetworks
+	int remainingSubnetworks = preparation.findSubnetworks().size();
+	logger.info("edges: " + graph.getAllEdges().getMaxId() + ", nodes " + n + ", there were "
+			+ preparation.getSubNetworks() + " subnetworks. removed them => "
+			+ (prev - n) + " less nodes. Remaining subnetworks:" + remainingSubnetworks);
     }
 
     protected void flush()
     {
-        logger.info("flushing graph " + graph.toString() + ", details:" + graph.toDetailsString() + ", " + Helper.getMemInfo() + ")");
-        graph.flush();
-        fullyLoaded = true;
+	logger.info("flushing graph " + graph.toString() + ", details:" + graph.toDetailsString()
+			+ ", " + Helper.getMemInfo() + ")");
+	graph.flush();
+	fullyLoaded = true;
     }
 
     /**
@@ -1096,19 +1113,20 @@
      */
     public void close()
     {
-        if (graph != null)
-            graph.close();
+	if (graph != null)
+	    graph.close();
 
-        if (locationIndex != null)
-            locationIndex.close();
+	if (locationIndex != null)
+	    locationIndex.close();
 
-        try
-        {
-            lockFactory.forceRemove(fileLockName, true);
-        } catch (Exception ex)
-        {
-            // silently fail e.g. on Windows where we cannot remove an unreleased native lock
-        }
+	try
+	{
+	    lockFactory.forceRemove(fileLockName, true);
+	} catch (Exception ex)
+	{
+	    // silently fail e.g. on Windows where we cannot remove an
+	    // unreleased native lock
+	}
     }
 
     /**
@@ -1117,30 +1135,32 @@
      */
     public void clean()
     {
-        if (getGraphHopperLocation().isEmpty())
-            throw new IllegalStateException("Cannot clean GraphHopper without specified graphHopperLocation");
+	if (getGraphHopperLocation().isEmpty())
+	    throw new IllegalStateException(
+			    "Cannot clean GraphHopper without specified graphHopperLocation");
 
-        File folder = new File(getGraphHopperLocation());
-        Helper.removeDir(folder);
+	File folder = new File(getGraphHopperLocation());
+	Helper.removeDir(folder);
     }
 
     // make sure this is identical to buildDate used in pom.xml
     // <maven.build.timestamp.format>yyyy-MM-dd'T'HH:mm:ssZ</maven.build.timestamp.format>
-    private String formatDateTime( Date date )
+    private String formatDateTime(Date date)
     {
-        return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
+	return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
     }
 
     protected void ensureNotLoaded()
     {
-        if (fullyLoaded)
-            throw new IllegalStateException("No configuration changes are possible after loading the graph");
+	if (fullyLoaded)
+	    throw new IllegalStateException(
+			    "No configuration changes are possible after loading the graph");
     }
 
     protected void ensureWriteAccess()
     {
-        if (!allowWrites)
-            throw new IllegalStateException("Writes are not allowed!");
+	if (!allowWrites)
+	    throw new IllegalStateException("Writes are not allowed!");
     }
 
     /**
@@ -1149,6 +1169,6 @@
      */
     public long getVisitedSum()
     {
-        return visitedSum.get();
+	return visitedSum.get();
     }
 }
Index: core/src/main/java/com/graphhopper/reader/Way.java
===================================================================
--- core/src/main/java/com/graphhopper/reader/Way.java	(revision 2400)
+++ core/src/main/java/com/graphhopper/reader/Way.java	(working copy)
@@ -1,11 +1,5 @@
 package com.graphhopper.reader;
 
-import gnu.trove.list.TLongList;
-
-
 public interface Way extends RoutingElement {
 
-	TLongList getNodes();
-
-
 }
Index: core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnWay.java
===================================================================
--- core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnWay.java	(revision 2400)
+++ core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnWay.java	(working copy)
@@ -17,8 +17,9 @@
  */
 package com.graphhopper.reader.osgb.dpn;
 
-import gnu.trove.list.TLongList;
-import gnu.trove.list.array.TLongArrayList;
+import gnu.trove.map.TDoubleLongMap;
+import gnu.trove.map.TDoubleObjectMap;
+import gnu.trove.map.TLongObjectMap;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -34,8 +35,6 @@
 import org.slf4j.LoggerFactory;
 
 import com.graphhopper.reader.Way;
-import com.graphhopper.reader.osgb.OSITNNode;
-import com.graphhopper.reader.osgb.OSITNWay;
 
 /**
  * Represents an OSM Way
@@ -43,111 +42,176 @@
  * 
  * @author Nop
  */
-public class OsDpnWay extends OSITNWay implements Way {
-	private static final long WAY_NODE_PREFIX_MOD = 100000000000000000L;
-	private long endNode;
-	private static final Logger logger = LoggerFactory
-			.getLogger(OsDpnWay.class);
+public class OsDpnWay extends OsDpnElement implements Way {
+    private static final long WAY_NODE_PREFIX_MOD = 100000000000000000L;
+    protected final List<String> nodes = new ArrayList<String>(5);
+    private String endNode;
+    protected String startCoord;
+    protected String endCoord;
+    private String[] wayCoords;
+    private static final Logger logger = LoggerFactory
+            .getLogger(OsDpnWay.class);
+
+    /**
+     * Constructor for XML Parser
+     * 
+     * @throws TransformException
+     * @throws FactoryException
+     * @throws MismatchedDimensionException
+     */
+    public static OsDpnWay create(String idStr, XMLStreamReader parser)
+            throws XMLStreamException, MismatchedDimensionException,
+            FactoryException, TransformException {
+        System.out.println("OsDpnWay.create()");
+        OsDpnWay way = new OsDpnWay(idStr);
+        parser.nextTag();
+        way.readTags(parser);
+        way.setTag("highway", "motorway");
+        logger.info(way.toString());
+        return way;
+    }
+
+    public OsDpnWay(String id) {
+        super(id, WAY);
+    }
+
+    public List<String> getNodes() {
+        return nodes;
+    }
 
-	/**
-	 * Constructor for XML Parser
-	 * @throws TransformException 
-	 * @throws FactoryException 
-	 * @throws MismatchedDimensionException 
-	 */
-	public static OsDpnWay create(long id, XMLStreamReader parser)
-			throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
-		OsDpnWay way = new OsDpnWay(id);
-		parser.nextTag();
-		way.readTags(parser);
-		way.setTag("highway", "motorway");
-		logger.info(way.toString());
-		return way;
-	}
+    @Override
+    protected void parseCoords(String lineDefinition) {
+        String[] lineSegments = lineDefinition.split(" ");
+        wayCoords = Arrays
+                .copyOfRange(lineSegments, 1, lineSegments.length - 1);
+        logger.info(toString() + " "
+                + ((wayCoords.length == 0) ? "0" : wayCoords[0]));
+    }
 
-	public OsDpnWay(long id) {
-		super(id);
-	}
+    @Override
+    protected void parseCoords(int dimensions, String lineDefinition) {
+        String[] lineSegments = lineDefinition.split(" ");
+        wayCoords = new String[lineSegments.length / dimensions];
+        StringBuilder curString = null;
+        for (int i = 0; i < lineSegments.length; i++) {
+            String string = lineSegments[i];
+            switch (i % dimensions) {
+                case 0: {
+                    int coordNumber = i / dimensions;
+                    if (coordNumber > 0) {
+                        wayCoords[coordNumber - 1] = curString.toString();
+                    }
+                    curString = new StringBuilder();
+                    curString.append(string);
+                    break;
+                }
 
-	@Override
-	protected void parseCoords(String lineDefinition) {
-		String[] lineSegments = lineDefinition.split(" ");
-		wayCoords = Arrays
-				.copyOfRange(lineSegments, 1, lineSegments.length -1);
-		logger.info(toString() + " "  + ((wayCoords.length == 0)?"0":wayCoords[0]));
-	}
-	
-	@Override
-	protected void parseCoords(int dimensions, String lineDefinition) {
-		String[] lineSegments = lineDefinition.split(" ");
-		wayCoords = new String[lineSegments.length/dimensions];
-		StringBuilder curString = null;
-		for (int i = 0; i < lineSegments.length; i++) {
-			String string = lineSegments[i];
-			switch (i % dimensions) {
-			case 0: {
-				int coordNumber = i/dimensions;
-				if(coordNumber >0) {
-					wayCoords[coordNumber-1] = curString.toString();
-				}
-				curString = new StringBuilder();
-				curString.append(string);
-				break;
-			}
-					
-			case 1:	
-			case 2: {
-				curString.append(',');
-				curString.append(string); 
-			}
-			}
-		}
-		wayCoords[wayCoords.length-1] = curString.toString();
-		addWayNodes();
-		nodes.add(endNode);
-		logger.info(toString() + " "  + ((wayCoords.length == 0)?"0":wayCoords[0]));
-	}
-	@Override
-	protected void parseNetworkMember(String elementText) {
-		throw new UnsupportedOperationException();
-	}
+                case 1:
+                case 2: {
+                    curString.append(',');
+                    curString.append(string);
+                }
+            }
+        }
+        wayCoords[wayCoords.length - 1] = curString.toString();
+        addWayNodes();
+        nodes.add(endNode);
+        logger.info(toString() + " "
+                + ((wayCoords.length == 0) ? "0" : wayCoords[0]));
+    }
 
-	@Override
-	protected void addDirectedNode(String nodeId, String grade,
-			String orientation) {
-		String idStr = nodeId.substring(5);
-		if (null != grade) {
-			idStr = grade + idStr;
-		}
-		long id = Long.parseLong(idStr);
+    @Override
+    protected void parseNetworkMember(String elementText) {
+        throw new UnsupportedOperationException();
+    }
 
-		if (0 == nodes.size()) {
-			nodes.add(id);
-		} else {
-			endNode = id;
-		}
-	}
+    @Override
+    protected void addNode(String nodeId) {
+        String idStr = nodeId.substring(1);
+        if (0 == nodes.size()) {
+            nodes.add(idStr);
+        } else {
+            endNode = idStr;
+        }
+    }
 
-	@Override
-	protected void addDirectedLink(String nodeId, String orientation) {
-		throw new UnsupportedOperationException();
-	}
+    protected void addWayNodes() {
+        for (int i = 1; i <= wayCoords.length; i++) {
+            long idPrefix = i;
+            String extraId = idPrefix + getId();
+            nodes.add(extraId);
+        }
+    }
 
-	public List<OSITNNode> evaluateWayNodes() throws MismatchedDimensionException, FactoryException, TransformException {
-		List<OSITNNode> wayNodes = new ArrayList<OSITNNode>();
+    @Override
+    protected void addDirectedLink(String nodeId, String orientation) {
+        throw new UnsupportedOperationException();
+    }
 
-		for (int i = 0; i < wayCoords.length; i++) {
-			String wayCoord = wayCoords[i];
-			long idPrefix = (i+1) * WAY_NODE_PREFIX_MOD;
-			long id = idPrefix + getId();
-			OSITNNode wayNode = new OSITNNode(id);
-			wayNode.parseCoordinateString(wayCoord, ",");
-			wayNodes.add(wayNode);
-		}
-		return wayNodes;
-	}
+    /**
+     * Creates a new OsDpnNode for each wayCoord. This also Looks for direction
+     * flags in edgeIdToXToYToNodeFlagsMap for the wayId, x, y combination. If
+     * it exists then set the node tag TAG_KEY_NOENTRY_ORIENTATION to true and
+     * the TAG_KEY_ONEWAY_ORIENTATION node tag to -1 for one direction and true
+     * for the other.
+     * 
+     * @param edgeIdToXToYToNodeFlagsMap
+     * @return
+     * @throws TransformException
+     * @throws FactoryException
+     * @throws MismatchedDimensionException
+     */
+    public List<OsDpnNode> evaluateWayNodes(
+            TLongObjectMap<TDoubleObjectMap<TDoubleLongMap>> edgeIdToXToYToNodeFlagsMap)
+            throws MismatchedDimensionException, FactoryException,
+            TransformException {
+        List<OsDpnNode> wayNodes = new ArrayList<OsDpnNode>();
 
-	public void clearWayNodes() {
-		wayCoords = null;
-	}
+        for (int i = 0; i < wayCoords.length; i++) {
+            String wayCoord = wayCoords[i];
+
+            long idPrefix = (i + 1) * WAY_NODE_PREFIX_MOD;
+            String id = idPrefix + getId();
+            OsDpnNode wayNode = new OsDpnNode(id);
+            wayNode.parseCoords(wayCoord);
+
+            logger.info("Node " + getId() + " coords: " + wayCoord + " tags: ");
+            for (String tagKey : wayNode.getTags().keySet()) {
+                logger.info("\t " + tagKey + " : " + wayNode.getTag(tagKey));
+            }
+
+            wayNodes.add(wayNode);
+        }
+        return wayNodes;
+    }
+
+    /**
+     * Memory management method. Once a way is processed the stored string
+     * coordinates are no longer required so set them to null so they can be
+     * garbage collected
+     */
+    public void clearStoredCoords() {
+        wayCoords = null;
+        startCoord = null;
+        endCoord = null;
+    }
+
+    public String[] getWayCoords() {
+        return wayCoords;
+    }
+
+    public String getStartCoord() {
+        return startCoord;
+    }
+
+    public String getEndCoord() {
+        return endCoord;
+    }
+
+    protected void parseCoordinateString(String elementText,
+            String elementSeparator) {
+        throw new UnsupportedOperationException();
+
+    }
+
 }
Index: core/src/main/java/com/graphhopper/reader/osgb/OsItnInputFile.java
===================================================================
--- core/src/main/java/com/graphhopper/reader/osgb/OsItnInputFile.java	(revision 2400)
+++ core/src/main/java/com/graphhopper/reader/osgb/OsItnInputFile.java	(working copy)
@@ -43,7 +43,6 @@
 import org.slf4j.LoggerFactory;
 
 import com.graphhopper.reader.RoutingElement;
-import com.graphhopper.reader.osgb.dpn.OsDpnWay;
 import com.graphhopper.reader.pbf.Sink;
 
 /**
@@ -53,223 +52,222 @@
  * @author Stuart Adam
  */
 public class OsItnInputFile implements Sink, Closeable {
-	private boolean eof;
-	private InputStream bis;
-	// for xml parsing
-	private XMLStreamReader parser;
-	// for pbf parsing
-	private boolean binary = false;
-	private final BlockingQueue<RoutingElement> itemQueue;
-	private boolean hasIncomingData;
-	private int workerThreads = -1;
-	private static final Logger logger = LoggerFactory
-			.getLogger(OsItnInputFile.class);
-	private String name;
+    private boolean eof;
+    private final InputStream bis;
+    // for xml parsing
+    private XMLStreamReader parser;
+    // for pbf parsing
+    private boolean binary = false;
+    private final BlockingQueue<RoutingElement> itemQueue;
+    private boolean hasIncomingData;
+    private int workerThreads = -1;
+    private static final Logger logger = LoggerFactory
+            .getLogger(OsItnInputFile.class);
+    private final String name;
+
+    public OsItnInputFile(File file) throws IOException {
+        name = file.getAbsolutePath();
+        bis = decode(file);
+        itemQueue = new LinkedBlockingQueue<RoutingElement>(50000);
+    }
 
-	public OsItnInputFile(File file) throws IOException {
-		name = file.getAbsolutePath();
-		bis = decode(file);
-		itemQueue = new LinkedBlockingQueue<RoutingElement>(50000);
-	}
+    public OsItnInputFile open() throws XMLStreamException {
+        openXMLStream(bis);
+        return this;
+    }
 
-	public OsItnInputFile open() throws XMLStreamException {
-		openXMLStream(bis);
-		return this;
-	}
-	
-	public InputStream getInputStream() {
-		return bis;
-	}
+    public InputStream getInputStream() {
+        return bis;
+    }
 
-	/**
-	 * Currently on for pbf format. Default is number of cores.
-	 */
-	public OsItnInputFile setWorkerThreads(int num) {
-		workerThreads = num;
-		return this;
-	}
+    /**
+     * Currently on for pbf format. Default is number of cores.
+     */
+    public OsItnInputFile setWorkerThreads(int num) {
+        workerThreads = num;
+        return this;
+    }
 
-	@SuppressWarnings("unchecked")
-	private InputStream decode(File file) throws IOException {
-		final String name = file.getName();
+    @SuppressWarnings("unchecked")
+    private InputStream decode(File file) throws IOException {
+        final String name = file.getName();
 
-		InputStream ips = null;
-		try {
-			ips = new BufferedInputStream(new FileInputStream(file), 50000);
-		} catch (FileNotFoundException e) {
-			throw new RuntimeException(e);
-		}
-		ips.mark(10);
+        InputStream ips = null;
+        try {
+            ips = new BufferedInputStream(new FileInputStream(file), 50000);
+        } catch (FileNotFoundException e) {
+            throw new RuntimeException(e);
+        }
+        ips.mark(10);
 
-		// check file header
-		byte header[] = new byte[6];
-		ips.read(header);
+        // check file header
+        byte header[] = new byte[6];
+        ips.read(header);
 
-		/*
-		 * can parse bz2 directly with additional lib if (header[0] == 'B' &&
-		 * header[1] == 'Z') { return new CBZip2InputStream(ips); }
-		 */
-		if (header[0] == 31 && header[1] == -117) {
-			ips.reset();
-			return new GZIPInputStream(ips, 50000);
-		} else if (header[0] == 0 && header[1] == 0 && header[2] == 0
-				&& header[4] == 10 && header[5] == 9
-				&& (header[3] == 13 || header[3] == 14)) {
-			ips.reset();
-			binary = true;
-			return ips;
-		} else if (header[0] == 'P' && header[1] == 'K') {
-			ips.reset();
-			ZipInputStream zip = new ZipInputStream(ips);
-			zip.getNextEntry();
+        /*
+         * can parse bz2 directly with additional lib if (header[0] == 'B' &&
+         * header[1] == 'Z') { return new CBZip2InputStream(ips); }
+         */
+        if (header[0] == 31 && header[1] == -117) {
+            ips.reset();
+            return new GZIPInputStream(ips, 50000);
+        } else if (header[0] == 0 && header[1] == 0 && header[2] == 0
+                && header[4] == 10 && header[5] == 9
+                && (header[3] == 13 || header[3] == 14)) {
+            ips.reset();
+            binary = true;
+            return ips;
+        } else if (header[0] == 'P' && header[1] == 'K') {
+            ips.reset();
+            ZipInputStream zip = new ZipInputStream(ips);
+            zip.getNextEntry();
 
-			return zip;
-		} else if (name.endsWith(".gml") || name.endsWith(".xml")) {
-			ips.reset();
-			return ips;
-		} else if (header[0] == 60 && header[1] == 63 && header[3] == 120
-				&& header[4] == 109 && header[5] == 108) {
-			ips.reset();
-			return ips;
-		} else if (name.endsWith(".bz2") || name.endsWith(".bzip2")) {
-			String clName = "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream";
-			try {
-				Class clazz = Class.forName(clName);
-				ips.reset();
-				Constructor<InputStream> ctor = clazz.getConstructor(
-						InputStream.class, boolean.class);
-				return ctor.newInstance(ips, true);
-			} catch (Exception e) {
-				throw new IllegalArgumentException("Cannot instantiate "
-						+ clName, e);
-			}
-		} else {
-			throw new IllegalArgumentException(
-					"Input file is not of valid type " + file.getPath());
-		}
-	}
+            return zip;
+        } else if (name.endsWith(".gml") || name.endsWith(".xml")) {
+            ips.reset();
+            return ips;
+        } else if (header[0] == 60 && header[1] == 63 && header[3] == 120
+                && header[4] == 109 && header[5] == 108) {
+            ips.reset();
+            return ips;
+        } else if (name.endsWith(".bz2") || name.endsWith(".bzip2")) {
+            String clName = "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream";
+            try {
+                Class clazz = Class.forName(clName);
+                ips.reset();
+                Constructor<InputStream> ctor = clazz.getConstructor(
+                        InputStream.class, boolean.class);
+                return ctor.newInstance(ips, true);
+            } catch (Exception e) {
+                throw new IllegalArgumentException("Cannot instantiate "
+                        + clName, e);
+            }
+        } else {
+            throw new IllegalArgumentException(
+                    "Input file is not of valid type " + file.getPath());
+        }
+    }
 
-	private void openXMLStream(InputStream in) throws XMLStreamException {
-		XMLInputFactory factory = XMLInputFactory.newInstance();
-		parser = factory.createXMLStreamReader(bis, "UTF-8");
-		int event;
-		do {
-			event = parser.next();
-		} while (event == XMLStreamConstants.COMMENT);
+    private void openXMLStream(InputStream in) throws XMLStreamException {
+        XMLInputFactory factory = XMLInputFactory.newInstance();
+        parser = factory.createXMLStreamReader(bis, "UTF-8");
+        int event;
+        do {
+            event = parser.next();
+        } while (event == XMLStreamConstants.COMMENT);
 
-		if (event != XMLStreamConstants.START_ELEMENT
-				|| !parser.getLocalName().equalsIgnoreCase("FeatureCollection")) {
-			throw new IllegalArgumentException(String.format(
-					"File %s not a valid OS ITN stream", name));
-		}
+        if (event != XMLStreamConstants.START_ELEMENT
+                || !parser.getLocalName().equalsIgnoreCase("FeatureCollection")) {
+            throw new IllegalArgumentException(String.format(
+                    "File %s not a valid OS ITN stream", name));
+        }
 
-		eof = false;
-	}
+        eof = false;
+    }
 
-	public RoutingElement getNext() throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
-		if (eof)
-			throw new IllegalStateException("EOF reached");
+    public RoutingElement getNext() throws XMLStreamException,
+            MismatchedDimensionException, FactoryException, TransformException {
+        if (eof)
+            throw new IllegalStateException("EOF reached");
 
-		RoutingElement item;
-		item = getNextXML();
+        RoutingElement item;
+        item = getNextXML();
 
-		if (item != null)
-			return item;
+        if (item != null)
+            return item;
 
-		eof = true;
-		return null;
-	}
+        eof = true;
+        return null;
+    }
 
-	private OSITNElement getNextXML() throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+    private OSITNElement getNextXML() throws XMLStreamException,
+            MismatchedDimensionException, FactoryException, TransformException {
 
-		int event = parser.next();
-		while (event != XMLStreamConstants.END_DOCUMENT) {
-			if (event == XMLStreamConstants.START_ELEMENT) {
-				String idStr = parser.getAttributeValue(null, "fid");
-				if (null == idStr) {
-					idStr = parser.getAttributeValue(
-							"http://www.opengis.net/gml/3.2", "id");
-				}
-				if (idStr != null) {
-					String name = parser.getLocalName();
-					idStr = idStr.substring(4);
-					logger.info(idStr + ":" + name + ":");
+        int event = parser.next();
+        while (event != XMLStreamConstants.END_DOCUMENT) {
+            if (event == XMLStreamConstants.START_ELEMENT) {
+                String idStr = parser.getAttributeValue(null, "fid");
+                if (null == idStr) {
+                    idStr = parser.getAttributeValue(
+                            "http://www.opengis.net/gml/3.2", "id");
+                }
+                if (idStr != null) {
+                    String name = parser.getLocalName();
+                    idStr = idStr.substring(4);
+                    logger.info(idStr + ":" + name + ":");
 
-					long id;
-					try {
-						id = Long.parseLong(idStr);
-					} catch (NumberFormatException nfe) {
-						BigDecimal bd = new BigDecimal(idStr);
-						id = bd.longValue();
-					}
-					logger.info(id + ":" + name + ":");
-					switch (name) {
-					case "RoadNode":
-					case "RouteNode": {
-						return OSITNNode.create(id, parser);
-					}
-					case "RoadLink": {
-						return OSITNWay.create(id, parser);
-					}
-					case "RouteLink": {
-						return OsDpnWay.create(id, parser);
-					}
-					case "RoadRouteInformation": {
-						return OSITNRelation.create(id, parser);
-					}
+                    long id;
+                    try {
+                        id = Long.parseLong(idStr);
+                    } catch (NumberFormatException nfe) {
+                        BigDecimal bd = new BigDecimal(idStr);
+                        id = bd.longValue();
+                    }
+                    logger.info(id + ":" + name + ":");
+                    switch (name) {
+                        case "RoadNode": {
+                            return OSITNNode.create(id, parser);
+                        }
+                        case "RoadLink": {
+                            return OSITNWay.create(id, parser);
+                        }
 
-					case "Road": {
-						return OsItnMetaData.create(id, parser);
-					}
-					case "RoadLinkInformation": {
-					}
-					case "RoadNodeInformation": {
-					}
-					default: {
+                        case "RoadRouteInformation": {
+                            return OSITNRelation.create(id, parser);
+                        }
 
-					}
+                        case "Road": {
+                            return OsItnMetaData.create(id, parser);
+                        }
+                        case "RoadLinkInformation": {
+                        }
+                        case "RoadNodeInformation": {
+                        }
+                        default: {
 
-					}
-				}
-			}
-			event = parser.next();
-		}
-		parser.close();
-		return null;
-	}
+                        }
 
-	public boolean isEOF() {
-		return eof;
-	}
+                    }
+                }
+            }
+            event = parser.next();
+        }
+        parser.close();
+        return null;
+    }
 
-	@Override
-	public void close() throws IOException {
-		try {
-			if (!binary)
-				parser.close();
-		} catch (XMLStreamException ex) {
-			throw new IOException(ex);
-		} finally {
-			eof = true;
-			bis.close();
-		}
-	}
+    public boolean isEOF() {
+        return eof;
+    }
 
-	@Override
-	public void process(RoutingElement item) {
-		try {
-			// blocks if full
-			itemQueue.put(item);
-		} catch (InterruptedException ex) {
-			throw new RuntimeException(ex);
-		}
+    @Override
+    public void close() throws IOException {
+        try {
+            if (!binary)
+                parser.close();
+        } catch (XMLStreamException ex) {
+            throw new IOException(ex);
+        } finally {
+            eof = true;
+            bis.close();
+        }
+    }
 
-		// throw exception if full
-		// itemQueue.add(item);
-	}
+    @Override
+    public void process(RoutingElement item) {
+        try {
+            // blocks if full
+            itemQueue.put(item);
+        } catch (InterruptedException ex) {
+            throw new RuntimeException(ex);
+        }
 
-	@Override
-	public void complete() {
-		hasIncomingData = false;
-	}
+        // throw exception if full
+        // itemQueue.add(item);
+    }
+
+    @Override
+    public void complete() {
+        hasIncomingData = false;
+    }
 }
