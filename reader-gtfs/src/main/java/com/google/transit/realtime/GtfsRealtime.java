// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: gtfs-realtime.proto
// Protobuf Java Version: 4.28.3

package com.google.transit.realtime;

public final class GtfsRealtime {
  private GtfsRealtime() {}
  static {
    com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
      com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
      /* major= */ 4,
      /* minor= */ 28,
      /* patch= */ 3,
      /* suffix= */ "",
      GtfsRealtime.class.getName());
  }
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface FeedMessageOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_realtime.FeedMessage)
      com.google.protobuf.GeneratedMessage.
          ExtendableMessageOrBuilder<FeedMessage> {

    /**
     * <pre>
     * Metadata about this feed and feed message.
     * </pre>
     *
     * <code>required .transit_realtime.FeedHeader header = 1;</code>
     * @return Whether the header field is set.
     */
    boolean hasHeader();
    /**
     * <pre>
     * Metadata about this feed and feed message.
     * </pre>
     *
     * <code>required .transit_realtime.FeedHeader header = 1;</code>
     * @return The header.
     */
    com.google.transit.realtime.GtfsRealtime.FeedHeader getHeader();
    /**
     * <pre>
     * Metadata about this feed and feed message.
     * </pre>
     *
     * <code>required .transit_realtime.FeedHeader header = 1;</code>
     */
    com.google.transit.realtime.GtfsRealtime.FeedHeaderOrBuilder getHeaderOrBuilder();

    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    java.util.List<com.google.transit.realtime.GtfsRealtime.FeedEntity> 
        getEntityList();
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    com.google.transit.realtime.GtfsRealtime.FeedEntity getEntity(int index);
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    int getEntityCount();
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    java.util.List<? extends com.google.transit.realtime.GtfsRealtime.FeedEntityOrBuilder> 
        getEntityOrBuilderList();
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    com.google.transit.realtime.GtfsRealtime.FeedEntityOrBuilder getEntityOrBuilder(
        int index);
  }
  /**
   * <pre>
   * The contents of a feed message.
   * A feed is a continuous stream of feed messages. Each message in the stream is
   * obtained as a response to an appropriate HTTP GET request.
   * A realtime feed is always defined with relation to an existing GTFS feed.
   * All the entity ids are resolved with respect to the GTFS feed.
   * Note that "required" and "optional" as stated in this file refer to Protocol
   * Buffer cardinality, not semantic cardinality.  See reference.md at
   * https://github.com/google/transit/tree/master/gtfs-realtime for field
   * semantic cardinality.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.FeedMessage}
   */
  public static final class FeedMessage extends
      com.google.protobuf.GeneratedMessage.ExtendableMessage<
        FeedMessage> implements
      // @@protoc_insertion_point(message_implements:transit_realtime.FeedMessage)
      FeedMessageOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 28,
        /* patch= */ 3,
        /* suffix= */ "",
        FeedMessage.class.getName());
    }
    // Use FeedMessage.newBuilder() to construct.
    private FeedMessage(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.FeedMessage, ?> builder) {
      super(builder);
    }
    private FeedMessage() {
      entity_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_FeedMessage_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_FeedMessage_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.transit.realtime.GtfsRealtime.FeedMessage.class, com.google.transit.realtime.GtfsRealtime.FeedMessage.Builder.class);
    }

    private int bitField0_;
    public static final int HEADER_FIELD_NUMBER = 1;
    private com.google.transit.realtime.GtfsRealtime.FeedHeader header_;
    /**
     * <pre>
     * Metadata about this feed and feed message.
     * </pre>
     *
     * <code>required .transit_realtime.FeedHeader header = 1;</code>
     * @return Whether the header field is set.
     */
    @java.lang.Override
    public boolean hasHeader() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Metadata about this feed and feed message.
     * </pre>
     *
     * <code>required .transit_realtime.FeedHeader header = 1;</code>
     * @return The header.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.FeedHeader getHeader() {
      return header_ == null ? com.google.transit.realtime.GtfsRealtime.FeedHeader.getDefaultInstance() : header_;
    }
    /**
     * <pre>
     * Metadata about this feed and feed message.
     * </pre>
     *
     * <code>required .transit_realtime.FeedHeader header = 1;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.FeedHeaderOrBuilder getHeaderOrBuilder() {
      return header_ == null ? com.google.transit.realtime.GtfsRealtime.FeedHeader.getDefaultInstance() : header_;
    }

    public static final int ENTITY_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<com.google.transit.realtime.GtfsRealtime.FeedEntity> entity_;
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.transit.realtime.GtfsRealtime.FeedEntity> getEntityList() {
      return entity_;
    }
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.FeedEntityOrBuilder> 
        getEntityOrBuilderList() {
      return entity_;
    }
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    @java.lang.Override
    public int getEntityCount() {
      return entity_.size();
    }
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.FeedEntity getEntity(int index) {
      return entity_.get(index);
    }
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.FeedEntityOrBuilder getEntityOrBuilder(
        int index) {
      return entity_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasHeader()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!getHeader().isInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      for (int i = 0; i < getEntityCount(); i++) {
        if (!getEntity(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (!extensionsAreInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessage
        .ExtendableMessage.ExtensionSerializer
          extensionWriter = newExtensionSerializer();
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getHeader());
      }
      for (int i = 0; i < entity_.size(); i++) {
        output.writeMessage(2, entity_.get(i));
      }
      extensionWriter.writeUntil(10000, output);
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getHeader());
      }
      for (int i = 0; i < entity_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, entity_.get(i));
      }
      size += extensionsSerializedSize();
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.FeedMessage)) {
        return super.equals(obj);
      }
      com.google.transit.realtime.GtfsRealtime.FeedMessage other = (com.google.transit.realtime.GtfsRealtime.FeedMessage) obj;

      if (hasHeader() != other.hasHeader()) return false;
      if (hasHeader()) {
        if (!getHeader()
            .equals(other.getHeader())) return false;
      }
      if (!getEntityList()
          .equals(other.getEntityList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      if (!getExtensionFields().equals(other.getExtensionFields()))
        return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasHeader()) {
        hash = (37 * hash) + HEADER_FIELD_NUMBER;
        hash = (53 * hash) + getHeader().hashCode();
      }
      if (getEntityCount() > 0) {
        hash = (37 * hash) + ENTITY_FIELD_NUMBER;
        hash = (53 * hash) + getEntityList().hashCode();
      }
      hash = hashFields(hash, getExtensionFields());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.transit.realtime.GtfsRealtime.FeedMessage parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedMessage parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedMessage parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedMessage parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedMessage parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedMessage parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedMessage parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedMessage parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.transit.realtime.GtfsRealtime.FeedMessage parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.transit.realtime.GtfsRealtime.FeedMessage parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedMessage parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedMessage parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.FeedMessage prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The contents of a feed message.
     * A feed is a continuous stream of feed messages. Each message in the stream is
     * obtained as a response to an appropriate HTTP GET request.
     * A realtime feed is always defined with relation to an existing GTFS feed.
     * All the entity ids are resolved with respect to the GTFS feed.
     * Note that "required" and "optional" as stated in this file refer to Protocol
     * Buffer cardinality, not semantic cardinality.  See reference.md at
     * https://github.com/google/transit/tree/master/gtfs-realtime for field
     * semantic cardinality.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.FeedMessage}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
          com.google.transit.realtime.GtfsRealtime.FeedMessage, Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_realtime.FeedMessage)
        com.google.transit.realtime.GtfsRealtime.FeedMessageOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_FeedMessage_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_FeedMessage_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.FeedMessage.class, com.google.transit.realtime.GtfsRealtime.FeedMessage.Builder.class);
      }

      // Construct using com.google.transit.realtime.GtfsRealtime.FeedMessage.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getHeaderFieldBuilder();
          getEntityFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        header_ = null;
        if (headerBuilder_ != null) {
          headerBuilder_.dispose();
          headerBuilder_ = null;
        }
        if (entityBuilder_ == null) {
          entity_ = java.util.Collections.emptyList();
        } else {
          entity_ = null;
          entityBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_FeedMessage_descriptor;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.FeedMessage getDefaultInstanceForType() {
        return com.google.transit.realtime.GtfsRealtime.FeedMessage.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.FeedMessage build() {
        com.google.transit.realtime.GtfsRealtime.FeedMessage result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.FeedMessage buildPartial() {
        com.google.transit.realtime.GtfsRealtime.FeedMessage result = new com.google.transit.realtime.GtfsRealtime.FeedMessage(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(com.google.transit.realtime.GtfsRealtime.FeedMessage result) {
        if (entityBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            entity_ = java.util.Collections.unmodifiableList(entity_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.entity_ = entity_;
        } else {
          result.entity_ = entityBuilder_.build();
        }
      }

      private void buildPartial0(com.google.transit.realtime.GtfsRealtime.FeedMessage result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.header_ = headerBuilder_ == null
              ? header_
              : headerBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.transit.realtime.GtfsRealtime.FeedMessage) {
          return mergeFrom((com.google.transit.realtime.GtfsRealtime.FeedMessage)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.FeedMessage other) {
        if (other == com.google.transit.realtime.GtfsRealtime.FeedMessage.getDefaultInstance()) return this;
        if (other.hasHeader()) {
          mergeHeader(other.getHeader());
        }
        if (entityBuilder_ == null) {
          if (!other.entity_.isEmpty()) {
            if (entity_.isEmpty()) {
              entity_ = other.entity_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureEntityIsMutable();
              entity_.addAll(other.entity_);
            }
            onChanged();
          }
        } else {
          if (!other.entity_.isEmpty()) {
            if (entityBuilder_.isEmpty()) {
              entityBuilder_.dispose();
              entityBuilder_ = null;
              entity_ = other.entity_;
              bitField0_ = (bitField0_ & ~0x00000002);
              entityBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getEntityFieldBuilder() : null;
            } else {
              entityBuilder_.addAllMessages(other.entity_);
            }
          }
        }
        this.mergeExtensionFields(other);
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasHeader()) {
          return false;
        }
        if (!getHeader().isInitialized()) {
          return false;
        }
        for (int i = 0; i < getEntityCount(); i++) {
          if (!getEntity(i).isInitialized()) {
            return false;
          }
        }
        if (!extensionsAreInitialized()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getHeaderFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                com.google.transit.realtime.GtfsRealtime.FeedEntity m =
                    input.readMessage(
                        com.google.transit.realtime.GtfsRealtime.FeedEntity.parser(),
                        extensionRegistry);
                if (entityBuilder_ == null) {
                  ensureEntityIsMutable();
                  entity_.add(m);
                } else {
                  entityBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.transit.realtime.GtfsRealtime.FeedHeader header_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.FeedHeader, com.google.transit.realtime.GtfsRealtime.FeedHeader.Builder, com.google.transit.realtime.GtfsRealtime.FeedHeaderOrBuilder> headerBuilder_;
      /**
       * <pre>
       * Metadata about this feed and feed message.
       * </pre>
       *
       * <code>required .transit_realtime.FeedHeader header = 1;</code>
       * @return Whether the header field is set.
       */
      public boolean hasHeader() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Metadata about this feed and feed message.
       * </pre>
       *
       * <code>required .transit_realtime.FeedHeader header = 1;</code>
       * @return The header.
       */
      public com.google.transit.realtime.GtfsRealtime.FeedHeader getHeader() {
        if (headerBuilder_ == null) {
          return header_ == null ? com.google.transit.realtime.GtfsRealtime.FeedHeader.getDefaultInstance() : header_;
        } else {
          return headerBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Metadata about this feed and feed message.
       * </pre>
       *
       * <code>required .transit_realtime.FeedHeader header = 1;</code>
       */
      public Builder setHeader(com.google.transit.realtime.GtfsRealtime.FeedHeader value) {
        if (headerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          header_ = value;
        } else {
          headerBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Metadata about this feed and feed message.
       * </pre>
       *
       * <code>required .transit_realtime.FeedHeader header = 1;</code>
       */
      public Builder setHeader(
          com.google.transit.realtime.GtfsRealtime.FeedHeader.Builder builderForValue) {
        if (headerBuilder_ == null) {
          header_ = builderForValue.build();
        } else {
          headerBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Metadata about this feed and feed message.
       * </pre>
       *
       * <code>required .transit_realtime.FeedHeader header = 1;</code>
       */
      public Builder mergeHeader(com.google.transit.realtime.GtfsRealtime.FeedHeader value) {
        if (headerBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            header_ != null &&
            header_ != com.google.transit.realtime.GtfsRealtime.FeedHeader.getDefaultInstance()) {
            getHeaderBuilder().mergeFrom(value);
          } else {
            header_ = value;
          }
        } else {
          headerBuilder_.mergeFrom(value);
        }
        if (header_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Metadata about this feed and feed message.
       * </pre>
       *
       * <code>required .transit_realtime.FeedHeader header = 1;</code>
       */
      public Builder clearHeader() {
        bitField0_ = (bitField0_ & ~0x00000001);
        header_ = null;
        if (headerBuilder_ != null) {
          headerBuilder_.dispose();
          headerBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Metadata about this feed and feed message.
       * </pre>
       *
       * <code>required .transit_realtime.FeedHeader header = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.FeedHeader.Builder getHeaderBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getHeaderFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Metadata about this feed and feed message.
       * </pre>
       *
       * <code>required .transit_realtime.FeedHeader header = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.FeedHeaderOrBuilder getHeaderOrBuilder() {
        if (headerBuilder_ != null) {
          return headerBuilder_.getMessageOrBuilder();
        } else {
          return header_ == null ?
              com.google.transit.realtime.GtfsRealtime.FeedHeader.getDefaultInstance() : header_;
        }
      }
      /**
       * <pre>
       * Metadata about this feed and feed message.
       * </pre>
       *
       * <code>required .transit_realtime.FeedHeader header = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.FeedHeader, com.google.transit.realtime.GtfsRealtime.FeedHeader.Builder, com.google.transit.realtime.GtfsRealtime.FeedHeaderOrBuilder> 
          getHeaderFieldBuilder() {
        if (headerBuilder_ == null) {
          headerBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.FeedHeader, com.google.transit.realtime.GtfsRealtime.FeedHeader.Builder, com.google.transit.realtime.GtfsRealtime.FeedHeaderOrBuilder>(
                  getHeader(),
                  getParentForChildren(),
                  isClean());
          header_ = null;
        }
        return headerBuilder_;
      }

      private java.util.List<com.google.transit.realtime.GtfsRealtime.FeedEntity> entity_ =
        java.util.Collections.emptyList();
      private void ensureEntityIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          entity_ = new java.util.ArrayList<com.google.transit.realtime.GtfsRealtime.FeedEntity>(entity_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.FeedEntity, com.google.transit.realtime.GtfsRealtime.FeedEntity.Builder, com.google.transit.realtime.GtfsRealtime.FeedEntityOrBuilder> entityBuilder_;

      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.FeedEntity> getEntityList() {
        if (entityBuilder_ == null) {
          return java.util.Collections.unmodifiableList(entity_);
        } else {
          return entityBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public int getEntityCount() {
        if (entityBuilder_ == null) {
          return entity_.size();
        } else {
          return entityBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.FeedEntity getEntity(int index) {
        if (entityBuilder_ == null) {
          return entity_.get(index);
        } else {
          return entityBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public Builder setEntity(
          int index, com.google.transit.realtime.GtfsRealtime.FeedEntity value) {
        if (entityBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEntityIsMutable();
          entity_.set(index, value);
          onChanged();
        } else {
          entityBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public Builder setEntity(
          int index, com.google.transit.realtime.GtfsRealtime.FeedEntity.Builder builderForValue) {
        if (entityBuilder_ == null) {
          ensureEntityIsMutable();
          entity_.set(index, builderForValue.build());
          onChanged();
        } else {
          entityBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public Builder addEntity(com.google.transit.realtime.GtfsRealtime.FeedEntity value) {
        if (entityBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEntityIsMutable();
          entity_.add(value);
          onChanged();
        } else {
          entityBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public Builder addEntity(
          int index, com.google.transit.realtime.GtfsRealtime.FeedEntity value) {
        if (entityBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEntityIsMutable();
          entity_.add(index, value);
          onChanged();
        } else {
          entityBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public Builder addEntity(
          com.google.transit.realtime.GtfsRealtime.FeedEntity.Builder builderForValue) {
        if (entityBuilder_ == null) {
          ensureEntityIsMutable();
          entity_.add(builderForValue.build());
          onChanged();
        } else {
          entityBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public Builder addEntity(
          int index, com.google.transit.realtime.GtfsRealtime.FeedEntity.Builder builderForValue) {
        if (entityBuilder_ == null) {
          ensureEntityIsMutable();
          entity_.add(index, builderForValue.build());
          onChanged();
        } else {
          entityBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public Builder addAllEntity(
          java.lang.Iterable<? extends com.google.transit.realtime.GtfsRealtime.FeedEntity> values) {
        if (entityBuilder_ == null) {
          ensureEntityIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, entity_);
          onChanged();
        } else {
          entityBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public Builder clearEntity() {
        if (entityBuilder_ == null) {
          entity_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          entityBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public Builder removeEntity(int index) {
        if (entityBuilder_ == null) {
          ensureEntityIsMutable();
          entity_.remove(index);
          onChanged();
        } else {
          entityBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.FeedEntity.Builder getEntityBuilder(
          int index) {
        return getEntityFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.FeedEntityOrBuilder getEntityOrBuilder(
          int index) {
        if (entityBuilder_ == null) {
          return entity_.get(index);  } else {
          return entityBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.FeedEntityOrBuilder> 
           getEntityOrBuilderList() {
        if (entityBuilder_ != null) {
          return entityBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(entity_);
        }
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.FeedEntity.Builder addEntityBuilder() {
        return getEntityFieldBuilder().addBuilder(
            com.google.transit.realtime.GtfsRealtime.FeedEntity.getDefaultInstance());
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.FeedEntity.Builder addEntityBuilder(
          int index) {
        return getEntityFieldBuilder().addBuilder(
            index, com.google.transit.realtime.GtfsRealtime.FeedEntity.getDefaultInstance());
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.FeedEntity.Builder> 
           getEntityBuilderList() {
        return getEntityFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.FeedEntity, com.google.transit.realtime.GtfsRealtime.FeedEntity.Builder, com.google.transit.realtime.GtfsRealtime.FeedEntityOrBuilder> 
          getEntityFieldBuilder() {
        if (entityBuilder_ == null) {
          entityBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.FeedEntity, com.google.transit.realtime.GtfsRealtime.FeedEntity.Builder, com.google.transit.realtime.GtfsRealtime.FeedEntityOrBuilder>(
                  entity_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          entity_ = null;
        }
        return entityBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.FeedMessage)
    }

    // @@protoc_insertion_point(class_scope:transit_realtime.FeedMessage)
    private static final com.google.transit.realtime.GtfsRealtime.FeedMessage DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.FeedMessage();
    }

    public static com.google.transit.realtime.GtfsRealtime.FeedMessage getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<FeedMessage>
        PARSER = new com.google.protobuf.AbstractParser<FeedMessage>() {
      @java.lang.Override
      public FeedMessage parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<FeedMessage> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<FeedMessage> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.FeedMessage getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface FeedHeaderOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_realtime.FeedHeader)
      com.google.protobuf.GeneratedMessage.
          ExtendableMessageOrBuilder<FeedHeader> {

    /**
     * <pre>
     * Version of the feed specification.
     * The current version is 2.0.  Valid versions are "2.0", "1.0".
     * </pre>
     *
     * <code>required string gtfs_realtime_version = 1;</code>
     * @return Whether the gtfsRealtimeVersion field is set.
     */
    boolean hasGtfsRealtimeVersion();
    /**
     * <pre>
     * Version of the feed specification.
     * The current version is 2.0.  Valid versions are "2.0", "1.0".
     * </pre>
     *
     * <code>required string gtfs_realtime_version = 1;</code>
     * @return The gtfsRealtimeVersion.
     */
    java.lang.String getGtfsRealtimeVersion();
    /**
     * <pre>
     * Version of the feed specification.
     * The current version is 2.0.  Valid versions are "2.0", "1.0".
     * </pre>
     *
     * <code>required string gtfs_realtime_version = 1;</code>
     * @return The bytes for gtfsRealtimeVersion.
     */
    com.google.protobuf.ByteString
        getGtfsRealtimeVersionBytes();

    /**
     * <code>optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];</code>
     * @return Whether the incrementality field is set.
     */
    boolean hasIncrementality();
    /**
     * <code>optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];</code>
     * @return The incrementality.
     */
    com.google.transit.realtime.GtfsRealtime.FeedHeader.Incrementality getIncrementality();

    /**
     * <pre>
     * This timestamp identifies the moment when the content of this feed has been
     * created (in server time). In POSIX time (i.e., number of seconds since
     * January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 3;</code>
     * @return Whether the timestamp field is set.
     */
    boolean hasTimestamp();
    /**
     * <pre>
     * This timestamp identifies the moment when the content of this feed has been
     * created (in server time). In POSIX time (i.e., number of seconds since
     * January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 3;</code>
     * @return The timestamp.
     */
    long getTimestamp();

    /**
     * <pre>
     * String that matches the feed_info.feed_version from the GTFS feed that the real
     * time data is based on. Consumers can use this to identify which GTFS feed is
     * currently active or when a new one is available to download.
     * </pre>
     *
     * <code>optional string feed_version = 4;</code>
     * @return Whether the feedVersion field is set.
     */
    boolean hasFeedVersion();
    /**
     * <pre>
     * String that matches the feed_info.feed_version from the GTFS feed that the real
     * time data is based on. Consumers can use this to identify which GTFS feed is
     * currently active or when a new one is available to download.
     * </pre>
     *
     * <code>optional string feed_version = 4;</code>
     * @return The feedVersion.
     */
    java.lang.String getFeedVersion();
    /**
     * <pre>
     * String that matches the feed_info.feed_version from the GTFS feed that the real
     * time data is based on. Consumers can use this to identify which GTFS feed is
     * currently active or when a new one is available to download.
     * </pre>
     *
     * <code>optional string feed_version = 4;</code>
     * @return The bytes for feedVersion.
     */
    com.google.protobuf.ByteString
        getFeedVersionBytes();
  }
  /**
   * <pre>
   * Metadata about a feed, included in feed messages.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.FeedHeader}
   */
  public static final class FeedHeader extends
      com.google.protobuf.GeneratedMessage.ExtendableMessage<
        FeedHeader> implements
      // @@protoc_insertion_point(message_implements:transit_realtime.FeedHeader)
      FeedHeaderOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 28,
        /* patch= */ 3,
        /* suffix= */ "",
        FeedHeader.class.getName());
    }
    // Use FeedHeader.newBuilder() to construct.
    private FeedHeader(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.FeedHeader, ?> builder) {
      super(builder);
    }
    private FeedHeader() {
      gtfsRealtimeVersion_ = "";
      incrementality_ = 0;
      feedVersion_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_FeedHeader_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_FeedHeader_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.transit.realtime.GtfsRealtime.FeedHeader.class, com.google.transit.realtime.GtfsRealtime.FeedHeader.Builder.class);
    }

    /**
     * <pre>
     * Determines whether the current fetch is incremental.  Currently,
     * DIFFERENTIAL mode is unsupported and behavior is unspecified for feeds
     * that use this mode.  There are discussions on the GTFS Realtime mailing
     * list around fully specifying the behavior of DIFFERENTIAL mode and the
     * documentation will be updated when those discussions are finalized.
     * </pre>
     *
     * Protobuf enum {@code transit_realtime.FeedHeader.Incrementality}
     */
    public enum Incrementality
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>FULL_DATASET = 0;</code>
       */
      FULL_DATASET(0),
      /**
       * <code>DIFFERENTIAL = 1;</code>
       */
      DIFFERENTIAL(1),
      ;

      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 28,
          /* patch= */ 3,
          /* suffix= */ "",
          Incrementality.class.getName());
      }
      /**
       * <code>FULL_DATASET = 0;</code>
       */
      public static final int FULL_DATASET_VALUE = 0;
      /**
       * <code>DIFFERENTIAL = 1;</code>
       */
      public static final int DIFFERENTIAL_VALUE = 1;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Incrementality valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static Incrementality forNumber(int value) {
        switch (value) {
          case 0: return FULL_DATASET;
          case 1: return DIFFERENTIAL;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Incrementality>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Incrementality> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Incrementality>() {
              public Incrementality findValueByNumber(int number) {
                return Incrementality.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.FeedHeader.getDescriptor().getEnumTypes().get(0);
      }

      private static final Incrementality[] VALUES = values();

      public static Incrementality valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private Incrementality(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_realtime.FeedHeader.Incrementality)
    }

    private int bitField0_;
    public static final int GTFS_REALTIME_VERSION_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object gtfsRealtimeVersion_ = "";
    /**
     * <pre>
     * Version of the feed specification.
     * The current version is 2.0.  Valid versions are "2.0", "1.0".
     * </pre>
     *
     * <code>required string gtfs_realtime_version = 1;</code>
     * @return Whether the gtfsRealtimeVersion field is set.
     */
    @java.lang.Override
    public boolean hasGtfsRealtimeVersion() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Version of the feed specification.
     * The current version is 2.0.  Valid versions are "2.0", "1.0".
     * </pre>
     *
     * <code>required string gtfs_realtime_version = 1;</code>
     * @return The gtfsRealtimeVersion.
     */
    @java.lang.Override
    public java.lang.String getGtfsRealtimeVersion() {
      java.lang.Object ref = gtfsRealtimeVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          gtfsRealtimeVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Version of the feed specification.
     * The current version is 2.0.  Valid versions are "2.0", "1.0".
     * </pre>
     *
     * <code>required string gtfs_realtime_version = 1;</code>
     * @return The bytes for gtfsRealtimeVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getGtfsRealtimeVersionBytes() {
      java.lang.Object ref = gtfsRealtimeVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        gtfsRealtimeVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int INCREMENTALITY_FIELD_NUMBER = 2;
    private int incrementality_ = 0;
    /**
     * <code>optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];</code>
     * @return Whether the incrementality field is set.
     */
    @java.lang.Override public boolean hasIncrementality() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];</code>
     * @return The incrementality.
     */
    @java.lang.Override public com.google.transit.realtime.GtfsRealtime.FeedHeader.Incrementality getIncrementality() {
      com.google.transit.realtime.GtfsRealtime.FeedHeader.Incrementality result = com.google.transit.realtime.GtfsRealtime.FeedHeader.Incrementality.forNumber(incrementality_);
      return result == null ? com.google.transit.realtime.GtfsRealtime.FeedHeader.Incrementality.FULL_DATASET : result;
    }

    public static final int TIMESTAMP_FIELD_NUMBER = 3;
    private long timestamp_ = 0L;
    /**
     * <pre>
     * This timestamp identifies the moment when the content of this feed has been
     * created (in server time). In POSIX time (i.e., number of seconds since
     * January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 3;</code>
     * @return Whether the timestamp field is set.
     */
    @java.lang.Override
    public boolean hasTimestamp() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * This timestamp identifies the moment when the content of this feed has been
     * created (in server time). In POSIX time (i.e., number of seconds since
     * January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 3;</code>
     * @return The timestamp.
     */
    @java.lang.Override
    public long getTimestamp() {
      return timestamp_;
    }

    public static final int FEED_VERSION_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object feedVersion_ = "";
    /**
     * <pre>
     * String that matches the feed_info.feed_version from the GTFS feed that the real
     * time data is based on. Consumers can use this to identify which GTFS feed is
     * currently active or when a new one is available to download.
     * </pre>
     *
     * <code>optional string feed_version = 4;</code>
     * @return Whether the feedVersion field is set.
     */
    @java.lang.Override
    public boolean hasFeedVersion() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * String that matches the feed_info.feed_version from the GTFS feed that the real
     * time data is based on. Consumers can use this to identify which GTFS feed is
     * currently active or when a new one is available to download.
     * </pre>
     *
     * <code>optional string feed_version = 4;</code>
     * @return The feedVersion.
     */
    @java.lang.Override
    public java.lang.String getFeedVersion() {
      java.lang.Object ref = feedVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          feedVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * String that matches the feed_info.feed_version from the GTFS feed that the real
     * time data is based on. Consumers can use this to identify which GTFS feed is
     * currently active or when a new one is available to download.
     * </pre>
     *
     * <code>optional string feed_version = 4;</code>
     * @return The bytes for feedVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFeedVersionBytes() {
      java.lang.Object ref = feedVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        feedVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasGtfsRealtimeVersion()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!extensionsAreInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessage
        .ExtendableMessage.ExtensionSerializer
          extensionWriter = newExtensionSerializer();
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, gtfsRealtimeVersion_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeEnum(2, incrementality_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeUInt64(3, timestamp_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, feedVersion_);
      }
      extensionWriter.writeUntil(10000, output);
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, gtfsRealtimeVersion_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(2, incrementality_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(3, timestamp_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, feedVersion_);
      }
      size += extensionsSerializedSize();
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.FeedHeader)) {
        return super.equals(obj);
      }
      com.google.transit.realtime.GtfsRealtime.FeedHeader other = (com.google.transit.realtime.GtfsRealtime.FeedHeader) obj;

      if (hasGtfsRealtimeVersion() != other.hasGtfsRealtimeVersion()) return false;
      if (hasGtfsRealtimeVersion()) {
        if (!getGtfsRealtimeVersion()
            .equals(other.getGtfsRealtimeVersion())) return false;
      }
      if (hasIncrementality() != other.hasIncrementality()) return false;
      if (hasIncrementality()) {
        if (incrementality_ != other.incrementality_) return false;
      }
      if (hasTimestamp() != other.hasTimestamp()) return false;
      if (hasTimestamp()) {
        if (getTimestamp()
            != other.getTimestamp()) return false;
      }
      if (hasFeedVersion() != other.hasFeedVersion()) return false;
      if (hasFeedVersion()) {
        if (!getFeedVersion()
            .equals(other.getFeedVersion())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      if (!getExtensionFields().equals(other.getExtensionFields()))
        return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasGtfsRealtimeVersion()) {
        hash = (37 * hash) + GTFS_REALTIME_VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getGtfsRealtimeVersion().hashCode();
      }
      if (hasIncrementality()) {
        hash = (37 * hash) + INCREMENTALITY_FIELD_NUMBER;
        hash = (53 * hash) + incrementality_;
      }
      if (hasTimestamp()) {
        hash = (37 * hash) + TIMESTAMP_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getTimestamp());
      }
      if (hasFeedVersion()) {
        hash = (37 * hash) + FEED_VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getFeedVersion().hashCode();
      }
      hash = hashFields(hash, getExtensionFields());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.transit.realtime.GtfsRealtime.FeedHeader parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedHeader parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedHeader parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedHeader parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedHeader parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedHeader parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedHeader parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedHeader parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.transit.realtime.GtfsRealtime.FeedHeader parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.transit.realtime.GtfsRealtime.FeedHeader parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedHeader parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedHeader parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.FeedHeader prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Metadata about a feed, included in feed messages.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.FeedHeader}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
          com.google.transit.realtime.GtfsRealtime.FeedHeader, Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_realtime.FeedHeader)
        com.google.transit.realtime.GtfsRealtime.FeedHeaderOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_FeedHeader_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_FeedHeader_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.FeedHeader.class, com.google.transit.realtime.GtfsRealtime.FeedHeader.Builder.class);
      }

      // Construct using com.google.transit.realtime.GtfsRealtime.FeedHeader.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        gtfsRealtimeVersion_ = "";
        incrementality_ = 0;
        timestamp_ = 0L;
        feedVersion_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_FeedHeader_descriptor;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.FeedHeader getDefaultInstanceForType() {
        return com.google.transit.realtime.GtfsRealtime.FeedHeader.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.FeedHeader build() {
        com.google.transit.realtime.GtfsRealtime.FeedHeader result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.FeedHeader buildPartial() {
        com.google.transit.realtime.GtfsRealtime.FeedHeader result = new com.google.transit.realtime.GtfsRealtime.FeedHeader(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.transit.realtime.GtfsRealtime.FeedHeader result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.gtfsRealtimeVersion_ = gtfsRealtimeVersion_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.incrementality_ = incrementality_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.timestamp_ = timestamp_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.feedVersion_ = feedVersion_;
          to_bitField0_ |= 0x00000008;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.transit.realtime.GtfsRealtime.FeedHeader) {
          return mergeFrom((com.google.transit.realtime.GtfsRealtime.FeedHeader)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.FeedHeader other) {
        if (other == com.google.transit.realtime.GtfsRealtime.FeedHeader.getDefaultInstance()) return this;
        if (other.hasGtfsRealtimeVersion()) {
          gtfsRealtimeVersion_ = other.gtfsRealtimeVersion_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasIncrementality()) {
          setIncrementality(other.getIncrementality());
        }
        if (other.hasTimestamp()) {
          setTimestamp(other.getTimestamp());
        }
        if (other.hasFeedVersion()) {
          feedVersion_ = other.feedVersion_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        this.mergeExtensionFields(other);
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasGtfsRealtimeVersion()) {
          return false;
        }
        if (!extensionsAreInitialized()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                gtfsRealtimeVersion_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 16: {
                int tmpRaw = input.readEnum();
                com.google.transit.realtime.GtfsRealtime.FeedHeader.Incrementality tmpValue =
                    com.google.transit.realtime.GtfsRealtime.FeedHeader.Incrementality.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(2, tmpRaw);
                } else {
                  incrementality_ = tmpRaw;
                  bitField0_ |= 0x00000002;
                }
                break;
              } // case 16
              case 24: {
                timestamp_ = input.readUInt64();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 34: {
                feedVersion_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object gtfsRealtimeVersion_ = "";
      /**
       * <pre>
       * Version of the feed specification.
       * The current version is 2.0.  Valid versions are "2.0", "1.0".
       * </pre>
       *
       * <code>required string gtfs_realtime_version = 1;</code>
       * @return Whether the gtfsRealtimeVersion field is set.
       */
      public boolean hasGtfsRealtimeVersion() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Version of the feed specification.
       * The current version is 2.0.  Valid versions are "2.0", "1.0".
       * </pre>
       *
       * <code>required string gtfs_realtime_version = 1;</code>
       * @return The gtfsRealtimeVersion.
       */
      public java.lang.String getGtfsRealtimeVersion() {
        java.lang.Object ref = gtfsRealtimeVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            gtfsRealtimeVersion_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Version of the feed specification.
       * The current version is 2.0.  Valid versions are "2.0", "1.0".
       * </pre>
       *
       * <code>required string gtfs_realtime_version = 1;</code>
       * @return The bytes for gtfsRealtimeVersion.
       */
      public com.google.protobuf.ByteString
          getGtfsRealtimeVersionBytes() {
        java.lang.Object ref = gtfsRealtimeVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          gtfsRealtimeVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Version of the feed specification.
       * The current version is 2.0.  Valid versions are "2.0", "1.0".
       * </pre>
       *
       * <code>required string gtfs_realtime_version = 1;</code>
       * @param value The gtfsRealtimeVersion to set.
       * @return This builder for chaining.
       */
      public Builder setGtfsRealtimeVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        gtfsRealtimeVersion_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Version of the feed specification.
       * The current version is 2.0.  Valid versions are "2.0", "1.0".
       * </pre>
       *
       * <code>required string gtfs_realtime_version = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearGtfsRealtimeVersion() {
        gtfsRealtimeVersion_ = getDefaultInstance().getGtfsRealtimeVersion();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Version of the feed specification.
       * The current version is 2.0.  Valid versions are "2.0", "1.0".
       * </pre>
       *
       * <code>required string gtfs_realtime_version = 1;</code>
       * @param value The bytes for gtfsRealtimeVersion to set.
       * @return This builder for chaining.
       */
      public Builder setGtfsRealtimeVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        gtfsRealtimeVersion_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private int incrementality_ = 0;
      /**
       * <code>optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];</code>
       * @return Whether the incrementality field is set.
       */
      @java.lang.Override public boolean hasIncrementality() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];</code>
       * @return The incrementality.
       */
      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.FeedHeader.Incrementality getIncrementality() {
        com.google.transit.realtime.GtfsRealtime.FeedHeader.Incrementality result = com.google.transit.realtime.GtfsRealtime.FeedHeader.Incrementality.forNumber(incrementality_);
        return result == null ? com.google.transit.realtime.GtfsRealtime.FeedHeader.Incrementality.FULL_DATASET : result;
      }
      /**
       * <code>optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];</code>
       * @param value The incrementality to set.
       * @return This builder for chaining.
       */
      public Builder setIncrementality(com.google.transit.realtime.GtfsRealtime.FeedHeader.Incrementality value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        incrementality_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];</code>
       * @return This builder for chaining.
       */
      public Builder clearIncrementality() {
        bitField0_ = (bitField0_ & ~0x00000002);
        incrementality_ = 0;
        onChanged();
        return this;
      }

      private long timestamp_ ;
      /**
       * <pre>
       * This timestamp identifies the moment when the content of this feed has been
       * created (in server time). In POSIX time (i.e., number of seconds since
       * January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 3;</code>
       * @return Whether the timestamp field is set.
       */
      @java.lang.Override
      public boolean hasTimestamp() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * This timestamp identifies the moment when the content of this feed has been
       * created (in server time). In POSIX time (i.e., number of seconds since
       * January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 3;</code>
       * @return The timestamp.
       */
      @java.lang.Override
      public long getTimestamp() {
        return timestamp_;
      }
      /**
       * <pre>
       * This timestamp identifies the moment when the content of this feed has been
       * created (in server time). In POSIX time (i.e., number of seconds since
       * January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 3;</code>
       * @param value The timestamp to set.
       * @return This builder for chaining.
       */
      public Builder setTimestamp(long value) {

        timestamp_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This timestamp identifies the moment when the content of this feed has been
       * created (in server time). In POSIX time (i.e., number of seconds since
       * January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearTimestamp() {
        bitField0_ = (bitField0_ & ~0x00000004);
        timestamp_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object feedVersion_ = "";
      /**
       * <pre>
       * String that matches the feed_info.feed_version from the GTFS feed that the real
       * time data is based on. Consumers can use this to identify which GTFS feed is
       * currently active or when a new one is available to download.
       * </pre>
       *
       * <code>optional string feed_version = 4;</code>
       * @return Whether the feedVersion field is set.
       */
      public boolean hasFeedVersion() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * String that matches the feed_info.feed_version from the GTFS feed that the real
       * time data is based on. Consumers can use this to identify which GTFS feed is
       * currently active or when a new one is available to download.
       * </pre>
       *
       * <code>optional string feed_version = 4;</code>
       * @return The feedVersion.
       */
      public java.lang.String getFeedVersion() {
        java.lang.Object ref = feedVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            feedVersion_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * String that matches the feed_info.feed_version from the GTFS feed that the real
       * time data is based on. Consumers can use this to identify which GTFS feed is
       * currently active or when a new one is available to download.
       * </pre>
       *
       * <code>optional string feed_version = 4;</code>
       * @return The bytes for feedVersion.
       */
      public com.google.protobuf.ByteString
          getFeedVersionBytes() {
        java.lang.Object ref = feedVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          feedVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * String that matches the feed_info.feed_version from the GTFS feed that the real
       * time data is based on. Consumers can use this to identify which GTFS feed is
       * currently active or when a new one is available to download.
       * </pre>
       *
       * <code>optional string feed_version = 4;</code>
       * @param value The feedVersion to set.
       * @return This builder for chaining.
       */
      public Builder setFeedVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        feedVersion_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * String that matches the feed_info.feed_version from the GTFS feed that the real
       * time data is based on. Consumers can use this to identify which GTFS feed is
       * currently active or when a new one is available to download.
       * </pre>
       *
       * <code>optional string feed_version = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearFeedVersion() {
        feedVersion_ = getDefaultInstance().getFeedVersion();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * String that matches the feed_info.feed_version from the GTFS feed that the real
       * time data is based on. Consumers can use this to identify which GTFS feed is
       * currently active or when a new one is available to download.
       * </pre>
       *
       * <code>optional string feed_version = 4;</code>
       * @param value The bytes for feedVersion to set.
       * @return This builder for chaining.
       */
      public Builder setFeedVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        feedVersion_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.FeedHeader)
    }

    // @@protoc_insertion_point(class_scope:transit_realtime.FeedHeader)
    private static final com.google.transit.realtime.GtfsRealtime.FeedHeader DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.FeedHeader();
    }

    public static com.google.transit.realtime.GtfsRealtime.FeedHeader getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<FeedHeader>
        PARSER = new com.google.protobuf.AbstractParser<FeedHeader>() {
      @java.lang.Override
      public FeedHeader parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<FeedHeader> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<FeedHeader> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.FeedHeader getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface FeedEntityOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_realtime.FeedEntity)
      com.google.protobuf.GeneratedMessage.
          ExtendableMessageOrBuilder<FeedEntity> {

    /**
     * <pre>
     * The ids are used only to provide incrementality support. The id should be
     * unique within a FeedMessage. Consequent FeedMessages may contain
     * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
     * FeedEntity with some id will replace the old FeedEntity with the same id
     * (or delete it - see is_deleted below).
     * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
     * feed must be specified by explicit selectors (see EntitySelector below for
     * more info).
     * </pre>
     *
     * <code>required string id = 1;</code>
     * @return Whether the id field is set.
     */
    boolean hasId();
    /**
     * <pre>
     * The ids are used only to provide incrementality support. The id should be
     * unique within a FeedMessage. Consequent FeedMessages may contain
     * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
     * FeedEntity with some id will replace the old FeedEntity with the same id
     * (or delete it - see is_deleted below).
     * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
     * feed must be specified by explicit selectors (see EntitySelector below for
     * more info).
     * </pre>
     *
     * <code>required string id = 1;</code>
     * @return The id.
     */
    java.lang.String getId();
    /**
     * <pre>
     * The ids are used only to provide incrementality support. The id should be
     * unique within a FeedMessage. Consequent FeedMessages may contain
     * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
     * FeedEntity with some id will replace the old FeedEntity with the same id
     * (or delete it - see is_deleted below).
     * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
     * feed must be specified by explicit selectors (see EntitySelector below for
     * more info).
     * </pre>
     *
     * <code>required string id = 1;</code>
     * @return The bytes for id.
     */
    com.google.protobuf.ByteString
        getIdBytes();

    /**
     * <pre>
     * Whether this entity is to be deleted. Relevant only for incremental
     * fetches.
     * </pre>
     *
     * <code>optional bool is_deleted = 2 [default = false];</code>
     * @return Whether the isDeleted field is set.
     */
    boolean hasIsDeleted();
    /**
     * <pre>
     * Whether this entity is to be deleted. Relevant only for incremental
     * fetches.
     * </pre>
     *
     * <code>optional bool is_deleted = 2 [default = false];</code>
     * @return The isDeleted.
     */
    boolean getIsDeleted();

    /**
     * <pre>
     * Data about the entity itself. Exactly one of the following fields must be
     * present (unless the entity is being deleted).
     * </pre>
     *
     * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
     * @return Whether the tripUpdate field is set.
     */
    boolean hasTripUpdate();
    /**
     * <pre>
     * Data about the entity itself. Exactly one of the following fields must be
     * present (unless the entity is being deleted).
     * </pre>
     *
     * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
     * @return The tripUpdate.
     */
    com.google.transit.realtime.GtfsRealtime.TripUpdate getTripUpdate();
    /**
     * <pre>
     * Data about the entity itself. Exactly one of the following fields must be
     * present (unless the entity is being deleted).
     * </pre>
     *
     * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TripUpdateOrBuilder getTripUpdateOrBuilder();

    /**
     * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
     * @return Whether the vehicle field is set.
     */
    boolean hasVehicle();
    /**
     * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
     * @return The vehicle.
     */
    com.google.transit.realtime.GtfsRealtime.VehiclePosition getVehicle();
    /**
     * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
     */
    com.google.transit.realtime.GtfsRealtime.VehiclePositionOrBuilder getVehicleOrBuilder();

    /**
     * <code>optional .transit_realtime.Alert alert = 5;</code>
     * @return Whether the alert field is set.
     */
    boolean hasAlert();
    /**
     * <code>optional .transit_realtime.Alert alert = 5;</code>
     * @return The alert.
     */
    com.google.transit.realtime.GtfsRealtime.Alert getAlert();
    /**
     * <code>optional .transit_realtime.Alert alert = 5;</code>
     */
    com.google.transit.realtime.GtfsRealtime.AlertOrBuilder getAlertOrBuilder();

    /**
     * <pre>
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.Shape shape = 6;</code>
     * @return Whether the shape field is set.
     */
    boolean hasShape();
    /**
     * <pre>
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.Shape shape = 6;</code>
     * @return The shape.
     */
    com.google.transit.realtime.GtfsRealtime.Shape getShape();
    /**
     * <pre>
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.Shape shape = 6;</code>
     */
    com.google.transit.realtime.GtfsRealtime.ShapeOrBuilder getShapeOrBuilder();

    /**
     * <code>optional .transit_realtime.Stop stop = 7;</code>
     * @return Whether the stop field is set.
     */
    boolean hasStop();
    /**
     * <code>optional .transit_realtime.Stop stop = 7;</code>
     * @return The stop.
     */
    com.google.transit.realtime.GtfsRealtime.Stop getStop();
    /**
     * <code>optional .transit_realtime.Stop stop = 7;</code>
     */
    com.google.transit.realtime.GtfsRealtime.StopOrBuilder getStopOrBuilder();

    /**
     * <code>optional .transit_realtime.TripModifications trip_modifications = 8;</code>
     * @return Whether the tripModifications field is set.
     */
    boolean hasTripModifications();
    /**
     * <code>optional .transit_realtime.TripModifications trip_modifications = 8;</code>
     * @return The tripModifications.
     */
    com.google.transit.realtime.GtfsRealtime.TripModifications getTripModifications();
    /**
     * <code>optional .transit_realtime.TripModifications trip_modifications = 8;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TripModificationsOrBuilder getTripModificationsOrBuilder();
  }
  /**
   * <pre>
   * A definition (or update) of an entity in the transit feed.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.FeedEntity}
   */
  public static final class FeedEntity extends
      com.google.protobuf.GeneratedMessage.ExtendableMessage<
        FeedEntity> implements
      // @@protoc_insertion_point(message_implements:transit_realtime.FeedEntity)
      FeedEntityOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 28,
        /* patch= */ 3,
        /* suffix= */ "",
        FeedEntity.class.getName());
    }
    // Use FeedEntity.newBuilder() to construct.
    private FeedEntity(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.FeedEntity, ?> builder) {
      super(builder);
    }
    private FeedEntity() {
      id_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_FeedEntity_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_FeedEntity_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.transit.realtime.GtfsRealtime.FeedEntity.class, com.google.transit.realtime.GtfsRealtime.FeedEntity.Builder.class);
    }

    private int bitField0_;
    public static final int ID_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object id_ = "";
    /**
     * <pre>
     * The ids are used only to provide incrementality support. The id should be
     * unique within a FeedMessage. Consequent FeedMessages may contain
     * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
     * FeedEntity with some id will replace the old FeedEntity with the same id
     * (or delete it - see is_deleted below).
     * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
     * feed must be specified by explicit selectors (see EntitySelector below for
     * more info).
     * </pre>
     *
     * <code>required string id = 1;</code>
     * @return Whether the id field is set.
     */
    @java.lang.Override
    public boolean hasId() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The ids are used only to provide incrementality support. The id should be
     * unique within a FeedMessage. Consequent FeedMessages may contain
     * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
     * FeedEntity with some id will replace the old FeedEntity with the same id
     * (or delete it - see is_deleted below).
     * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
     * feed must be specified by explicit selectors (see EntitySelector below for
     * more info).
     * </pre>
     *
     * <code>required string id = 1;</code>
     * @return The id.
     */
    @java.lang.Override
    public java.lang.String getId() {
      java.lang.Object ref = id_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          id_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The ids are used only to provide incrementality support. The id should be
     * unique within a FeedMessage. Consequent FeedMessages may contain
     * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
     * FeedEntity with some id will replace the old FeedEntity with the same id
     * (or delete it - see is_deleted below).
     * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
     * feed must be specified by explicit selectors (see EntitySelector below for
     * more info).
     * </pre>
     *
     * <code>required string id = 1;</code>
     * @return The bytes for id.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getIdBytes() {
      java.lang.Object ref = id_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        id_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int IS_DELETED_FIELD_NUMBER = 2;
    private boolean isDeleted_ = false;
    /**
     * <pre>
     * Whether this entity is to be deleted. Relevant only for incremental
     * fetches.
     * </pre>
     *
     * <code>optional bool is_deleted = 2 [default = false];</code>
     * @return Whether the isDeleted field is set.
     */
    @java.lang.Override
    public boolean hasIsDeleted() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Whether this entity is to be deleted. Relevant only for incremental
     * fetches.
     * </pre>
     *
     * <code>optional bool is_deleted = 2 [default = false];</code>
     * @return The isDeleted.
     */
    @java.lang.Override
    public boolean getIsDeleted() {
      return isDeleted_;
    }

    public static final int TRIP_UPDATE_FIELD_NUMBER = 3;
    private com.google.transit.realtime.GtfsRealtime.TripUpdate tripUpdate_;
    /**
     * <pre>
     * Data about the entity itself. Exactly one of the following fields must be
     * present (unless the entity is being deleted).
     * </pre>
     *
     * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
     * @return Whether the tripUpdate field is set.
     */
    @java.lang.Override
    public boolean hasTripUpdate() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Data about the entity itself. Exactly one of the following fields must be
     * present (unless the entity is being deleted).
     * </pre>
     *
     * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
     * @return The tripUpdate.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripUpdate getTripUpdate() {
      return tripUpdate_ == null ? com.google.transit.realtime.GtfsRealtime.TripUpdate.getDefaultInstance() : tripUpdate_;
    }
    /**
     * <pre>
     * Data about the entity itself. Exactly one of the following fields must be
     * present (unless the entity is being deleted).
     * </pre>
     *
     * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripUpdateOrBuilder getTripUpdateOrBuilder() {
      return tripUpdate_ == null ? com.google.transit.realtime.GtfsRealtime.TripUpdate.getDefaultInstance() : tripUpdate_;
    }

    public static final int VEHICLE_FIELD_NUMBER = 4;
    private com.google.transit.realtime.GtfsRealtime.VehiclePosition vehicle_;
    /**
     * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
     * @return Whether the vehicle field is set.
     */
    @java.lang.Override
    public boolean hasVehicle() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
     * @return The vehicle.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.VehiclePosition getVehicle() {
      return vehicle_ == null ? com.google.transit.realtime.GtfsRealtime.VehiclePosition.getDefaultInstance() : vehicle_;
    }
    /**
     * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.VehiclePositionOrBuilder getVehicleOrBuilder() {
      return vehicle_ == null ? com.google.transit.realtime.GtfsRealtime.VehiclePosition.getDefaultInstance() : vehicle_;
    }

    public static final int ALERT_FIELD_NUMBER = 5;
    private com.google.transit.realtime.GtfsRealtime.Alert alert_;
    /**
     * <code>optional .transit_realtime.Alert alert = 5;</code>
     * @return Whether the alert field is set.
     */
    @java.lang.Override
    public boolean hasAlert() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <code>optional .transit_realtime.Alert alert = 5;</code>
     * @return The alert.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.Alert getAlert() {
      return alert_ == null ? com.google.transit.realtime.GtfsRealtime.Alert.getDefaultInstance() : alert_;
    }
    /**
     * <code>optional .transit_realtime.Alert alert = 5;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.AlertOrBuilder getAlertOrBuilder() {
      return alert_ == null ? com.google.transit.realtime.GtfsRealtime.Alert.getDefaultInstance() : alert_;
    }

    public static final int SHAPE_FIELD_NUMBER = 6;
    private com.google.transit.realtime.GtfsRealtime.Shape shape_;
    /**
     * <pre>
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.Shape shape = 6;</code>
     * @return Whether the shape field is set.
     */
    @java.lang.Override
    public boolean hasShape() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.Shape shape = 6;</code>
     * @return The shape.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.Shape getShape() {
      return shape_ == null ? com.google.transit.realtime.GtfsRealtime.Shape.getDefaultInstance() : shape_;
    }
    /**
     * <pre>
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.Shape shape = 6;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.ShapeOrBuilder getShapeOrBuilder() {
      return shape_ == null ? com.google.transit.realtime.GtfsRealtime.Shape.getDefaultInstance() : shape_;
    }

    public static final int STOP_FIELD_NUMBER = 7;
    private com.google.transit.realtime.GtfsRealtime.Stop stop_;
    /**
     * <code>optional .transit_realtime.Stop stop = 7;</code>
     * @return Whether the stop field is set.
     */
    @java.lang.Override
    public boolean hasStop() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <code>optional .transit_realtime.Stop stop = 7;</code>
     * @return The stop.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.Stop getStop() {
      return stop_ == null ? com.google.transit.realtime.GtfsRealtime.Stop.getDefaultInstance() : stop_;
    }
    /**
     * <code>optional .transit_realtime.Stop stop = 7;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.StopOrBuilder getStopOrBuilder() {
      return stop_ == null ? com.google.transit.realtime.GtfsRealtime.Stop.getDefaultInstance() : stop_;
    }

    public static final int TRIP_MODIFICATIONS_FIELD_NUMBER = 8;
    private com.google.transit.realtime.GtfsRealtime.TripModifications tripModifications_;
    /**
     * <code>optional .transit_realtime.TripModifications trip_modifications = 8;</code>
     * @return Whether the tripModifications field is set.
     */
    @java.lang.Override
    public boolean hasTripModifications() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <code>optional .transit_realtime.TripModifications trip_modifications = 8;</code>
     * @return The tripModifications.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripModifications getTripModifications() {
      return tripModifications_ == null ? com.google.transit.realtime.GtfsRealtime.TripModifications.getDefaultInstance() : tripModifications_;
    }
    /**
     * <code>optional .transit_realtime.TripModifications trip_modifications = 8;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripModificationsOrBuilder getTripModificationsOrBuilder() {
      return tripModifications_ == null ? com.google.transit.realtime.GtfsRealtime.TripModifications.getDefaultInstance() : tripModifications_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasId()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (hasTripUpdate()) {
        if (!getTripUpdate().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasVehicle()) {
        if (!getVehicle().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasAlert()) {
        if (!getAlert().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasShape()) {
        if (!getShape().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasStop()) {
        if (!getStop().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasTripModifications()) {
        if (!getTripModifications().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (!extensionsAreInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessage
        .ExtendableMessage.ExtensionSerializer
          extensionWriter = newExtensionSerializer();
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, id_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBool(2, isDeleted_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getTripUpdate());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(4, getVehicle());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeMessage(5, getAlert());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeMessage(6, getShape());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeMessage(7, getStop());
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeMessage(8, getTripModifications());
      }
      extensionWriter.writeUntil(10000, output);
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, id_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, isDeleted_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getTripUpdate());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getVehicle());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getAlert());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getShape());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getStop());
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getTripModifications());
      }
      size += extensionsSerializedSize();
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.FeedEntity)) {
        return super.equals(obj);
      }
      com.google.transit.realtime.GtfsRealtime.FeedEntity other = (com.google.transit.realtime.GtfsRealtime.FeedEntity) obj;

      if (hasId() != other.hasId()) return false;
      if (hasId()) {
        if (!getId()
            .equals(other.getId())) return false;
      }
      if (hasIsDeleted() != other.hasIsDeleted()) return false;
      if (hasIsDeleted()) {
        if (getIsDeleted()
            != other.getIsDeleted()) return false;
      }
      if (hasTripUpdate() != other.hasTripUpdate()) return false;
      if (hasTripUpdate()) {
        if (!getTripUpdate()
            .equals(other.getTripUpdate())) return false;
      }
      if (hasVehicle() != other.hasVehicle()) return false;
      if (hasVehicle()) {
        if (!getVehicle()
            .equals(other.getVehicle())) return false;
      }
      if (hasAlert() != other.hasAlert()) return false;
      if (hasAlert()) {
        if (!getAlert()
            .equals(other.getAlert())) return false;
      }
      if (hasShape() != other.hasShape()) return false;
      if (hasShape()) {
        if (!getShape()
            .equals(other.getShape())) return false;
      }
      if (hasStop() != other.hasStop()) return false;
      if (hasStop()) {
        if (!getStop()
            .equals(other.getStop())) return false;
      }
      if (hasTripModifications() != other.hasTripModifications()) return false;
      if (hasTripModifications()) {
        if (!getTripModifications()
            .equals(other.getTripModifications())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      if (!getExtensionFields().equals(other.getExtensionFields()))
        return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasId()) {
        hash = (37 * hash) + ID_FIELD_NUMBER;
        hash = (53 * hash) + getId().hashCode();
      }
      if (hasIsDeleted()) {
        hash = (37 * hash) + IS_DELETED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getIsDeleted());
      }
      if (hasTripUpdate()) {
        hash = (37 * hash) + TRIP_UPDATE_FIELD_NUMBER;
        hash = (53 * hash) + getTripUpdate().hashCode();
      }
      if (hasVehicle()) {
        hash = (37 * hash) + VEHICLE_FIELD_NUMBER;
        hash = (53 * hash) + getVehicle().hashCode();
      }
      if (hasAlert()) {
        hash = (37 * hash) + ALERT_FIELD_NUMBER;
        hash = (53 * hash) + getAlert().hashCode();
      }
      if (hasShape()) {
        hash = (37 * hash) + SHAPE_FIELD_NUMBER;
        hash = (53 * hash) + getShape().hashCode();
      }
      if (hasStop()) {
        hash = (37 * hash) + STOP_FIELD_NUMBER;
        hash = (53 * hash) + getStop().hashCode();
      }
      if (hasTripModifications()) {
        hash = (37 * hash) + TRIP_MODIFICATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getTripModifications().hashCode();
      }
      hash = hashFields(hash, getExtensionFields());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.transit.realtime.GtfsRealtime.FeedEntity parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedEntity parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedEntity parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedEntity parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedEntity parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedEntity parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedEntity parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedEntity parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.transit.realtime.GtfsRealtime.FeedEntity parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.transit.realtime.GtfsRealtime.FeedEntity parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedEntity parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedEntity parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.FeedEntity prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * A definition (or update) of an entity in the transit feed.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.FeedEntity}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
          com.google.transit.realtime.GtfsRealtime.FeedEntity, Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_realtime.FeedEntity)
        com.google.transit.realtime.GtfsRealtime.FeedEntityOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_FeedEntity_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_FeedEntity_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.FeedEntity.class, com.google.transit.realtime.GtfsRealtime.FeedEntity.Builder.class);
      }

      // Construct using com.google.transit.realtime.GtfsRealtime.FeedEntity.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getTripUpdateFieldBuilder();
          getVehicleFieldBuilder();
          getAlertFieldBuilder();
          getShapeFieldBuilder();
          getStopFieldBuilder();
          getTripModificationsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        id_ = "";
        isDeleted_ = false;
        tripUpdate_ = null;
        if (tripUpdateBuilder_ != null) {
          tripUpdateBuilder_.dispose();
          tripUpdateBuilder_ = null;
        }
        vehicle_ = null;
        if (vehicleBuilder_ != null) {
          vehicleBuilder_.dispose();
          vehicleBuilder_ = null;
        }
        alert_ = null;
        if (alertBuilder_ != null) {
          alertBuilder_.dispose();
          alertBuilder_ = null;
        }
        shape_ = null;
        if (shapeBuilder_ != null) {
          shapeBuilder_.dispose();
          shapeBuilder_ = null;
        }
        stop_ = null;
        if (stopBuilder_ != null) {
          stopBuilder_.dispose();
          stopBuilder_ = null;
        }
        tripModifications_ = null;
        if (tripModificationsBuilder_ != null) {
          tripModificationsBuilder_.dispose();
          tripModificationsBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_FeedEntity_descriptor;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.FeedEntity getDefaultInstanceForType() {
        return com.google.transit.realtime.GtfsRealtime.FeedEntity.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.FeedEntity build() {
        com.google.transit.realtime.GtfsRealtime.FeedEntity result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.FeedEntity buildPartial() {
        com.google.transit.realtime.GtfsRealtime.FeedEntity result = new com.google.transit.realtime.GtfsRealtime.FeedEntity(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.transit.realtime.GtfsRealtime.FeedEntity result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.id_ = id_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.isDeleted_ = isDeleted_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.tripUpdate_ = tripUpdateBuilder_ == null
              ? tripUpdate_
              : tripUpdateBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.vehicle_ = vehicleBuilder_ == null
              ? vehicle_
              : vehicleBuilder_.build();
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.alert_ = alertBuilder_ == null
              ? alert_
              : alertBuilder_.build();
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.shape_ = shapeBuilder_ == null
              ? shape_
              : shapeBuilder_.build();
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.stop_ = stopBuilder_ == null
              ? stop_
              : stopBuilder_.build();
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.tripModifications_ = tripModificationsBuilder_ == null
              ? tripModifications_
              : tripModificationsBuilder_.build();
          to_bitField0_ |= 0x00000080;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.transit.realtime.GtfsRealtime.FeedEntity) {
          return mergeFrom((com.google.transit.realtime.GtfsRealtime.FeedEntity)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.FeedEntity other) {
        if (other == com.google.transit.realtime.GtfsRealtime.FeedEntity.getDefaultInstance()) return this;
        if (other.hasId()) {
          id_ = other.id_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasIsDeleted()) {
          setIsDeleted(other.getIsDeleted());
        }
        if (other.hasTripUpdate()) {
          mergeTripUpdate(other.getTripUpdate());
        }
        if (other.hasVehicle()) {
          mergeVehicle(other.getVehicle());
        }
        if (other.hasAlert()) {
          mergeAlert(other.getAlert());
        }
        if (other.hasShape()) {
          mergeShape(other.getShape());
        }
        if (other.hasStop()) {
          mergeStop(other.getStop());
        }
        if (other.hasTripModifications()) {
          mergeTripModifications(other.getTripModifications());
        }
        this.mergeExtensionFields(other);
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasId()) {
          return false;
        }
        if (hasTripUpdate()) {
          if (!getTripUpdate().isInitialized()) {
            return false;
          }
        }
        if (hasVehicle()) {
          if (!getVehicle().isInitialized()) {
            return false;
          }
        }
        if (hasAlert()) {
          if (!getAlert().isInitialized()) {
            return false;
          }
        }
        if (hasShape()) {
          if (!getShape().isInitialized()) {
            return false;
          }
        }
        if (hasStop()) {
          if (!getStop().isInitialized()) {
            return false;
          }
        }
        if (hasTripModifications()) {
          if (!getTripModifications().isInitialized()) {
            return false;
          }
        }
        if (!extensionsAreInitialized()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                id_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 16: {
                isDeleted_ = input.readBool();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 26: {
                input.readMessage(
                    getTripUpdateFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                input.readMessage(
                    getVehicleFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                input.readMessage(
                    getAlertFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              case 50: {
                input.readMessage(
                    getShapeFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000020;
                break;
              } // case 50
              case 58: {
                input.readMessage(
                    getStopFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000040;
                break;
              } // case 58
              case 66: {
                input.readMessage(
                    getTripModificationsFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000080;
                break;
              } // case 66
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object id_ = "";
      /**
       * <pre>
       * The ids are used only to provide incrementality support. The id should be
       * unique within a FeedMessage. Consequent FeedMessages may contain
       * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
       * FeedEntity with some id will replace the old FeedEntity with the same id
       * (or delete it - see is_deleted below).
       * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
       * feed must be specified by explicit selectors (see EntitySelector below for
       * more info).
       * </pre>
       *
       * <code>required string id = 1;</code>
       * @return Whether the id field is set.
       */
      public boolean hasId() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The ids are used only to provide incrementality support. The id should be
       * unique within a FeedMessage. Consequent FeedMessages may contain
       * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
       * FeedEntity with some id will replace the old FeedEntity with the same id
       * (or delete it - see is_deleted below).
       * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
       * feed must be specified by explicit selectors (see EntitySelector below for
       * more info).
       * </pre>
       *
       * <code>required string id = 1;</code>
       * @return The id.
       */
      public java.lang.String getId() {
        java.lang.Object ref = id_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            id_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ids are used only to provide incrementality support. The id should be
       * unique within a FeedMessage. Consequent FeedMessages may contain
       * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
       * FeedEntity with some id will replace the old FeedEntity with the same id
       * (or delete it - see is_deleted below).
       * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
       * feed must be specified by explicit selectors (see EntitySelector below for
       * more info).
       * </pre>
       *
       * <code>required string id = 1;</code>
       * @return The bytes for id.
       */
      public com.google.protobuf.ByteString
          getIdBytes() {
        java.lang.Object ref = id_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          id_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ids are used only to provide incrementality support. The id should be
       * unique within a FeedMessage. Consequent FeedMessages may contain
       * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
       * FeedEntity with some id will replace the old FeedEntity with the same id
       * (or delete it - see is_deleted below).
       * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
       * feed must be specified by explicit selectors (see EntitySelector below for
       * more info).
       * </pre>
       *
       * <code>required string id = 1;</code>
       * @param value The id to set.
       * @return This builder for chaining.
       */
      public Builder setId(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        id_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ids are used only to provide incrementality support. The id should be
       * unique within a FeedMessage. Consequent FeedMessages may contain
       * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
       * FeedEntity with some id will replace the old FeedEntity with the same id
       * (or delete it - see is_deleted below).
       * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
       * feed must be specified by explicit selectors (see EntitySelector below for
       * more info).
       * </pre>
       *
       * <code>required string id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearId() {
        id_ = getDefaultInstance().getId();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ids are used only to provide incrementality support. The id should be
       * unique within a FeedMessage. Consequent FeedMessages may contain
       * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
       * FeedEntity with some id will replace the old FeedEntity with the same id
       * (or delete it - see is_deleted below).
       * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
       * feed must be specified by explicit selectors (see EntitySelector below for
       * more info).
       * </pre>
       *
       * <code>required string id = 1;</code>
       * @param value The bytes for id to set.
       * @return This builder for chaining.
       */
      public Builder setIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        id_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private boolean isDeleted_ ;
      /**
       * <pre>
       * Whether this entity is to be deleted. Relevant only for incremental
       * fetches.
       * </pre>
       *
       * <code>optional bool is_deleted = 2 [default = false];</code>
       * @return Whether the isDeleted field is set.
       */
      @java.lang.Override
      public boolean hasIsDeleted() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Whether this entity is to be deleted. Relevant only for incremental
       * fetches.
       * </pre>
       *
       * <code>optional bool is_deleted = 2 [default = false];</code>
       * @return The isDeleted.
       */
      @java.lang.Override
      public boolean getIsDeleted() {
        return isDeleted_;
      }
      /**
       * <pre>
       * Whether this entity is to be deleted. Relevant only for incremental
       * fetches.
       * </pre>
       *
       * <code>optional bool is_deleted = 2 [default = false];</code>
       * @param value The isDeleted to set.
       * @return This builder for chaining.
       */
      public Builder setIsDeleted(boolean value) {

        isDeleted_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether this entity is to be deleted. Relevant only for incremental
       * fetches.
       * </pre>
       *
       * <code>optional bool is_deleted = 2 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearIsDeleted() {
        bitField0_ = (bitField0_ & ~0x00000002);
        isDeleted_ = false;
        onChanged();
        return this;
      }

      private com.google.transit.realtime.GtfsRealtime.TripUpdate tripUpdate_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TripUpdate, com.google.transit.realtime.GtfsRealtime.TripUpdate.Builder, com.google.transit.realtime.GtfsRealtime.TripUpdateOrBuilder> tripUpdateBuilder_;
      /**
       * <pre>
       * Data about the entity itself. Exactly one of the following fields must be
       * present (unless the entity is being deleted).
       * </pre>
       *
       * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
       * @return Whether the tripUpdate field is set.
       */
      public boolean hasTripUpdate() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Data about the entity itself. Exactly one of the following fields must be
       * present (unless the entity is being deleted).
       * </pre>
       *
       * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
       * @return The tripUpdate.
       */
      public com.google.transit.realtime.GtfsRealtime.TripUpdate getTripUpdate() {
        if (tripUpdateBuilder_ == null) {
          return tripUpdate_ == null ? com.google.transit.realtime.GtfsRealtime.TripUpdate.getDefaultInstance() : tripUpdate_;
        } else {
          return tripUpdateBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Data about the entity itself. Exactly one of the following fields must be
       * present (unless the entity is being deleted).
       * </pre>
       *
       * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
       */
      public Builder setTripUpdate(com.google.transit.realtime.GtfsRealtime.TripUpdate value) {
        if (tripUpdateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          tripUpdate_ = value;
        } else {
          tripUpdateBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Data about the entity itself. Exactly one of the following fields must be
       * present (unless the entity is being deleted).
       * </pre>
       *
       * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
       */
      public Builder setTripUpdate(
          com.google.transit.realtime.GtfsRealtime.TripUpdate.Builder builderForValue) {
        if (tripUpdateBuilder_ == null) {
          tripUpdate_ = builderForValue.build();
        } else {
          tripUpdateBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Data about the entity itself. Exactly one of the following fields must be
       * present (unless the entity is being deleted).
       * </pre>
       *
       * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
       */
      public Builder mergeTripUpdate(com.google.transit.realtime.GtfsRealtime.TripUpdate value) {
        if (tripUpdateBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            tripUpdate_ != null &&
            tripUpdate_ != com.google.transit.realtime.GtfsRealtime.TripUpdate.getDefaultInstance()) {
            getTripUpdateBuilder().mergeFrom(value);
          } else {
            tripUpdate_ = value;
          }
        } else {
          tripUpdateBuilder_.mergeFrom(value);
        }
        if (tripUpdate_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Data about the entity itself. Exactly one of the following fields must be
       * present (unless the entity is being deleted).
       * </pre>
       *
       * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
       */
      public Builder clearTripUpdate() {
        bitField0_ = (bitField0_ & ~0x00000004);
        tripUpdate_ = null;
        if (tripUpdateBuilder_ != null) {
          tripUpdateBuilder_.dispose();
          tripUpdateBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Data about the entity itself. Exactly one of the following fields must be
       * present (unless the entity is being deleted).
       * </pre>
       *
       * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripUpdate.Builder getTripUpdateBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getTripUpdateFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Data about the entity itself. Exactly one of the following fields must be
       * present (unless the entity is being deleted).
       * </pre>
       *
       * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripUpdateOrBuilder getTripUpdateOrBuilder() {
        if (tripUpdateBuilder_ != null) {
          return tripUpdateBuilder_.getMessageOrBuilder();
        } else {
          return tripUpdate_ == null ?
              com.google.transit.realtime.GtfsRealtime.TripUpdate.getDefaultInstance() : tripUpdate_;
        }
      }
      /**
       * <pre>
       * Data about the entity itself. Exactly one of the following fields must be
       * present (unless the entity is being deleted).
       * </pre>
       *
       * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TripUpdate, com.google.transit.realtime.GtfsRealtime.TripUpdate.Builder, com.google.transit.realtime.GtfsRealtime.TripUpdateOrBuilder> 
          getTripUpdateFieldBuilder() {
        if (tripUpdateBuilder_ == null) {
          tripUpdateBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TripUpdate, com.google.transit.realtime.GtfsRealtime.TripUpdate.Builder, com.google.transit.realtime.GtfsRealtime.TripUpdateOrBuilder>(
                  getTripUpdate(),
                  getParentForChildren(),
                  isClean());
          tripUpdate_ = null;
        }
        return tripUpdateBuilder_;
      }

      private com.google.transit.realtime.GtfsRealtime.VehiclePosition vehicle_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.VehiclePosition, com.google.transit.realtime.GtfsRealtime.VehiclePosition.Builder, com.google.transit.realtime.GtfsRealtime.VehiclePositionOrBuilder> vehicleBuilder_;
      /**
       * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
       * @return Whether the vehicle field is set.
       */
      public boolean hasVehicle() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
       * @return The vehicle.
       */
      public com.google.transit.realtime.GtfsRealtime.VehiclePosition getVehicle() {
        if (vehicleBuilder_ == null) {
          return vehicle_ == null ? com.google.transit.realtime.GtfsRealtime.VehiclePosition.getDefaultInstance() : vehicle_;
        } else {
          return vehicleBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
       */
      public Builder setVehicle(com.google.transit.realtime.GtfsRealtime.VehiclePosition value) {
        if (vehicleBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          vehicle_ = value;
        } else {
          vehicleBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
       */
      public Builder setVehicle(
          com.google.transit.realtime.GtfsRealtime.VehiclePosition.Builder builderForValue) {
        if (vehicleBuilder_ == null) {
          vehicle_ = builderForValue.build();
        } else {
          vehicleBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
       */
      public Builder mergeVehicle(com.google.transit.realtime.GtfsRealtime.VehiclePosition value) {
        if (vehicleBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0) &&
            vehicle_ != null &&
            vehicle_ != com.google.transit.realtime.GtfsRealtime.VehiclePosition.getDefaultInstance()) {
            getVehicleBuilder().mergeFrom(value);
          } else {
            vehicle_ = value;
          }
        } else {
          vehicleBuilder_.mergeFrom(value);
        }
        if (vehicle_ != null) {
          bitField0_ |= 0x00000008;
          onChanged();
        }
        return this;
      }
      /**
       * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
       */
      public Builder clearVehicle() {
        bitField0_ = (bitField0_ & ~0x00000008);
        vehicle_ = null;
        if (vehicleBuilder_ != null) {
          vehicleBuilder_.dispose();
          vehicleBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.VehiclePosition.Builder getVehicleBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getVehicleFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.VehiclePositionOrBuilder getVehicleOrBuilder() {
        if (vehicleBuilder_ != null) {
          return vehicleBuilder_.getMessageOrBuilder();
        } else {
          return vehicle_ == null ?
              com.google.transit.realtime.GtfsRealtime.VehiclePosition.getDefaultInstance() : vehicle_;
        }
      }
      /**
       * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.VehiclePosition, com.google.transit.realtime.GtfsRealtime.VehiclePosition.Builder, com.google.transit.realtime.GtfsRealtime.VehiclePositionOrBuilder> 
          getVehicleFieldBuilder() {
        if (vehicleBuilder_ == null) {
          vehicleBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.VehiclePosition, com.google.transit.realtime.GtfsRealtime.VehiclePosition.Builder, com.google.transit.realtime.GtfsRealtime.VehiclePositionOrBuilder>(
                  getVehicle(),
                  getParentForChildren(),
                  isClean());
          vehicle_ = null;
        }
        return vehicleBuilder_;
      }

      private com.google.transit.realtime.GtfsRealtime.Alert alert_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.Alert, com.google.transit.realtime.GtfsRealtime.Alert.Builder, com.google.transit.realtime.GtfsRealtime.AlertOrBuilder> alertBuilder_;
      /**
       * <code>optional .transit_realtime.Alert alert = 5;</code>
       * @return Whether the alert field is set.
       */
      public boolean hasAlert() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <code>optional .transit_realtime.Alert alert = 5;</code>
       * @return The alert.
       */
      public com.google.transit.realtime.GtfsRealtime.Alert getAlert() {
        if (alertBuilder_ == null) {
          return alert_ == null ? com.google.transit.realtime.GtfsRealtime.Alert.getDefaultInstance() : alert_;
        } else {
          return alertBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .transit_realtime.Alert alert = 5;</code>
       */
      public Builder setAlert(com.google.transit.realtime.GtfsRealtime.Alert value) {
        if (alertBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          alert_ = value;
        } else {
          alertBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.Alert alert = 5;</code>
       */
      public Builder setAlert(
          com.google.transit.realtime.GtfsRealtime.Alert.Builder builderForValue) {
        if (alertBuilder_ == null) {
          alert_ = builderForValue.build();
        } else {
          alertBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.Alert alert = 5;</code>
       */
      public Builder mergeAlert(com.google.transit.realtime.GtfsRealtime.Alert value) {
        if (alertBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0) &&
            alert_ != null &&
            alert_ != com.google.transit.realtime.GtfsRealtime.Alert.getDefaultInstance()) {
            getAlertBuilder().mergeFrom(value);
          } else {
            alert_ = value;
          }
        } else {
          alertBuilder_.mergeFrom(value);
        }
        if (alert_ != null) {
          bitField0_ |= 0x00000010;
          onChanged();
        }
        return this;
      }
      /**
       * <code>optional .transit_realtime.Alert alert = 5;</code>
       */
      public Builder clearAlert() {
        bitField0_ = (bitField0_ & ~0x00000010);
        alert_ = null;
        if (alertBuilder_ != null) {
          alertBuilder_.dispose();
          alertBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.Alert alert = 5;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.Alert.Builder getAlertBuilder() {
        bitField0_ |= 0x00000010;
        onChanged();
        return getAlertFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .transit_realtime.Alert alert = 5;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.AlertOrBuilder getAlertOrBuilder() {
        if (alertBuilder_ != null) {
          return alertBuilder_.getMessageOrBuilder();
        } else {
          return alert_ == null ?
              com.google.transit.realtime.GtfsRealtime.Alert.getDefaultInstance() : alert_;
        }
      }
      /**
       * <code>optional .transit_realtime.Alert alert = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.Alert, com.google.transit.realtime.GtfsRealtime.Alert.Builder, com.google.transit.realtime.GtfsRealtime.AlertOrBuilder> 
          getAlertFieldBuilder() {
        if (alertBuilder_ == null) {
          alertBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.Alert, com.google.transit.realtime.GtfsRealtime.Alert.Builder, com.google.transit.realtime.GtfsRealtime.AlertOrBuilder>(
                  getAlert(),
                  getParentForChildren(),
                  isClean());
          alert_ = null;
        }
        return alertBuilder_;
      }

      private com.google.transit.realtime.GtfsRealtime.Shape shape_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.Shape, com.google.transit.realtime.GtfsRealtime.Shape.Builder, com.google.transit.realtime.GtfsRealtime.ShapeOrBuilder> shapeBuilder_;
      /**
       * <pre>
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.Shape shape = 6;</code>
       * @return Whether the shape field is set.
       */
      public boolean hasShape() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.Shape shape = 6;</code>
       * @return The shape.
       */
      public com.google.transit.realtime.GtfsRealtime.Shape getShape() {
        if (shapeBuilder_ == null) {
          return shape_ == null ? com.google.transit.realtime.GtfsRealtime.Shape.getDefaultInstance() : shape_;
        } else {
          return shapeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.Shape shape = 6;</code>
       */
      public Builder setShape(com.google.transit.realtime.GtfsRealtime.Shape value) {
        if (shapeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          shape_ = value;
        } else {
          shapeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.Shape shape = 6;</code>
       */
      public Builder setShape(
          com.google.transit.realtime.GtfsRealtime.Shape.Builder builderForValue) {
        if (shapeBuilder_ == null) {
          shape_ = builderForValue.build();
        } else {
          shapeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.Shape shape = 6;</code>
       */
      public Builder mergeShape(com.google.transit.realtime.GtfsRealtime.Shape value) {
        if (shapeBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0) &&
            shape_ != null &&
            shape_ != com.google.transit.realtime.GtfsRealtime.Shape.getDefaultInstance()) {
            getShapeBuilder().mergeFrom(value);
          } else {
            shape_ = value;
          }
        } else {
          shapeBuilder_.mergeFrom(value);
        }
        if (shape_ != null) {
          bitField0_ |= 0x00000020;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.Shape shape = 6;</code>
       */
      public Builder clearShape() {
        bitField0_ = (bitField0_ & ~0x00000020);
        shape_ = null;
        if (shapeBuilder_ != null) {
          shapeBuilder_.dispose();
          shapeBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.Shape shape = 6;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.Shape.Builder getShapeBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getShapeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.Shape shape = 6;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.ShapeOrBuilder getShapeOrBuilder() {
        if (shapeBuilder_ != null) {
          return shapeBuilder_.getMessageOrBuilder();
        } else {
          return shape_ == null ?
              com.google.transit.realtime.GtfsRealtime.Shape.getDefaultInstance() : shape_;
        }
      }
      /**
       * <pre>
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.Shape shape = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.Shape, com.google.transit.realtime.GtfsRealtime.Shape.Builder, com.google.transit.realtime.GtfsRealtime.ShapeOrBuilder> 
          getShapeFieldBuilder() {
        if (shapeBuilder_ == null) {
          shapeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.Shape, com.google.transit.realtime.GtfsRealtime.Shape.Builder, com.google.transit.realtime.GtfsRealtime.ShapeOrBuilder>(
                  getShape(),
                  getParentForChildren(),
                  isClean());
          shape_ = null;
        }
        return shapeBuilder_;
      }

      private com.google.transit.realtime.GtfsRealtime.Stop stop_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.Stop, com.google.transit.realtime.GtfsRealtime.Stop.Builder, com.google.transit.realtime.GtfsRealtime.StopOrBuilder> stopBuilder_;
      /**
       * <code>optional .transit_realtime.Stop stop = 7;</code>
       * @return Whether the stop field is set.
       */
      public boolean hasStop() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <code>optional .transit_realtime.Stop stop = 7;</code>
       * @return The stop.
       */
      public com.google.transit.realtime.GtfsRealtime.Stop getStop() {
        if (stopBuilder_ == null) {
          return stop_ == null ? com.google.transit.realtime.GtfsRealtime.Stop.getDefaultInstance() : stop_;
        } else {
          return stopBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .transit_realtime.Stop stop = 7;</code>
       */
      public Builder setStop(com.google.transit.realtime.GtfsRealtime.Stop value) {
        if (stopBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          stop_ = value;
        } else {
          stopBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.Stop stop = 7;</code>
       */
      public Builder setStop(
          com.google.transit.realtime.GtfsRealtime.Stop.Builder builderForValue) {
        if (stopBuilder_ == null) {
          stop_ = builderForValue.build();
        } else {
          stopBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.Stop stop = 7;</code>
       */
      public Builder mergeStop(com.google.transit.realtime.GtfsRealtime.Stop value) {
        if (stopBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
            stop_ != null &&
            stop_ != com.google.transit.realtime.GtfsRealtime.Stop.getDefaultInstance()) {
            getStopBuilder().mergeFrom(value);
          } else {
            stop_ = value;
          }
        } else {
          stopBuilder_.mergeFrom(value);
        }
        if (stop_ != null) {
          bitField0_ |= 0x00000040;
          onChanged();
        }
        return this;
      }
      /**
       * <code>optional .transit_realtime.Stop stop = 7;</code>
       */
      public Builder clearStop() {
        bitField0_ = (bitField0_ & ~0x00000040);
        stop_ = null;
        if (stopBuilder_ != null) {
          stopBuilder_.dispose();
          stopBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.Stop stop = 7;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.Stop.Builder getStopBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getStopFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .transit_realtime.Stop stop = 7;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.StopOrBuilder getStopOrBuilder() {
        if (stopBuilder_ != null) {
          return stopBuilder_.getMessageOrBuilder();
        } else {
          return stop_ == null ?
              com.google.transit.realtime.GtfsRealtime.Stop.getDefaultInstance() : stop_;
        }
      }
      /**
       * <code>optional .transit_realtime.Stop stop = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.Stop, com.google.transit.realtime.GtfsRealtime.Stop.Builder, com.google.transit.realtime.GtfsRealtime.StopOrBuilder> 
          getStopFieldBuilder() {
        if (stopBuilder_ == null) {
          stopBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.Stop, com.google.transit.realtime.GtfsRealtime.Stop.Builder, com.google.transit.realtime.GtfsRealtime.StopOrBuilder>(
                  getStop(),
                  getParentForChildren(),
                  isClean());
          stop_ = null;
        }
        return stopBuilder_;
      }

      private com.google.transit.realtime.GtfsRealtime.TripModifications tripModifications_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TripModifications, com.google.transit.realtime.GtfsRealtime.TripModifications.Builder, com.google.transit.realtime.GtfsRealtime.TripModificationsOrBuilder> tripModificationsBuilder_;
      /**
       * <code>optional .transit_realtime.TripModifications trip_modifications = 8;</code>
       * @return Whether the tripModifications field is set.
       */
      public boolean hasTripModifications() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <code>optional .transit_realtime.TripModifications trip_modifications = 8;</code>
       * @return The tripModifications.
       */
      public com.google.transit.realtime.GtfsRealtime.TripModifications getTripModifications() {
        if (tripModificationsBuilder_ == null) {
          return tripModifications_ == null ? com.google.transit.realtime.GtfsRealtime.TripModifications.getDefaultInstance() : tripModifications_;
        } else {
          return tripModificationsBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .transit_realtime.TripModifications trip_modifications = 8;</code>
       */
      public Builder setTripModifications(com.google.transit.realtime.GtfsRealtime.TripModifications value) {
        if (tripModificationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          tripModifications_ = value;
        } else {
          tripModificationsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TripModifications trip_modifications = 8;</code>
       */
      public Builder setTripModifications(
          com.google.transit.realtime.GtfsRealtime.TripModifications.Builder builderForValue) {
        if (tripModificationsBuilder_ == null) {
          tripModifications_ = builderForValue.build();
        } else {
          tripModificationsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TripModifications trip_modifications = 8;</code>
       */
      public Builder mergeTripModifications(com.google.transit.realtime.GtfsRealtime.TripModifications value) {
        if (tripModificationsBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0) &&
            tripModifications_ != null &&
            tripModifications_ != com.google.transit.realtime.GtfsRealtime.TripModifications.getDefaultInstance()) {
            getTripModificationsBuilder().mergeFrom(value);
          } else {
            tripModifications_ = value;
          }
        } else {
          tripModificationsBuilder_.mergeFrom(value);
        }
        if (tripModifications_ != null) {
          bitField0_ |= 0x00000080;
          onChanged();
        }
        return this;
      }
      /**
       * <code>optional .transit_realtime.TripModifications trip_modifications = 8;</code>
       */
      public Builder clearTripModifications() {
        bitField0_ = (bitField0_ & ~0x00000080);
        tripModifications_ = null;
        if (tripModificationsBuilder_ != null) {
          tripModificationsBuilder_.dispose();
          tripModificationsBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TripModifications trip_modifications = 8;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripModifications.Builder getTripModificationsBuilder() {
        bitField0_ |= 0x00000080;
        onChanged();
        return getTripModificationsFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .transit_realtime.TripModifications trip_modifications = 8;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripModificationsOrBuilder getTripModificationsOrBuilder() {
        if (tripModificationsBuilder_ != null) {
          return tripModificationsBuilder_.getMessageOrBuilder();
        } else {
          return tripModifications_ == null ?
              com.google.transit.realtime.GtfsRealtime.TripModifications.getDefaultInstance() : tripModifications_;
        }
      }
      /**
       * <code>optional .transit_realtime.TripModifications trip_modifications = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TripModifications, com.google.transit.realtime.GtfsRealtime.TripModifications.Builder, com.google.transit.realtime.GtfsRealtime.TripModificationsOrBuilder> 
          getTripModificationsFieldBuilder() {
        if (tripModificationsBuilder_ == null) {
          tripModificationsBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TripModifications, com.google.transit.realtime.GtfsRealtime.TripModifications.Builder, com.google.transit.realtime.GtfsRealtime.TripModificationsOrBuilder>(
                  getTripModifications(),
                  getParentForChildren(),
                  isClean());
          tripModifications_ = null;
        }
        return tripModificationsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.FeedEntity)
    }

    // @@protoc_insertion_point(class_scope:transit_realtime.FeedEntity)
    private static final com.google.transit.realtime.GtfsRealtime.FeedEntity DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.FeedEntity();
    }

    public static com.google.transit.realtime.GtfsRealtime.FeedEntity getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<FeedEntity>
        PARSER = new com.google.protobuf.AbstractParser<FeedEntity>() {
      @java.lang.Override
      public FeedEntity parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<FeedEntity> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<FeedEntity> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.FeedEntity getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TripUpdateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_realtime.TripUpdate)
      com.google.protobuf.GeneratedMessage.
          ExtendableMessageOrBuilder<TripUpdate> {

    /**
     * <pre>
     * The Trip that this message applies to. There can be at most one
     * TripUpdate entity for each actual trip instance.
     * If there is none, that means there is no prediction information available.
     * It does *not* mean that the trip is progressing according to schedule.
     * </pre>
     *
     * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
     * @return Whether the trip field is set.
     */
    boolean hasTrip();
    /**
     * <pre>
     * The Trip that this message applies to. There can be at most one
     * TripUpdate entity for each actual trip instance.
     * If there is none, that means there is no prediction information available.
     * It does *not* mean that the trip is progressing according to schedule.
     * </pre>
     *
     * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
     * @return The trip.
     */
    com.google.transit.realtime.GtfsRealtime.TripDescriptor getTrip();
    /**
     * <pre>
     * The Trip that this message applies to. There can be at most one
     * TripUpdate entity for each actual trip instance.
     * If there is none, that means there is no prediction information available.
     * It does *not* mean that the trip is progressing according to schedule.
     * </pre>
     *
     * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TripDescriptorOrBuilder getTripOrBuilder();

    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
     * @return Whether the vehicle field is set.
     */
    boolean hasVehicle();
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
     * @return The vehicle.
     */
    com.google.transit.realtime.GtfsRealtime.VehicleDescriptor getVehicle();
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
     */
    com.google.transit.realtime.GtfsRealtime.VehicleDescriptorOrBuilder getVehicleOrBuilder();

    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     *
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     *
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    java.util.List<com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate> 
        getStopTimeUpdateList();
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     *
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     *
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate getStopTimeUpdate(int index);
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     *
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     *
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    int getStopTimeUpdateCount();
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     *
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     *
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    java.util.List<? extends com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdateOrBuilder> 
        getStopTimeUpdateOrBuilderList();
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     *
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     *
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdateOrBuilder getStopTimeUpdateOrBuilder(
        int index);

    /**
     * <pre>
     * The most recent moment at which the vehicle's real-time progress was measured
     * to estimate StopTimes in the future. When StopTimes in the past are provided,
     * arrival/departure times may be earlier than this value. In POSIX
     * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 4;</code>
     * @return Whether the timestamp field is set.
     */
    boolean hasTimestamp();
    /**
     * <pre>
     * The most recent moment at which the vehicle's real-time progress was measured
     * to estimate StopTimes in the future. When StopTimes in the past are provided,
     * arrival/departure times may be earlier than this value. In POSIX
     * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 4;</code>
     * @return The timestamp.
     */
    long getTimestamp();

    /**
     * <pre>
     * The current schedule deviation for the trip.  Delay should only be
     * specified when the prediction is given relative to some existing schedule
     * in GTFS.
     *
     * Delay (in seconds) can be positive (meaning that the vehicle is late) or
     * negative (meaning that the vehicle is ahead of schedule). Delay of 0
     * means that the vehicle is exactly on time.
     *
     * Delay information in StopTimeUpdates take precedent of trip-level delay
     * information, such that trip-level delay is only propagated until the next
     * stop along the trip with a StopTimeUpdate delay value specified.
     *
     * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
     * value indicating when the delay value was last updated, in order to
     * evaluate the freshness of the data.
     *
     * NOTE: This field is still experimental, and subject to change. It may be
     * formally adopted in the future.
     * </pre>
     *
     * <code>optional int32 delay = 5;</code>
     * @return Whether the delay field is set.
     */
    boolean hasDelay();
    /**
     * <pre>
     * The current schedule deviation for the trip.  Delay should only be
     * specified when the prediction is given relative to some existing schedule
     * in GTFS.
     *
     * Delay (in seconds) can be positive (meaning that the vehicle is late) or
     * negative (meaning that the vehicle is ahead of schedule). Delay of 0
     * means that the vehicle is exactly on time.
     *
     * Delay information in StopTimeUpdates take precedent of trip-level delay
     * information, such that trip-level delay is only propagated until the next
     * stop along the trip with a StopTimeUpdate delay value specified.
     *
     * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
     * value indicating when the delay value was last updated, in order to
     * evaluate the freshness of the data.
     *
     * NOTE: This field is still experimental, and subject to change. It may be
     * formally adopted in the future.
     * </pre>
     *
     * <code>optional int32 delay = 5;</code>
     * @return The delay.
     */
    int getDelay();

    /**
     * <code>optional .transit_realtime.TripUpdate.TripProperties trip_properties = 6;</code>
     * @return Whether the tripProperties field is set.
     */
    boolean hasTripProperties();
    /**
     * <code>optional .transit_realtime.TripUpdate.TripProperties trip_properties = 6;</code>
     * @return The tripProperties.
     */
    com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties getTripProperties();
    /**
     * <code>optional .transit_realtime.TripUpdate.TripProperties trip_properties = 6;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TripUpdate.TripPropertiesOrBuilder getTripPropertiesOrBuilder();
  }
  /**
   * <pre>
   * Realtime update of the progress of a vehicle along a trip.
   * Depending on the value of ScheduleRelationship, a TripUpdate can specify:
   * - A trip that proceeds along the schedule.
   * - A trip that proceeds along a route but has no fixed schedule.
   * - A trip that have been added or removed with regard to schedule.
   *
   * The updates can be for future, predicted arrival/departure events, or for
   * past events that already occurred.
   * Normally, updates should get more precise and more certain (see
   * uncertainty below) as the events gets closer to current time.
   * Even if that is not possible, the information for past events should be
   * precise and certain. In particular, if an update points to time in the past
   * but its update's uncertainty is not 0, the client should conclude that the
   * update is a (wrong) prediction and that the trip has not completed yet.
   *
   * Note that the update can describe a trip that is already completed.
   * To this end, it is enough to provide an update for the last stop of the trip.
   * If the time of that is in the past, the client will conclude from that that
   * the whole trip is in the past (it is possible, although inconsequential, to
   * also provide updates for preceding stops).
   * This option is most relevant for a trip that has completed ahead of schedule,
   * but according to the schedule, the trip is still proceeding at the current
   * time. Removing the updates for this trip could make the client assume
   * that the trip is still proceeding.
   * Note that the feed provider is allowed, but not required, to purge past
   * updates - this is one case where this would be practically useful.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.TripUpdate}
   */
  public static final class TripUpdate extends
      com.google.protobuf.GeneratedMessage.ExtendableMessage<
        TripUpdate> implements
      // @@protoc_insertion_point(message_implements:transit_realtime.TripUpdate)
      TripUpdateOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 28,
        /* patch= */ 3,
        /* suffix= */ "",
        TripUpdate.class.getName());
    }
    // Use TripUpdate.newBuilder() to construct.
    private TripUpdate(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.TripUpdate, ?> builder) {
      super(builder);
    }
    private TripUpdate() {
      stopTimeUpdate_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.transit.realtime.GtfsRealtime.TripUpdate.class, com.google.transit.realtime.GtfsRealtime.TripUpdate.Builder.class);
    }

    public interface StopTimeEventOrBuilder extends
        // @@protoc_insertion_point(interface_extends:transit_realtime.TripUpdate.StopTimeEvent)
        com.google.protobuf.GeneratedMessage.
            ExtendableMessageOrBuilder<StopTimeEvent> {

      /**
       * <pre>
       * Delay (in seconds) can be positive (meaning that the vehicle is late) or
       * negative (meaning that the vehicle is ahead of schedule). Delay of 0
       * means that the vehicle is exactly on time.
       * </pre>
       *
       * <code>optional int32 delay = 1;</code>
       * @return Whether the delay field is set.
       */
      boolean hasDelay();
      /**
       * <pre>
       * Delay (in seconds) can be positive (meaning that the vehicle is late) or
       * negative (meaning that the vehicle is ahead of schedule). Delay of 0
       * means that the vehicle is exactly on time.
       * </pre>
       *
       * <code>optional int32 delay = 1;</code>
       * @return The delay.
       */
      int getDelay();

      /**
       * <pre>
       * Event as absolute time.
       * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
       * UTC).
       * </pre>
       *
       * <code>optional int64 time = 2;</code>
       * @return Whether the time field is set.
       */
      boolean hasTime();
      /**
       * <pre>
       * Event as absolute time.
       * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
       * UTC).
       * </pre>
       *
       * <code>optional int64 time = 2;</code>
       * @return The time.
       */
      long getTime();

      /**
       * <pre>
       * If uncertainty is omitted, it is interpreted as unknown.
       * If the prediction is unknown or too uncertain, the delay (or time) field
       * should be empty. In such case, the uncertainty field is ignored.
       * To specify a completely certain prediction, set its uncertainty to 0.
       * </pre>
       *
       * <code>optional int32 uncertainty = 3;</code>
       * @return Whether the uncertainty field is set.
       */
      boolean hasUncertainty();
      /**
       * <pre>
       * If uncertainty is omitted, it is interpreted as unknown.
       * If the prediction is unknown or too uncertain, the delay (or time) field
       * should be empty. In such case, the uncertainty field is ignored.
       * To specify a completely certain prediction, set its uncertainty to 0.
       * </pre>
       *
       * <code>optional int32 uncertainty = 3;</code>
       * @return The uncertainty.
       */
      int getUncertainty();
    }
    /**
     * <pre>
     * Timing information for a single predicted event (either arrival or
     * departure).
     * Timing consists of delay and/or estimated time, and uncertainty.
     * - delay should be used when the prediction is given relative to some
     * existing schedule in GTFS.
     * - time should be given whether there is a predicted schedule or not. If
     * both time and delay are specified, time will take precedence
     * (although normally, time, if given for a scheduled trip, should be
     * equal to scheduled time in GTFS + delay).
     *
     * Uncertainty applies equally to both time and delay.
     * The uncertainty roughly specifies the expected error in true delay (but
     * note, we don't yet define its precise statistical meaning). It's possible
     * for the uncertainty to be 0, for example for trains that are driven under
     * computer timing control.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.TripUpdate.StopTimeEvent}
     */
    public static final class StopTimeEvent extends
        com.google.protobuf.GeneratedMessage.ExtendableMessage<
          StopTimeEvent> implements
        // @@protoc_insertion_point(message_implements:transit_realtime.TripUpdate.StopTimeEvent)
        StopTimeEventOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 28,
          /* patch= */ 3,
          /* suffix= */ "",
          StopTimeEvent.class.getName());
      }
      // Use StopTimeEvent.newBuilder() to construct.
      private StopTimeEvent(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent, ?> builder) {
        super(builder);
      }
      private StopTimeEvent() {
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_StopTimeEvent_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_StopTimeEvent_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.class, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.Builder.class);
      }

      private int bitField0_;
      public static final int DELAY_FIELD_NUMBER = 1;
      private int delay_ = 0;
      /**
       * <pre>
       * Delay (in seconds) can be positive (meaning that the vehicle is late) or
       * negative (meaning that the vehicle is ahead of schedule). Delay of 0
       * means that the vehicle is exactly on time.
       * </pre>
       *
       * <code>optional int32 delay = 1;</code>
       * @return Whether the delay field is set.
       */
      @java.lang.Override
      public boolean hasDelay() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Delay (in seconds) can be positive (meaning that the vehicle is late) or
       * negative (meaning that the vehicle is ahead of schedule). Delay of 0
       * means that the vehicle is exactly on time.
       * </pre>
       *
       * <code>optional int32 delay = 1;</code>
       * @return The delay.
       */
      @java.lang.Override
      public int getDelay() {
        return delay_;
      }

      public static final int TIME_FIELD_NUMBER = 2;
      private long time_ = 0L;
      /**
       * <pre>
       * Event as absolute time.
       * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
       * UTC).
       * </pre>
       *
       * <code>optional int64 time = 2;</code>
       * @return Whether the time field is set.
       */
      @java.lang.Override
      public boolean hasTime() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Event as absolute time.
       * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
       * UTC).
       * </pre>
       *
       * <code>optional int64 time = 2;</code>
       * @return The time.
       */
      @java.lang.Override
      public long getTime() {
        return time_;
      }

      public static final int UNCERTAINTY_FIELD_NUMBER = 3;
      private int uncertainty_ = 0;
      /**
       * <pre>
       * If uncertainty is omitted, it is interpreted as unknown.
       * If the prediction is unknown or too uncertain, the delay (or time) field
       * should be empty. In such case, the uncertainty field is ignored.
       * To specify a completely certain prediction, set its uncertainty to 0.
       * </pre>
       *
       * <code>optional int32 uncertainty = 3;</code>
       * @return Whether the uncertainty field is set.
       */
      @java.lang.Override
      public boolean hasUncertainty() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * If uncertainty is omitted, it is interpreted as unknown.
       * If the prediction is unknown or too uncertain, the delay (or time) field
       * should be empty. In such case, the uncertainty field is ignored.
       * To specify a completely certain prediction, set its uncertainty to 0.
       * </pre>
       *
       * <code>optional int32 uncertainty = 3;</code>
       * @return The uncertainty.
       */
      @java.lang.Override
      public int getUncertainty() {
        return uncertainty_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        if (!extensionsAreInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        com.google.protobuf.GeneratedMessage
          .ExtendableMessage.ExtensionSerializer
            extensionWriter = newExtensionSerializer();
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeInt32(1, delay_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeInt64(2, time_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          output.writeInt32(3, uncertainty_);
        }
        extensionWriter.writeUntil(10000, output);
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(1, delay_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt64Size(2, time_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(3, uncertainty_);
        }
        size += extensionsSerializedSize();
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent)) {
          return super.equals(obj);
        }
        com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent other = (com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent) obj;

        if (hasDelay() != other.hasDelay()) return false;
        if (hasDelay()) {
          if (getDelay()
              != other.getDelay()) return false;
        }
        if (hasTime() != other.hasTime()) return false;
        if (hasTime()) {
          if (getTime()
              != other.getTime()) return false;
        }
        if (hasUncertainty() != other.hasUncertainty()) return false;
        if (hasUncertainty()) {
          if (getUncertainty()
              != other.getUncertainty()) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        if (!getExtensionFields().equals(other.getExtensionFields()))
          return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasDelay()) {
          hash = (37 * hash) + DELAY_FIELD_NUMBER;
          hash = (53 * hash) + getDelay();
        }
        if (hasTime()) {
          hash = (37 * hash) + TIME_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getTime());
        }
        if (hasUncertainty()) {
          hash = (37 * hash) + UNCERTAINTY_FIELD_NUMBER;
          hash = (53 * hash) + getUncertainty();
        }
        hash = hashFields(hash, getExtensionFields());
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Timing information for a single predicted event (either arrival or
       * departure).
       * Timing consists of delay and/or estimated time, and uncertainty.
       * - delay should be used when the prediction is given relative to some
       * existing schedule in GTFS.
       * - time should be given whether there is a predicted schedule or not. If
       * both time and delay are specified, time will take precedence
       * (although normally, time, if given for a scheduled trip, should be
       * equal to scheduled time in GTFS + delay).
       *
       * Uncertainty applies equally to both time and delay.
       * The uncertainty roughly specifies the expected error in true delay (but
       * note, we don't yet define its precise statistical meaning). It's possible
       * for the uncertainty to be 0, for example for trains that are driven under
       * computer timing control.
       * </pre>
       *
       * Protobuf type {@code transit_realtime.TripUpdate.StopTimeEvent}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.ExtendableBuilder<
            com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent, Builder> implements
          // @@protoc_insertion_point(builder_implements:transit_realtime.TripUpdate.StopTimeEvent)
          com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEventOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_StopTimeEvent_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_StopTimeEvent_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.class, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.Builder.class);
        }

        // Construct using com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          delay_ = 0;
          time_ = 0L;
          uncertainty_ = 0;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_StopTimeEvent_descriptor;
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent getDefaultInstanceForType() {
          return com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.getDefaultInstance();
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent build() {
          com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent buildPartial() {
          com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent result = new com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.delay_ = delay_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.time_ = time_;
            to_bitField0_ |= 0x00000002;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.uncertainty_ = uncertainty_;
            to_bitField0_ |= 0x00000004;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent) {
            return mergeFrom((com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent other) {
          if (other == com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.getDefaultInstance()) return this;
          if (other.hasDelay()) {
            setDelay(other.getDelay());
          }
          if (other.hasTime()) {
            setTime(other.getTime());
          }
          if (other.hasUncertainty()) {
            setUncertainty(other.getUncertainty());
          }
          this.mergeExtensionFields(other);
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          if (!extensionsAreInitialized()) {
            return false;
          }
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  delay_ = input.readInt32();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
                case 16: {
                  time_ = input.readInt64();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 16
                case 24: {
                  uncertainty_ = input.readInt32();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 24
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private int delay_ ;
        /**
         * <pre>
         * Delay (in seconds) can be positive (meaning that the vehicle is late) or
         * negative (meaning that the vehicle is ahead of schedule). Delay of 0
         * means that the vehicle is exactly on time.
         * </pre>
         *
         * <code>optional int32 delay = 1;</code>
         * @return Whether the delay field is set.
         */
        @java.lang.Override
        public boolean hasDelay() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * Delay (in seconds) can be positive (meaning that the vehicle is late) or
         * negative (meaning that the vehicle is ahead of schedule). Delay of 0
         * means that the vehicle is exactly on time.
         * </pre>
         *
         * <code>optional int32 delay = 1;</code>
         * @return The delay.
         */
        @java.lang.Override
        public int getDelay() {
          return delay_;
        }
        /**
         * <pre>
         * Delay (in seconds) can be positive (meaning that the vehicle is late) or
         * negative (meaning that the vehicle is ahead of schedule). Delay of 0
         * means that the vehicle is exactly on time.
         * </pre>
         *
         * <code>optional int32 delay = 1;</code>
         * @param value The delay to set.
         * @return This builder for chaining.
         */
        public Builder setDelay(int value) {

          delay_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Delay (in seconds) can be positive (meaning that the vehicle is late) or
         * negative (meaning that the vehicle is ahead of schedule). Delay of 0
         * means that the vehicle is exactly on time.
         * </pre>
         *
         * <code>optional int32 delay = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearDelay() {
          bitField0_ = (bitField0_ & ~0x00000001);
          delay_ = 0;
          onChanged();
          return this;
        }

        private long time_ ;
        /**
         * <pre>
         * Event as absolute time.
         * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
         * UTC).
         * </pre>
         *
         * <code>optional int64 time = 2;</code>
         * @return Whether the time field is set.
         */
        @java.lang.Override
        public boolean hasTime() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * Event as absolute time.
         * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
         * UTC).
         * </pre>
         *
         * <code>optional int64 time = 2;</code>
         * @return The time.
         */
        @java.lang.Override
        public long getTime() {
          return time_;
        }
        /**
         * <pre>
         * Event as absolute time.
         * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
         * UTC).
         * </pre>
         *
         * <code>optional int64 time = 2;</code>
         * @param value The time to set.
         * @return This builder for chaining.
         */
        public Builder setTime(long value) {

          time_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Event as absolute time.
         * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
         * UTC).
         * </pre>
         *
         * <code>optional int64 time = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearTime() {
          bitField0_ = (bitField0_ & ~0x00000002);
          time_ = 0L;
          onChanged();
          return this;
        }

        private int uncertainty_ ;
        /**
         * <pre>
         * If uncertainty is omitted, it is interpreted as unknown.
         * If the prediction is unknown or too uncertain, the delay (or time) field
         * should be empty. In such case, the uncertainty field is ignored.
         * To specify a completely certain prediction, set its uncertainty to 0.
         * </pre>
         *
         * <code>optional int32 uncertainty = 3;</code>
         * @return Whether the uncertainty field is set.
         */
        @java.lang.Override
        public boolean hasUncertainty() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * If uncertainty is omitted, it is interpreted as unknown.
         * If the prediction is unknown or too uncertain, the delay (or time) field
         * should be empty. In such case, the uncertainty field is ignored.
         * To specify a completely certain prediction, set its uncertainty to 0.
         * </pre>
         *
         * <code>optional int32 uncertainty = 3;</code>
         * @return The uncertainty.
         */
        @java.lang.Override
        public int getUncertainty() {
          return uncertainty_;
        }
        /**
         * <pre>
         * If uncertainty is omitted, it is interpreted as unknown.
         * If the prediction is unknown or too uncertain, the delay (or time) field
         * should be empty. In such case, the uncertainty field is ignored.
         * To specify a completely certain prediction, set its uncertainty to 0.
         * </pre>
         *
         * <code>optional int32 uncertainty = 3;</code>
         * @param value The uncertainty to set.
         * @return This builder for chaining.
         */
        public Builder setUncertainty(int value) {

          uncertainty_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * If uncertainty is omitted, it is interpreted as unknown.
         * If the prediction is unknown or too uncertain, the delay (or time) field
         * should be empty. In such case, the uncertainty field is ignored.
         * To specify a completely certain prediction, set its uncertainty to 0.
         * </pre>
         *
         * <code>optional int32 uncertainty = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearUncertainty() {
          bitField0_ = (bitField0_ & ~0x00000004);
          uncertainty_ = 0;
          onChanged();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:transit_realtime.TripUpdate.StopTimeEvent)
      }

      // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate.StopTimeEvent)
      private static final com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent();
      }

      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<StopTimeEvent>
          PARSER = new com.google.protobuf.AbstractParser<StopTimeEvent>() {
        @java.lang.Override
        public StopTimeEvent parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<StopTimeEvent> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<StopTimeEvent> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface StopTimeUpdateOrBuilder extends
        // @@protoc_insertion_point(interface_extends:transit_realtime.TripUpdate.StopTimeUpdate)
        com.google.protobuf.GeneratedMessage.
            ExtendableMessageOrBuilder<StopTimeUpdate> {

      /**
       * <pre>
       * Must be the same as in stop_times.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional uint32 stop_sequence = 1;</code>
       * @return Whether the stopSequence field is set.
       */
      boolean hasStopSequence();
      /**
       * <pre>
       * Must be the same as in stop_times.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional uint32 stop_sequence = 1;</code>
       * @return The stopSequence.
       */
      int getStopSequence();

      /**
       * <pre>
       * Must be the same as in stops.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 4;</code>
       * @return Whether the stopId field is set.
       */
      boolean hasStopId();
      /**
       * <pre>
       * Must be the same as in stops.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 4;</code>
       * @return The stopId.
       */
      java.lang.String getStopId();
      /**
       * <pre>
       * Must be the same as in stops.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 4;</code>
       * @return The bytes for stopId.
       */
      com.google.protobuf.ByteString
          getStopIdBytes();

      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
       * @return Whether the arrival field is set.
       */
      boolean hasArrival();
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
       * @return The arrival.
       */
      com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent getArrival();
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
       */
      com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEventOrBuilder getArrivalOrBuilder();

      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
       * @return Whether the departure field is set.
       */
      boolean hasDeparture();
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
       * @return The departure.
       */
      com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent getDeparture();
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
       */
      com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEventOrBuilder getDepartureOrBuilder();

      /**
       * <pre>
       * Expected occupancy after departure from the given stop.
       * Should be provided only for future stops.
       * In order to provide departure_occupancy_status without either arrival or
       * departure StopTimeEvents, ScheduleRelationship should be set to NO_DATA. 
       * </pre>
       *
       * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus departure_occupancy_status = 7;</code>
       * @return Whether the departureOccupancyStatus field is set.
       */
      boolean hasDepartureOccupancyStatus();
      /**
       * <pre>
       * Expected occupancy after departure from the given stop.
       * Should be provided only for future stops.
       * In order to provide departure_occupancy_status without either arrival or
       * departure StopTimeEvents, ScheduleRelationship should be set to NO_DATA. 
       * </pre>
       *
       * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus departure_occupancy_status = 7;</code>
       * @return The departureOccupancyStatus.
       */
      com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus getDepartureOccupancyStatus();

      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];</code>
       * @return Whether the scheduleRelationship field is set.
       */
      boolean hasScheduleRelationship();
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];</code>
       * @return The scheduleRelationship.
       */
      com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship getScheduleRelationship();

      /**
       * <pre>
       * Realtime updates for certain properties defined within GTFS stop_times.txt
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;</code>
       * @return Whether the stopTimeProperties field is set.
       */
      boolean hasStopTimeProperties();
      /**
       * <pre>
       * Realtime updates for certain properties defined within GTFS stop_times.txt
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;</code>
       * @return The stopTimeProperties.
       */
      com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties getStopTimeProperties();
      /**
       * <pre>
       * Realtime updates for certain properties defined within GTFS stop_times.txt
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;</code>
       */
      com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimePropertiesOrBuilder getStopTimePropertiesOrBuilder();
    }
    /**
     * <pre>
     * Realtime update for arrival and/or departure events for a given stop on a
     * trip. Updates can be supplied for both past and future events.
     * The producer is allowed, although not required, to drop past events.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.TripUpdate.StopTimeUpdate}
     */
    public static final class StopTimeUpdate extends
        com.google.protobuf.GeneratedMessage.ExtendableMessage<
          StopTimeUpdate> implements
        // @@protoc_insertion_point(message_implements:transit_realtime.TripUpdate.StopTimeUpdate)
        StopTimeUpdateOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 28,
          /* patch= */ 3,
          /* suffix= */ "",
          StopTimeUpdate.class.getName());
      }
      // Use StopTimeUpdate.newBuilder() to construct.
      private StopTimeUpdate(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate, ?> builder) {
        super(builder);
      }
      private StopTimeUpdate() {
        stopId_ = "";
        departureOccupancyStatus_ = 0;
        scheduleRelationship_ = 0;
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_StopTimeUpdate_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_StopTimeUpdate_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.class, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.Builder.class);
      }

      /**
       * <pre>
       * The relation between the StopTimeEvents and the static schedule.
       * </pre>
       *
       * Protobuf enum {@code transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship}
       */
      public enum ScheduleRelationship
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <pre>
         * The vehicle is proceeding in accordance with its static schedule of
         * stops, although not necessarily according to the times of the schedule.
         * At least one of arrival and departure must be provided. If the schedule
         * for this stop contains both arrival and departure times then so must
         * this update. Frequency-based trips (GTFS frequencies.txt with exact_times = 0)
         * should not have a SCHEDULED value and should use UNSCHEDULED instead.
         * </pre>
         *
         * <code>SCHEDULED = 0;</code>
         */
        SCHEDULED(0),
        /**
         * <pre>
         * The stop is skipped, i.e., the vehicle will not stop at this stop.
         * Arrival and departure are optional.
         * </pre>
         *
         * <code>SKIPPED = 1;</code>
         */
        SKIPPED(1),
        /**
         * <pre>
         * No StopTimeEvents are given for this stop.
         * The main intention for this value is to give time predictions only for
         * part of a trip, i.e., if the last update for a trip has a NO_DATA
         * specifier, then StopTimeEvents for the rest of the stops in the trip
         * are considered to be unspecified as well.
         * Neither arrival nor departure should be supplied.
         * </pre>
         *
         * <code>NO_DATA = 2;</code>
         */
        NO_DATA(2),
        /**
         * <pre>
         * The vehicle is operating a trip defined in GTFS frequencies.txt with exact_times = 0.
         * This value should not be used for trips that are not defined in GTFS frequencies.txt,
         * or trips in GTFS frequencies.txt with exact_times = 1. Trips containing StopTimeUpdates
         * with ScheduleRelationship=UNSCHEDULED must also set TripDescriptor.ScheduleRelationship=UNSCHEDULED.
         * NOTE: This field is still experimental, and subject to change. It may be
         * formally adopted in the future.
         * </pre>
         *
         * <code>UNSCHEDULED = 3;</code>
         */
        UNSCHEDULED(3),
        ;

        static {
          com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
            com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
            /* major= */ 4,
            /* minor= */ 28,
            /* patch= */ 3,
            /* suffix= */ "",
            ScheduleRelationship.class.getName());
        }
        /**
         * <pre>
         * The vehicle is proceeding in accordance with its static schedule of
         * stops, although not necessarily according to the times of the schedule.
         * At least one of arrival and departure must be provided. If the schedule
         * for this stop contains both arrival and departure times then so must
         * this update. Frequency-based trips (GTFS frequencies.txt with exact_times = 0)
         * should not have a SCHEDULED value and should use UNSCHEDULED instead.
         * </pre>
         *
         * <code>SCHEDULED = 0;</code>
         */
        public static final int SCHEDULED_VALUE = 0;
        /**
         * <pre>
         * The stop is skipped, i.e., the vehicle will not stop at this stop.
         * Arrival and departure are optional.
         * </pre>
         *
         * <code>SKIPPED = 1;</code>
         */
        public static final int SKIPPED_VALUE = 1;
        /**
         * <pre>
         * No StopTimeEvents are given for this stop.
         * The main intention for this value is to give time predictions only for
         * part of a trip, i.e., if the last update for a trip has a NO_DATA
         * specifier, then StopTimeEvents for the rest of the stops in the trip
         * are considered to be unspecified as well.
         * Neither arrival nor departure should be supplied.
         * </pre>
         *
         * <code>NO_DATA = 2;</code>
         */
        public static final int NO_DATA_VALUE = 2;
        /**
         * <pre>
         * The vehicle is operating a trip defined in GTFS frequencies.txt with exact_times = 0.
         * This value should not be used for trips that are not defined in GTFS frequencies.txt,
         * or trips in GTFS frequencies.txt with exact_times = 1. Trips containing StopTimeUpdates
         * with ScheduleRelationship=UNSCHEDULED must also set TripDescriptor.ScheduleRelationship=UNSCHEDULED.
         * NOTE: This field is still experimental, and subject to change. It may be
         * formally adopted in the future.
         * </pre>
         *
         * <code>UNSCHEDULED = 3;</code>
         */
        public static final int UNSCHEDULED_VALUE = 3;


        public final int getNumber() {
          return value;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static ScheduleRelationship valueOf(int value) {
          return forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static ScheduleRelationship forNumber(int value) {
          switch (value) {
            case 0: return SCHEDULED;
            case 1: return SKIPPED;
            case 2: return NO_DATA;
            case 3: return UNSCHEDULED;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<ScheduleRelationship>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            ScheduleRelationship> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<ScheduleRelationship>() {
                public ScheduleRelationship findValueByNumber(int number) {
                  return ScheduleRelationship.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.getDescriptor().getEnumTypes().get(0);
        }

        private static final ScheduleRelationship[] VALUES = values();

        public static ScheduleRelationship valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private ScheduleRelationship(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship)
      }

      public interface StopTimePropertiesOrBuilder extends
          // @@protoc_insertion_point(interface_extends:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties)
          com.google.protobuf.GeneratedMessage.
              ExtendableMessageOrBuilder<StopTimeProperties> {

        /**
         * <pre>
         * Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt.
         * The new assigned_stop_id should not result in a significantly different trip experience for the end user than
         * the stop_id defined in GTFS stop_times.txt. In other words, the end user should not view this new stop_id as an
         * "unusual change" if the new stop was presented within an app without any additional context.
         * For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the
         * same station as the stop originally defined in GTFS stop_times.txt.
         * To assign a stop without providing any real-time arrival or departure predictions, populate this field and set
         * StopTimeUpdate.schedule_relationship = NO_DATA.
         * If this field is populated, it is preferred to omit `StopTimeUpdate.stop_id` and use only `StopTimeUpdate.stop_sequence`. If
         * `StopTimeProperties.assigned_stop_id` and `StopTimeUpdate.stop_id` are populated, `StopTimeUpdate.stop_id` must match `assigned_stop_id`.
         * Platform assignments should be reflected in other GTFS-realtime fields as well
         * (e.g., `VehiclePosition.stop_id`).
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string assigned_stop_id = 1;</code>
         * @return Whether the assignedStopId field is set.
         */
        boolean hasAssignedStopId();
        /**
         * <pre>
         * Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt.
         * The new assigned_stop_id should not result in a significantly different trip experience for the end user than
         * the stop_id defined in GTFS stop_times.txt. In other words, the end user should not view this new stop_id as an
         * "unusual change" if the new stop was presented within an app without any additional context.
         * For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the
         * same station as the stop originally defined in GTFS stop_times.txt.
         * To assign a stop without providing any real-time arrival or departure predictions, populate this field and set
         * StopTimeUpdate.schedule_relationship = NO_DATA.
         * If this field is populated, it is preferred to omit `StopTimeUpdate.stop_id` and use only `StopTimeUpdate.stop_sequence`. If
         * `StopTimeProperties.assigned_stop_id` and `StopTimeUpdate.stop_id` are populated, `StopTimeUpdate.stop_id` must match `assigned_stop_id`.
         * Platform assignments should be reflected in other GTFS-realtime fields as well
         * (e.g., `VehiclePosition.stop_id`).
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string assigned_stop_id = 1;</code>
         * @return The assignedStopId.
         */
        java.lang.String getAssignedStopId();
        /**
         * <pre>
         * Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt.
         * The new assigned_stop_id should not result in a significantly different trip experience for the end user than
         * the stop_id defined in GTFS stop_times.txt. In other words, the end user should not view this new stop_id as an
         * "unusual change" if the new stop was presented within an app without any additional context.
         * For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the
         * same station as the stop originally defined in GTFS stop_times.txt.
         * To assign a stop without providing any real-time arrival or departure predictions, populate this field and set
         * StopTimeUpdate.schedule_relationship = NO_DATA.
         * If this field is populated, it is preferred to omit `StopTimeUpdate.stop_id` and use only `StopTimeUpdate.stop_sequence`. If
         * `StopTimeProperties.assigned_stop_id` and `StopTimeUpdate.stop_id` are populated, `StopTimeUpdate.stop_id` must match `assigned_stop_id`.
         * Platform assignments should be reflected in other GTFS-realtime fields as well
         * (e.g., `VehiclePosition.stop_id`).
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string assigned_stop_id = 1;</code>
         * @return The bytes for assignedStopId.
         */
        com.google.protobuf.ByteString
            getAssignedStopIdBytes();
      }
      /**
       * <pre>
       * Provides the updated values for the stop time.
       * NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * Protobuf type {@code transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties}
       */
      public static final class StopTimeProperties extends
          com.google.protobuf.GeneratedMessage.ExtendableMessage<
            StopTimeProperties> implements
          // @@protoc_insertion_point(message_implements:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties)
          StopTimePropertiesOrBuilder {
      private static final long serialVersionUID = 0L;
        static {
          com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
            com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
            /* major= */ 4,
            /* minor= */ 28,
            /* patch= */ 3,
            /* suffix= */ "",
            StopTimeProperties.class.getName());
        }
        // Use StopTimeProperties.newBuilder() to construct.
        private StopTimeProperties(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties, ?> builder) {
          super(builder);
        }
        private StopTimeProperties() {
          assignedStopId_ = "";
        }

        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_StopTimeUpdate_StopTimeProperties_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_StopTimeUpdate_StopTimeProperties_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties.class, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties.Builder.class);
        }

        private int bitField0_;
        public static final int ASSIGNED_STOP_ID_FIELD_NUMBER = 1;
        @SuppressWarnings("serial")
        private volatile java.lang.Object assignedStopId_ = "";
        /**
         * <pre>
         * Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt.
         * The new assigned_stop_id should not result in a significantly different trip experience for the end user than
         * the stop_id defined in GTFS stop_times.txt. In other words, the end user should not view this new stop_id as an
         * "unusual change" if the new stop was presented within an app without any additional context.
         * For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the
         * same station as the stop originally defined in GTFS stop_times.txt.
         * To assign a stop without providing any real-time arrival or departure predictions, populate this field and set
         * StopTimeUpdate.schedule_relationship = NO_DATA.
         * If this field is populated, it is preferred to omit `StopTimeUpdate.stop_id` and use only `StopTimeUpdate.stop_sequence`. If
         * `StopTimeProperties.assigned_stop_id` and `StopTimeUpdate.stop_id` are populated, `StopTimeUpdate.stop_id` must match `assigned_stop_id`.
         * Platform assignments should be reflected in other GTFS-realtime fields as well
         * (e.g., `VehiclePosition.stop_id`).
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string assigned_stop_id = 1;</code>
         * @return Whether the assignedStopId field is set.
         */
        @java.lang.Override
        public boolean hasAssignedStopId() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt.
         * The new assigned_stop_id should not result in a significantly different trip experience for the end user than
         * the stop_id defined in GTFS stop_times.txt. In other words, the end user should not view this new stop_id as an
         * "unusual change" if the new stop was presented within an app without any additional context.
         * For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the
         * same station as the stop originally defined in GTFS stop_times.txt.
         * To assign a stop without providing any real-time arrival or departure predictions, populate this field and set
         * StopTimeUpdate.schedule_relationship = NO_DATA.
         * If this field is populated, it is preferred to omit `StopTimeUpdate.stop_id` and use only `StopTimeUpdate.stop_sequence`. If
         * `StopTimeProperties.assigned_stop_id` and `StopTimeUpdate.stop_id` are populated, `StopTimeUpdate.stop_id` must match `assigned_stop_id`.
         * Platform assignments should be reflected in other GTFS-realtime fields as well
         * (e.g., `VehiclePosition.stop_id`).
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string assigned_stop_id = 1;</code>
         * @return The assignedStopId.
         */
        @java.lang.Override
        public java.lang.String getAssignedStopId() {
          java.lang.Object ref = assignedStopId_;
          if (ref instanceof java.lang.String) {
            return (java.lang.String) ref;
          } else {
            com.google.protobuf.ByteString bs = 
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              assignedStopId_ = s;
            }
            return s;
          }
        }
        /**
         * <pre>
         * Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt.
         * The new assigned_stop_id should not result in a significantly different trip experience for the end user than
         * the stop_id defined in GTFS stop_times.txt. In other words, the end user should not view this new stop_id as an
         * "unusual change" if the new stop was presented within an app without any additional context.
         * For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the
         * same station as the stop originally defined in GTFS stop_times.txt.
         * To assign a stop without providing any real-time arrival or departure predictions, populate this field and set
         * StopTimeUpdate.schedule_relationship = NO_DATA.
         * If this field is populated, it is preferred to omit `StopTimeUpdate.stop_id` and use only `StopTimeUpdate.stop_sequence`. If
         * `StopTimeProperties.assigned_stop_id` and `StopTimeUpdate.stop_id` are populated, `StopTimeUpdate.stop_id` must match `assigned_stop_id`.
         * Platform assignments should be reflected in other GTFS-realtime fields as well
         * (e.g., `VehiclePosition.stop_id`).
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string assigned_stop_id = 1;</code>
         * @return The bytes for assignedStopId.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getAssignedStopIdBytes() {
          java.lang.Object ref = assignedStopId_;
          if (ref instanceof java.lang.String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            assignedStopId_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }

        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return true;
          if (isInitialized == 0) return false;

          if (!extensionsAreInitialized()) {
            memoizedIsInitialized = 0;
            return false;
          }
          memoizedIsInitialized = 1;
          return true;
        }

        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
                            throws java.io.IOException {
          com.google.protobuf.GeneratedMessage
            .ExtendableMessage.ExtensionSerializer
              extensionWriter = newExtensionSerializer();
          if (((bitField0_ & 0x00000001) != 0)) {
            com.google.protobuf.GeneratedMessage.writeString(output, 1, assignedStopId_);
          }
          extensionWriter.writeUntil(10000, output);
          getUnknownFields().writeTo(output);
        }

        @java.lang.Override
        public int getSerializedSize() {
          int size = memoizedSize;
          if (size != -1) return size;

          size = 0;
          if (((bitField0_ & 0x00000001) != 0)) {
            size += com.google.protobuf.GeneratedMessage.computeStringSize(1, assignedStopId_);
          }
          size += extensionsSerializedSize();
          size += getUnknownFields().getSerializedSize();
          memoizedSize = size;
          return size;
        }

        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
          if (obj == this) {
           return true;
          }
          if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties)) {
            return super.equals(obj);
          }
          com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties other = (com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties) obj;

          if (hasAssignedStopId() != other.hasAssignedStopId()) return false;
          if (hasAssignedStopId()) {
            if (!getAssignedStopId()
                .equals(other.getAssignedStopId())) return false;
          }
          if (!getUnknownFields().equals(other.getUnknownFields())) return false;
          if (!getExtensionFields().equals(other.getExtensionFields()))
            return false;
          return true;
        }

        @java.lang.Override
        public int hashCode() {
          if (memoizedHashCode != 0) {
            return memoizedHashCode;
          }
          int hash = 41;
          hash = (19 * hash) + getDescriptor().hashCode();
          if (hasAssignedStopId()) {
            hash = (37 * hash) + ASSIGNED_STOP_ID_FIELD_NUMBER;
            hash = (53 * hash) + getAssignedStopId().hashCode();
          }
          hash = hashFields(hash, getExtensionFields());
          hash = (29 * hash) + getUnknownFields().hashCode();
          memoizedHashCode = hash;
          return hash;
        }

        public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data);
        }
        public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data, extensionRegistry);
        }
        public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data);
        }
        public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data, extensionRegistry);
        }
        public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data);
        }
        public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data, extensionRegistry);
        }
        public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties parseFrom(java.io.InputStream input)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessage
              .parseWithIOException(PARSER, input);
        }
        public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessage
              .parseWithIOException(PARSER, input, extensionRegistry);
        }

        public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessage
              .parseDelimitedWithIOException(PARSER, input);
        }

        public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessage
              .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessage
              .parseWithIOException(PARSER, input);
        }
        public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessage
              .parseWithIOException(PARSER, input, extensionRegistry);
        }

        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
          return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties prototype) {
          return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
          return this == DEFAULT_INSTANCE
              ? new Builder() : new Builder().mergeFrom(this);
        }

        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          Builder builder = new Builder(parent);
          return builder;
        }
        /**
         * <pre>
         * Provides the updated values for the stop time.
         * NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * Protobuf type {@code transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.ExtendableBuilder<
              com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties, Builder> implements
            // @@protoc_insertion_point(builder_implements:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties)
            com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimePropertiesOrBuilder {
          public static final com.google.protobuf.Descriptors.Descriptor
              getDescriptor() {
            return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_StopTimeUpdate_StopTimeProperties_descriptor;
          }

          @java.lang.Override
          protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
              internalGetFieldAccessorTable() {
            return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_StopTimeUpdate_StopTimeProperties_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties.class, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties.Builder.class);
          }

          // Construct using com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties.newBuilder()
          private Builder() {

          }

          private Builder(
              com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            super(parent);

          }
          @java.lang.Override
          public Builder clear() {
            super.clear();
            bitField0_ = 0;
            assignedStopId_ = "";
            return this;
          }

          @java.lang.Override
          public com.google.protobuf.Descriptors.Descriptor
              getDescriptorForType() {
            return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_StopTimeUpdate_StopTimeProperties_descriptor;
          }

          @java.lang.Override
          public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties getDefaultInstanceForType() {
            return com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties.getDefaultInstance();
          }

          @java.lang.Override
          public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties build() {
            com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties result = buildPartial();
            if (!result.isInitialized()) {
              throw newUninitializedMessageException(result);
            }
            return result;
          }

          @java.lang.Override
          public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties buildPartial() {
            com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties result = new com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties(this);
            if (bitField0_ != 0) { buildPartial0(result); }
            onBuilt();
            return result;
          }

          private void buildPartial0(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties result) {
            int from_bitField0_ = bitField0_;
            int to_bitField0_ = 0;
            if (((from_bitField0_ & 0x00000001) != 0)) {
              result.assignedStopId_ = assignedStopId_;
              to_bitField0_ |= 0x00000001;
            }
            result.bitField0_ |= to_bitField0_;
          }

          @java.lang.Override
          public Builder mergeFrom(com.google.protobuf.Message other) {
            if (other instanceof com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties) {
              return mergeFrom((com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties)other);
            } else {
              super.mergeFrom(other);
              return this;
            }
          }

          public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties other) {
            if (other == com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties.getDefaultInstance()) return this;
            if (other.hasAssignedStopId()) {
              assignedStopId_ = other.assignedStopId_;
              bitField0_ |= 0x00000001;
              onChanged();
            }
            this.mergeExtensionFields(other);
            this.mergeUnknownFields(other.getUnknownFields());
            onChanged();
            return this;
          }

          @java.lang.Override
          public final boolean isInitialized() {
            if (!extensionsAreInitialized()) {
              return false;
            }
            return true;
          }

          @java.lang.Override
          public Builder mergeFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
            if (extensionRegistry == null) {
              throw new java.lang.NullPointerException();
            }
            try {
              boolean done = false;
              while (!done) {
                int tag = input.readTag();
                switch (tag) {
                  case 0:
                    done = true;
                    break;
                  case 10: {
                    assignedStopId_ = input.readBytes();
                    bitField0_ |= 0x00000001;
                    break;
                  } // case 10
                  default: {
                    if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                      done = true; // was an endgroup tag
                    }
                    break;
                  } // default:
                } // switch (tag)
              } // while (!done)
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.unwrapIOException();
            } finally {
              onChanged();
            } // finally
            return this;
          }
          private int bitField0_;

          private java.lang.Object assignedStopId_ = "";
          /**
           * <pre>
           * Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt.
           * The new assigned_stop_id should not result in a significantly different trip experience for the end user than
           * the stop_id defined in GTFS stop_times.txt. In other words, the end user should not view this new stop_id as an
           * "unusual change" if the new stop was presented within an app without any additional context.
           * For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the
           * same station as the stop originally defined in GTFS stop_times.txt.
           * To assign a stop without providing any real-time arrival or departure predictions, populate this field and set
           * StopTimeUpdate.schedule_relationship = NO_DATA.
           * If this field is populated, it is preferred to omit `StopTimeUpdate.stop_id` and use only `StopTimeUpdate.stop_sequence`. If
           * `StopTimeProperties.assigned_stop_id` and `StopTimeUpdate.stop_id` are populated, `StopTimeUpdate.stop_id` must match `assigned_stop_id`.
           * Platform assignments should be reflected in other GTFS-realtime fields as well
           * (e.g., `VehiclePosition.stop_id`).
           * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
           * </pre>
           *
           * <code>optional string assigned_stop_id = 1;</code>
           * @return Whether the assignedStopId field is set.
           */
          public boolean hasAssignedStopId() {
            return ((bitField0_ & 0x00000001) != 0);
          }
          /**
           * <pre>
           * Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt.
           * The new assigned_stop_id should not result in a significantly different trip experience for the end user than
           * the stop_id defined in GTFS stop_times.txt. In other words, the end user should not view this new stop_id as an
           * "unusual change" if the new stop was presented within an app without any additional context.
           * For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the
           * same station as the stop originally defined in GTFS stop_times.txt.
           * To assign a stop without providing any real-time arrival or departure predictions, populate this field and set
           * StopTimeUpdate.schedule_relationship = NO_DATA.
           * If this field is populated, it is preferred to omit `StopTimeUpdate.stop_id` and use only `StopTimeUpdate.stop_sequence`. If
           * `StopTimeProperties.assigned_stop_id` and `StopTimeUpdate.stop_id` are populated, `StopTimeUpdate.stop_id` must match `assigned_stop_id`.
           * Platform assignments should be reflected in other GTFS-realtime fields as well
           * (e.g., `VehiclePosition.stop_id`).
           * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
           * </pre>
           *
           * <code>optional string assigned_stop_id = 1;</code>
           * @return The assignedStopId.
           */
          public java.lang.String getAssignedStopId() {
            java.lang.Object ref = assignedStopId_;
            if (!(ref instanceof java.lang.String)) {
              com.google.protobuf.ByteString bs =
                  (com.google.protobuf.ByteString) ref;
              java.lang.String s = bs.toStringUtf8();
              if (bs.isValidUtf8()) {
                assignedStopId_ = s;
              }
              return s;
            } else {
              return (java.lang.String) ref;
            }
          }
          /**
           * <pre>
           * Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt.
           * The new assigned_stop_id should not result in a significantly different trip experience for the end user than
           * the stop_id defined in GTFS stop_times.txt. In other words, the end user should not view this new stop_id as an
           * "unusual change" if the new stop was presented within an app without any additional context.
           * For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the
           * same station as the stop originally defined in GTFS stop_times.txt.
           * To assign a stop without providing any real-time arrival or departure predictions, populate this field and set
           * StopTimeUpdate.schedule_relationship = NO_DATA.
           * If this field is populated, it is preferred to omit `StopTimeUpdate.stop_id` and use only `StopTimeUpdate.stop_sequence`. If
           * `StopTimeProperties.assigned_stop_id` and `StopTimeUpdate.stop_id` are populated, `StopTimeUpdate.stop_id` must match `assigned_stop_id`.
           * Platform assignments should be reflected in other GTFS-realtime fields as well
           * (e.g., `VehiclePosition.stop_id`).
           * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
           * </pre>
           *
           * <code>optional string assigned_stop_id = 1;</code>
           * @return The bytes for assignedStopId.
           */
          public com.google.protobuf.ByteString
              getAssignedStopIdBytes() {
            java.lang.Object ref = assignedStopId_;
            if (ref instanceof String) {
              com.google.protobuf.ByteString b = 
                  com.google.protobuf.ByteString.copyFromUtf8(
                      (java.lang.String) ref);
              assignedStopId_ = b;
              return b;
            } else {
              return (com.google.protobuf.ByteString) ref;
            }
          }
          /**
           * <pre>
           * Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt.
           * The new assigned_stop_id should not result in a significantly different trip experience for the end user than
           * the stop_id defined in GTFS stop_times.txt. In other words, the end user should not view this new stop_id as an
           * "unusual change" if the new stop was presented within an app without any additional context.
           * For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the
           * same station as the stop originally defined in GTFS stop_times.txt.
           * To assign a stop without providing any real-time arrival or departure predictions, populate this field and set
           * StopTimeUpdate.schedule_relationship = NO_DATA.
           * If this field is populated, it is preferred to omit `StopTimeUpdate.stop_id` and use only `StopTimeUpdate.stop_sequence`. If
           * `StopTimeProperties.assigned_stop_id` and `StopTimeUpdate.stop_id` are populated, `StopTimeUpdate.stop_id` must match `assigned_stop_id`.
           * Platform assignments should be reflected in other GTFS-realtime fields as well
           * (e.g., `VehiclePosition.stop_id`).
           * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
           * </pre>
           *
           * <code>optional string assigned_stop_id = 1;</code>
           * @param value The assignedStopId to set.
           * @return This builder for chaining.
           */
          public Builder setAssignedStopId(
              java.lang.String value) {
            if (value == null) { throw new NullPointerException(); }
            assignedStopId_ = value;
            bitField0_ |= 0x00000001;
            onChanged();
            return this;
          }
          /**
           * <pre>
           * Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt.
           * The new assigned_stop_id should not result in a significantly different trip experience for the end user than
           * the stop_id defined in GTFS stop_times.txt. In other words, the end user should not view this new stop_id as an
           * "unusual change" if the new stop was presented within an app without any additional context.
           * For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the
           * same station as the stop originally defined in GTFS stop_times.txt.
           * To assign a stop without providing any real-time arrival or departure predictions, populate this field and set
           * StopTimeUpdate.schedule_relationship = NO_DATA.
           * If this field is populated, it is preferred to omit `StopTimeUpdate.stop_id` and use only `StopTimeUpdate.stop_sequence`. If
           * `StopTimeProperties.assigned_stop_id` and `StopTimeUpdate.stop_id` are populated, `StopTimeUpdate.stop_id` must match `assigned_stop_id`.
           * Platform assignments should be reflected in other GTFS-realtime fields as well
           * (e.g., `VehiclePosition.stop_id`).
           * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
           * </pre>
           *
           * <code>optional string assigned_stop_id = 1;</code>
           * @return This builder for chaining.
           */
          public Builder clearAssignedStopId() {
            assignedStopId_ = getDefaultInstance().getAssignedStopId();
            bitField0_ = (bitField0_ & ~0x00000001);
            onChanged();
            return this;
          }
          /**
           * <pre>
           * Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt.
           * The new assigned_stop_id should not result in a significantly different trip experience for the end user than
           * the stop_id defined in GTFS stop_times.txt. In other words, the end user should not view this new stop_id as an
           * "unusual change" if the new stop was presented within an app without any additional context.
           * For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the
           * same station as the stop originally defined in GTFS stop_times.txt.
           * To assign a stop without providing any real-time arrival or departure predictions, populate this field and set
           * StopTimeUpdate.schedule_relationship = NO_DATA.
           * If this field is populated, it is preferred to omit `StopTimeUpdate.stop_id` and use only `StopTimeUpdate.stop_sequence`. If
           * `StopTimeProperties.assigned_stop_id` and `StopTimeUpdate.stop_id` are populated, `StopTimeUpdate.stop_id` must match `assigned_stop_id`.
           * Platform assignments should be reflected in other GTFS-realtime fields as well
           * (e.g., `VehiclePosition.stop_id`).
           * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
           * </pre>
           *
           * <code>optional string assigned_stop_id = 1;</code>
           * @param value The bytes for assignedStopId to set.
           * @return This builder for chaining.
           */
          public Builder setAssignedStopIdBytes(
              com.google.protobuf.ByteString value) {
            if (value == null) { throw new NullPointerException(); }
            assignedStopId_ = value;
            bitField0_ |= 0x00000001;
            onChanged();
            return this;
          }

          // @@protoc_insertion_point(builder_scope:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties)
        }

        // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties)
        private static final com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties DEFAULT_INSTANCE;
        static {
          DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties();
        }

        public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties getDefaultInstance() {
          return DEFAULT_INSTANCE;
        }

        private static final com.google.protobuf.Parser<StopTimeProperties>
            PARSER = new com.google.protobuf.AbstractParser<StopTimeProperties>() {
          @java.lang.Override
          public StopTimeProperties parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

        public static com.google.protobuf.Parser<StopTimeProperties> parser() {
          return PARSER;
        }

        @java.lang.Override
        public com.google.protobuf.Parser<StopTimeProperties> getParserForType() {
          return PARSER;
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties getDefaultInstanceForType() {
          return DEFAULT_INSTANCE;
        }

      }

      private int bitField0_;
      public static final int STOP_SEQUENCE_FIELD_NUMBER = 1;
      private int stopSequence_ = 0;
      /**
       * <pre>
       * Must be the same as in stop_times.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional uint32 stop_sequence = 1;</code>
       * @return Whether the stopSequence field is set.
       */
      @java.lang.Override
      public boolean hasStopSequence() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Must be the same as in stop_times.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional uint32 stop_sequence = 1;</code>
       * @return The stopSequence.
       */
      @java.lang.Override
      public int getStopSequence() {
        return stopSequence_;
      }

      public static final int STOP_ID_FIELD_NUMBER = 4;
      @SuppressWarnings("serial")
      private volatile java.lang.Object stopId_ = "";
      /**
       * <pre>
       * Must be the same as in stops.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 4;</code>
       * @return Whether the stopId field is set.
       */
      @java.lang.Override
      public boolean hasStopId() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Must be the same as in stops.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 4;</code>
       * @return The stopId.
       */
      @java.lang.Override
      public java.lang.String getStopId() {
        java.lang.Object ref = stopId_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            stopId_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * Must be the same as in stops.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 4;</code>
       * @return The bytes for stopId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getStopIdBytes() {
        java.lang.Object ref = stopId_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          stopId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int ARRIVAL_FIELD_NUMBER = 2;
      private com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent arrival_;
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
       * @return Whether the arrival field is set.
       */
      @java.lang.Override
      public boolean hasArrival() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
       * @return The arrival.
       */
      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent getArrival() {
        return arrival_ == null ? com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.getDefaultInstance() : arrival_;
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
       */
      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEventOrBuilder getArrivalOrBuilder() {
        return arrival_ == null ? com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.getDefaultInstance() : arrival_;
      }

      public static final int DEPARTURE_FIELD_NUMBER = 3;
      private com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent departure_;
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
       * @return Whether the departure field is set.
       */
      @java.lang.Override
      public boolean hasDeparture() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
       * @return The departure.
       */
      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent getDeparture() {
        return departure_ == null ? com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.getDefaultInstance() : departure_;
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
       */
      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEventOrBuilder getDepartureOrBuilder() {
        return departure_ == null ? com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.getDefaultInstance() : departure_;
      }

      public static final int DEPARTURE_OCCUPANCY_STATUS_FIELD_NUMBER = 7;
      private int departureOccupancyStatus_ = 0;
      /**
       * <pre>
       * Expected occupancy after departure from the given stop.
       * Should be provided only for future stops.
       * In order to provide departure_occupancy_status without either arrival or
       * departure StopTimeEvents, ScheduleRelationship should be set to NO_DATA. 
       * </pre>
       *
       * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus departure_occupancy_status = 7;</code>
       * @return Whether the departureOccupancyStatus field is set.
       */
      @java.lang.Override public boolean hasDepartureOccupancyStatus() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Expected occupancy after departure from the given stop.
       * Should be provided only for future stops.
       * In order to provide departure_occupancy_status without either arrival or
       * departure StopTimeEvents, ScheduleRelationship should be set to NO_DATA. 
       * </pre>
       *
       * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus departure_occupancy_status = 7;</code>
       * @return The departureOccupancyStatus.
       */
      @java.lang.Override public com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus getDepartureOccupancyStatus() {
        com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus result = com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus.forNumber(departureOccupancyStatus_);
        return result == null ? com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus.EMPTY : result;
      }

      public static final int SCHEDULE_RELATIONSHIP_FIELD_NUMBER = 5;
      private int scheduleRelationship_ = 0;
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];</code>
       * @return Whether the scheduleRelationship field is set.
       */
      @java.lang.Override public boolean hasScheduleRelationship() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];</code>
       * @return The scheduleRelationship.
       */
      @java.lang.Override public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship getScheduleRelationship() {
        com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship result = com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.forNumber(scheduleRelationship_);
        return result == null ? com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.SCHEDULED : result;
      }

      public static final int STOP_TIME_PROPERTIES_FIELD_NUMBER = 6;
      private com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties stopTimeProperties_;
      /**
       * <pre>
       * Realtime updates for certain properties defined within GTFS stop_times.txt
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;</code>
       * @return Whether the stopTimeProperties field is set.
       */
      @java.lang.Override
      public boolean hasStopTimeProperties() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Realtime updates for certain properties defined within GTFS stop_times.txt
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;</code>
       * @return The stopTimeProperties.
       */
      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties getStopTimeProperties() {
        return stopTimeProperties_ == null ? com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties.getDefaultInstance() : stopTimeProperties_;
      }
      /**
       * <pre>
       * Realtime updates for certain properties defined within GTFS stop_times.txt
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;</code>
       */
      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimePropertiesOrBuilder getStopTimePropertiesOrBuilder() {
        return stopTimeProperties_ == null ? com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties.getDefaultInstance() : stopTimeProperties_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        if (hasArrival()) {
          if (!getArrival().isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
          }
        }
        if (hasDeparture()) {
          if (!getDeparture().isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
          }
        }
        if (hasStopTimeProperties()) {
          if (!getStopTimeProperties().isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
          }
        }
        if (!extensionsAreInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        com.google.protobuf.GeneratedMessage
          .ExtendableMessage.ExtensionSerializer
            extensionWriter = newExtensionSerializer();
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeUInt32(1, stopSequence_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          output.writeMessage(2, getArrival());
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          output.writeMessage(3, getDeparture());
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          com.google.protobuf.GeneratedMessage.writeString(output, 4, stopId_);
        }
        if (((bitField0_ & 0x00000020) != 0)) {
          output.writeEnum(5, scheduleRelationship_);
        }
        if (((bitField0_ & 0x00000040) != 0)) {
          output.writeMessage(6, getStopTimeProperties());
        }
        if (((bitField0_ & 0x00000010) != 0)) {
          output.writeEnum(7, departureOccupancyStatus_);
        }
        extensionWriter.writeUntil(10000, output);
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(1, stopSequence_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, getArrival());
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(3, getDeparture());
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.GeneratedMessage.computeStringSize(4, stopId_);
        }
        if (((bitField0_ & 0x00000020) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(5, scheduleRelationship_);
        }
        if (((bitField0_ & 0x00000040) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(6, getStopTimeProperties());
        }
        if (((bitField0_ & 0x00000010) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(7, departureOccupancyStatus_);
        }
        size += extensionsSerializedSize();
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate)) {
          return super.equals(obj);
        }
        com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate other = (com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate) obj;

        if (hasStopSequence() != other.hasStopSequence()) return false;
        if (hasStopSequence()) {
          if (getStopSequence()
              != other.getStopSequence()) return false;
        }
        if (hasStopId() != other.hasStopId()) return false;
        if (hasStopId()) {
          if (!getStopId()
              .equals(other.getStopId())) return false;
        }
        if (hasArrival() != other.hasArrival()) return false;
        if (hasArrival()) {
          if (!getArrival()
              .equals(other.getArrival())) return false;
        }
        if (hasDeparture() != other.hasDeparture()) return false;
        if (hasDeparture()) {
          if (!getDeparture()
              .equals(other.getDeparture())) return false;
        }
        if (hasDepartureOccupancyStatus() != other.hasDepartureOccupancyStatus()) return false;
        if (hasDepartureOccupancyStatus()) {
          if (departureOccupancyStatus_ != other.departureOccupancyStatus_) return false;
        }
        if (hasScheduleRelationship() != other.hasScheduleRelationship()) return false;
        if (hasScheduleRelationship()) {
          if (scheduleRelationship_ != other.scheduleRelationship_) return false;
        }
        if (hasStopTimeProperties() != other.hasStopTimeProperties()) return false;
        if (hasStopTimeProperties()) {
          if (!getStopTimeProperties()
              .equals(other.getStopTimeProperties())) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        if (!getExtensionFields().equals(other.getExtensionFields()))
          return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasStopSequence()) {
          hash = (37 * hash) + STOP_SEQUENCE_FIELD_NUMBER;
          hash = (53 * hash) + getStopSequence();
        }
        if (hasStopId()) {
          hash = (37 * hash) + STOP_ID_FIELD_NUMBER;
          hash = (53 * hash) + getStopId().hashCode();
        }
        if (hasArrival()) {
          hash = (37 * hash) + ARRIVAL_FIELD_NUMBER;
          hash = (53 * hash) + getArrival().hashCode();
        }
        if (hasDeparture()) {
          hash = (37 * hash) + DEPARTURE_FIELD_NUMBER;
          hash = (53 * hash) + getDeparture().hashCode();
        }
        if (hasDepartureOccupancyStatus()) {
          hash = (37 * hash) + DEPARTURE_OCCUPANCY_STATUS_FIELD_NUMBER;
          hash = (53 * hash) + departureOccupancyStatus_;
        }
        if (hasScheduleRelationship()) {
          hash = (37 * hash) + SCHEDULE_RELATIONSHIP_FIELD_NUMBER;
          hash = (53 * hash) + scheduleRelationship_;
        }
        if (hasStopTimeProperties()) {
          hash = (37 * hash) + STOP_TIME_PROPERTIES_FIELD_NUMBER;
          hash = (53 * hash) + getStopTimeProperties().hashCode();
        }
        hash = hashFields(hash, getExtensionFields());
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Realtime update for arrival and/or departure events for a given stop on a
       * trip. Updates can be supplied for both past and future events.
       * The producer is allowed, although not required, to drop past events.
       * </pre>
       *
       * Protobuf type {@code transit_realtime.TripUpdate.StopTimeUpdate}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.ExtendableBuilder<
            com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate, Builder> implements
          // @@protoc_insertion_point(builder_implements:transit_realtime.TripUpdate.StopTimeUpdate)
          com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdateOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_StopTimeUpdate_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_StopTimeUpdate_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.class, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.Builder.class);
        }

        // Construct using com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessage
                  .alwaysUseFieldBuilders) {
            getArrivalFieldBuilder();
            getDepartureFieldBuilder();
            getStopTimePropertiesFieldBuilder();
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          stopSequence_ = 0;
          stopId_ = "";
          arrival_ = null;
          if (arrivalBuilder_ != null) {
            arrivalBuilder_.dispose();
            arrivalBuilder_ = null;
          }
          departure_ = null;
          if (departureBuilder_ != null) {
            departureBuilder_.dispose();
            departureBuilder_ = null;
          }
          departureOccupancyStatus_ = 0;
          scheduleRelationship_ = 0;
          stopTimeProperties_ = null;
          if (stopTimePropertiesBuilder_ != null) {
            stopTimePropertiesBuilder_.dispose();
            stopTimePropertiesBuilder_ = null;
          }
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_StopTimeUpdate_descriptor;
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate getDefaultInstanceForType() {
          return com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.getDefaultInstance();
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate build() {
          com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate buildPartial() {
          com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate result = new com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.stopSequence_ = stopSequence_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.stopId_ = stopId_;
            to_bitField0_ |= 0x00000002;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.arrival_ = arrivalBuilder_ == null
                ? arrival_
                : arrivalBuilder_.build();
            to_bitField0_ |= 0x00000004;
          }
          if (((from_bitField0_ & 0x00000008) != 0)) {
            result.departure_ = departureBuilder_ == null
                ? departure_
                : departureBuilder_.build();
            to_bitField0_ |= 0x00000008;
          }
          if (((from_bitField0_ & 0x00000010) != 0)) {
            result.departureOccupancyStatus_ = departureOccupancyStatus_;
            to_bitField0_ |= 0x00000010;
          }
          if (((from_bitField0_ & 0x00000020) != 0)) {
            result.scheduleRelationship_ = scheduleRelationship_;
            to_bitField0_ |= 0x00000020;
          }
          if (((from_bitField0_ & 0x00000040) != 0)) {
            result.stopTimeProperties_ = stopTimePropertiesBuilder_ == null
                ? stopTimeProperties_
                : stopTimePropertiesBuilder_.build();
            to_bitField0_ |= 0x00000040;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate) {
            return mergeFrom((com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate other) {
          if (other == com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.getDefaultInstance()) return this;
          if (other.hasStopSequence()) {
            setStopSequence(other.getStopSequence());
          }
          if (other.hasStopId()) {
            stopId_ = other.stopId_;
            bitField0_ |= 0x00000002;
            onChanged();
          }
          if (other.hasArrival()) {
            mergeArrival(other.getArrival());
          }
          if (other.hasDeparture()) {
            mergeDeparture(other.getDeparture());
          }
          if (other.hasDepartureOccupancyStatus()) {
            setDepartureOccupancyStatus(other.getDepartureOccupancyStatus());
          }
          if (other.hasScheduleRelationship()) {
            setScheduleRelationship(other.getScheduleRelationship());
          }
          if (other.hasStopTimeProperties()) {
            mergeStopTimeProperties(other.getStopTimeProperties());
          }
          this.mergeExtensionFields(other);
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          if (hasArrival()) {
            if (!getArrival().isInitialized()) {
              return false;
            }
          }
          if (hasDeparture()) {
            if (!getDeparture().isInitialized()) {
              return false;
            }
          }
          if (hasStopTimeProperties()) {
            if (!getStopTimeProperties().isInitialized()) {
              return false;
            }
          }
          if (!extensionsAreInitialized()) {
            return false;
          }
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  stopSequence_ = input.readUInt32();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
                case 18: {
                  input.readMessage(
                      getArrivalFieldBuilder().getBuilder(),
                      extensionRegistry);
                  bitField0_ |= 0x00000004;
                  break;
                } // case 18
                case 26: {
                  input.readMessage(
                      getDepartureFieldBuilder().getBuilder(),
                      extensionRegistry);
                  bitField0_ |= 0x00000008;
                  break;
                } // case 26
                case 34: {
                  stopId_ = input.readBytes();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 34
                case 40: {
                  int tmpRaw = input.readEnum();
                  com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship tmpValue =
                      com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(5, tmpRaw);
                  } else {
                    scheduleRelationship_ = tmpRaw;
                    bitField0_ |= 0x00000020;
                  }
                  break;
                } // case 40
                case 50: {
                  input.readMessage(
                      getStopTimePropertiesFieldBuilder().getBuilder(),
                      extensionRegistry);
                  bitField0_ |= 0x00000040;
                  break;
                } // case 50
                case 56: {
                  int tmpRaw = input.readEnum();
                  com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus tmpValue =
                      com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(7, tmpRaw);
                  } else {
                    departureOccupancyStatus_ = tmpRaw;
                    bitField0_ |= 0x00000010;
                  }
                  break;
                } // case 56
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private int stopSequence_ ;
        /**
         * <pre>
         * Must be the same as in stop_times.txt in the corresponding GTFS feed.
         * </pre>
         *
         * <code>optional uint32 stop_sequence = 1;</code>
         * @return Whether the stopSequence field is set.
         */
        @java.lang.Override
        public boolean hasStopSequence() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * Must be the same as in stop_times.txt in the corresponding GTFS feed.
         * </pre>
         *
         * <code>optional uint32 stop_sequence = 1;</code>
         * @return The stopSequence.
         */
        @java.lang.Override
        public int getStopSequence() {
          return stopSequence_;
        }
        /**
         * <pre>
         * Must be the same as in stop_times.txt in the corresponding GTFS feed.
         * </pre>
         *
         * <code>optional uint32 stop_sequence = 1;</code>
         * @param value The stopSequence to set.
         * @return This builder for chaining.
         */
        public Builder setStopSequence(int value) {

          stopSequence_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Must be the same as in stop_times.txt in the corresponding GTFS feed.
         * </pre>
         *
         * <code>optional uint32 stop_sequence = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearStopSequence() {
          bitField0_ = (bitField0_ & ~0x00000001);
          stopSequence_ = 0;
          onChanged();
          return this;
        }

        private java.lang.Object stopId_ = "";
        /**
         * <pre>
         * Must be the same as in stops.txt in the corresponding GTFS feed.
         * </pre>
         *
         * <code>optional string stop_id = 4;</code>
         * @return Whether the stopId field is set.
         */
        public boolean hasStopId() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * Must be the same as in stops.txt in the corresponding GTFS feed.
         * </pre>
         *
         * <code>optional string stop_id = 4;</code>
         * @return The stopId.
         */
        public java.lang.String getStopId() {
          java.lang.Object ref = stopId_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              stopId_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * Must be the same as in stops.txt in the corresponding GTFS feed.
         * </pre>
         *
         * <code>optional string stop_id = 4;</code>
         * @return The bytes for stopId.
         */
        public com.google.protobuf.ByteString
            getStopIdBytes() {
          java.lang.Object ref = stopId_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            stopId_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * Must be the same as in stops.txt in the corresponding GTFS feed.
         * </pre>
         *
         * <code>optional string stop_id = 4;</code>
         * @param value The stopId to set.
         * @return This builder for chaining.
         */
        public Builder setStopId(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          stopId_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Must be the same as in stops.txt in the corresponding GTFS feed.
         * </pre>
         *
         * <code>optional string stop_id = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearStopId() {
          stopId_ = getDefaultInstance().getStopId();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Must be the same as in stops.txt in the corresponding GTFS feed.
         * </pre>
         *
         * <code>optional string stop_id = 4;</code>
         * @param value The bytes for stopId to set.
         * @return This builder for chaining.
         */
        public Builder setStopIdBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          stopId_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }

        private com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent arrival_;
        private com.google.protobuf.SingleFieldBuilder<
            com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.Builder, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEventOrBuilder> arrivalBuilder_;
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
         * @return Whether the arrival field is set.
         */
        public boolean hasArrival() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
         * @return The arrival.
         */
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent getArrival() {
          if (arrivalBuilder_ == null) {
            return arrival_ == null ? com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.getDefaultInstance() : arrival_;
          } else {
            return arrivalBuilder_.getMessage();
          }
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
         */
        public Builder setArrival(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent value) {
          if (arrivalBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            arrival_ = value;
          } else {
            arrivalBuilder_.setMessage(value);
          }
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
         */
        public Builder setArrival(
            com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.Builder builderForValue) {
          if (arrivalBuilder_ == null) {
            arrival_ = builderForValue.build();
          } else {
            arrivalBuilder_.setMessage(builderForValue.build());
          }
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
         */
        public Builder mergeArrival(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent value) {
          if (arrivalBuilder_ == null) {
            if (((bitField0_ & 0x00000004) != 0) &&
              arrival_ != null &&
              arrival_ != com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.getDefaultInstance()) {
              getArrivalBuilder().mergeFrom(value);
            } else {
              arrival_ = value;
            }
          } else {
            arrivalBuilder_.mergeFrom(value);
          }
          if (arrival_ != null) {
            bitField0_ |= 0x00000004;
            onChanged();
          }
          return this;
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
         */
        public Builder clearArrival() {
          bitField0_ = (bitField0_ & ~0x00000004);
          arrival_ = null;
          if (arrivalBuilder_ != null) {
            arrivalBuilder_.dispose();
            arrivalBuilder_ = null;
          }
          onChanged();
          return this;
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
         */
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.Builder getArrivalBuilder() {
          bitField0_ |= 0x00000004;
          onChanged();
          return getArrivalFieldBuilder().getBuilder();
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
         */
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEventOrBuilder getArrivalOrBuilder() {
          if (arrivalBuilder_ != null) {
            return arrivalBuilder_.getMessageOrBuilder();
          } else {
            return arrival_ == null ?
                com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.getDefaultInstance() : arrival_;
          }
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
         */
        private com.google.protobuf.SingleFieldBuilder<
            com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.Builder, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEventOrBuilder> 
            getArrivalFieldBuilder() {
          if (arrivalBuilder_ == null) {
            arrivalBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.Builder, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEventOrBuilder>(
                    getArrival(),
                    getParentForChildren(),
                    isClean());
            arrival_ = null;
          }
          return arrivalBuilder_;
        }

        private com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent departure_;
        private com.google.protobuf.SingleFieldBuilder<
            com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.Builder, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEventOrBuilder> departureBuilder_;
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
         * @return Whether the departure field is set.
         */
        public boolean hasDeparture() {
          return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
         * @return The departure.
         */
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent getDeparture() {
          if (departureBuilder_ == null) {
            return departure_ == null ? com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.getDefaultInstance() : departure_;
          } else {
            return departureBuilder_.getMessage();
          }
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
         */
        public Builder setDeparture(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent value) {
          if (departureBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            departure_ = value;
          } else {
            departureBuilder_.setMessage(value);
          }
          bitField0_ |= 0x00000008;
          onChanged();
          return this;
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
         */
        public Builder setDeparture(
            com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.Builder builderForValue) {
          if (departureBuilder_ == null) {
            departure_ = builderForValue.build();
          } else {
            departureBuilder_.setMessage(builderForValue.build());
          }
          bitField0_ |= 0x00000008;
          onChanged();
          return this;
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
         */
        public Builder mergeDeparture(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent value) {
          if (departureBuilder_ == null) {
            if (((bitField0_ & 0x00000008) != 0) &&
              departure_ != null &&
              departure_ != com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.getDefaultInstance()) {
              getDepartureBuilder().mergeFrom(value);
            } else {
              departure_ = value;
            }
          } else {
            departureBuilder_.mergeFrom(value);
          }
          if (departure_ != null) {
            bitField0_ |= 0x00000008;
            onChanged();
          }
          return this;
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
         */
        public Builder clearDeparture() {
          bitField0_ = (bitField0_ & ~0x00000008);
          departure_ = null;
          if (departureBuilder_ != null) {
            departureBuilder_.dispose();
            departureBuilder_ = null;
          }
          onChanged();
          return this;
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
         */
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.Builder getDepartureBuilder() {
          bitField0_ |= 0x00000008;
          onChanged();
          return getDepartureFieldBuilder().getBuilder();
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
         */
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEventOrBuilder getDepartureOrBuilder() {
          if (departureBuilder_ != null) {
            return departureBuilder_.getMessageOrBuilder();
          } else {
            return departure_ == null ?
                com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.getDefaultInstance() : departure_;
          }
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
         */
        private com.google.protobuf.SingleFieldBuilder<
            com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.Builder, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEventOrBuilder> 
            getDepartureFieldBuilder() {
          if (departureBuilder_ == null) {
            departureBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.Builder, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEventOrBuilder>(
                    getDeparture(),
                    getParentForChildren(),
                    isClean());
            departure_ = null;
          }
          return departureBuilder_;
        }

        private int departureOccupancyStatus_ = 0;
        /**
         * <pre>
         * Expected occupancy after departure from the given stop.
         * Should be provided only for future stops.
         * In order to provide departure_occupancy_status without either arrival or
         * departure StopTimeEvents, ScheduleRelationship should be set to NO_DATA. 
         * </pre>
         *
         * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus departure_occupancy_status = 7;</code>
         * @return Whether the departureOccupancyStatus field is set.
         */
        @java.lang.Override public boolean hasDepartureOccupancyStatus() {
          return ((bitField0_ & 0x00000010) != 0);
        }
        /**
         * <pre>
         * Expected occupancy after departure from the given stop.
         * Should be provided only for future stops.
         * In order to provide departure_occupancy_status without either arrival or
         * departure StopTimeEvents, ScheduleRelationship should be set to NO_DATA. 
         * </pre>
         *
         * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus departure_occupancy_status = 7;</code>
         * @return The departureOccupancyStatus.
         */
        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus getDepartureOccupancyStatus() {
          com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus result = com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus.forNumber(departureOccupancyStatus_);
          return result == null ? com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus.EMPTY : result;
        }
        /**
         * <pre>
         * Expected occupancy after departure from the given stop.
         * Should be provided only for future stops.
         * In order to provide departure_occupancy_status without either arrival or
         * departure StopTimeEvents, ScheduleRelationship should be set to NO_DATA. 
         * </pre>
         *
         * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus departure_occupancy_status = 7;</code>
         * @param value The departureOccupancyStatus to set.
         * @return This builder for chaining.
         */
        public Builder setDepartureOccupancyStatus(com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000010;
          departureOccupancyStatus_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Expected occupancy after departure from the given stop.
         * Should be provided only for future stops.
         * In order to provide departure_occupancy_status without either arrival or
         * departure StopTimeEvents, ScheduleRelationship should be set to NO_DATA. 
         * </pre>
         *
         * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus departure_occupancy_status = 7;</code>
         * @return This builder for chaining.
         */
        public Builder clearDepartureOccupancyStatus() {
          bitField0_ = (bitField0_ & ~0x00000010);
          departureOccupancyStatus_ = 0;
          onChanged();
          return this;
        }

        private int scheduleRelationship_ = 0;
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];</code>
         * @return Whether the scheduleRelationship field is set.
         */
        @java.lang.Override public boolean hasScheduleRelationship() {
          return ((bitField0_ & 0x00000020) != 0);
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];</code>
         * @return The scheduleRelationship.
         */
        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship getScheduleRelationship() {
          com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship result = com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.forNumber(scheduleRelationship_);
          return result == null ? com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.SCHEDULED : result;
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];</code>
         * @param value The scheduleRelationship to set.
         * @return This builder for chaining.
         */
        public Builder setScheduleRelationship(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000020;
          scheduleRelationship_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];</code>
         * @return This builder for chaining.
         */
        public Builder clearScheduleRelationship() {
          bitField0_ = (bitField0_ & ~0x00000020);
          scheduleRelationship_ = 0;
          onChanged();
          return this;
        }

        private com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties stopTimeProperties_;
        private com.google.protobuf.SingleFieldBuilder<
            com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties.Builder, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimePropertiesOrBuilder> stopTimePropertiesBuilder_;
        /**
         * <pre>
         * Realtime updates for certain properties defined within GTFS stop_times.txt
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;</code>
         * @return Whether the stopTimeProperties field is set.
         */
        public boolean hasStopTimeProperties() {
          return ((bitField0_ & 0x00000040) != 0);
        }
        /**
         * <pre>
         * Realtime updates for certain properties defined within GTFS stop_times.txt
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;</code>
         * @return The stopTimeProperties.
         */
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties getStopTimeProperties() {
          if (stopTimePropertiesBuilder_ == null) {
            return stopTimeProperties_ == null ? com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties.getDefaultInstance() : stopTimeProperties_;
          } else {
            return stopTimePropertiesBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * Realtime updates for certain properties defined within GTFS stop_times.txt
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;</code>
         */
        public Builder setStopTimeProperties(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties value) {
          if (stopTimePropertiesBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            stopTimeProperties_ = value;
          } else {
            stopTimePropertiesBuilder_.setMessage(value);
          }
          bitField0_ |= 0x00000040;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Realtime updates for certain properties defined within GTFS stop_times.txt
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;</code>
         */
        public Builder setStopTimeProperties(
            com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties.Builder builderForValue) {
          if (stopTimePropertiesBuilder_ == null) {
            stopTimeProperties_ = builderForValue.build();
          } else {
            stopTimePropertiesBuilder_.setMessage(builderForValue.build());
          }
          bitField0_ |= 0x00000040;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Realtime updates for certain properties defined within GTFS stop_times.txt
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;</code>
         */
        public Builder mergeStopTimeProperties(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties value) {
          if (stopTimePropertiesBuilder_ == null) {
            if (((bitField0_ & 0x00000040) != 0) &&
              stopTimeProperties_ != null &&
              stopTimeProperties_ != com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties.getDefaultInstance()) {
              getStopTimePropertiesBuilder().mergeFrom(value);
            } else {
              stopTimeProperties_ = value;
            }
          } else {
            stopTimePropertiesBuilder_.mergeFrom(value);
          }
          if (stopTimeProperties_ != null) {
            bitField0_ |= 0x00000040;
            onChanged();
          }
          return this;
        }
        /**
         * <pre>
         * Realtime updates for certain properties defined within GTFS stop_times.txt
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;</code>
         */
        public Builder clearStopTimeProperties() {
          bitField0_ = (bitField0_ & ~0x00000040);
          stopTimeProperties_ = null;
          if (stopTimePropertiesBuilder_ != null) {
            stopTimePropertiesBuilder_.dispose();
            stopTimePropertiesBuilder_ = null;
          }
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Realtime updates for certain properties defined within GTFS stop_times.txt
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;</code>
         */
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties.Builder getStopTimePropertiesBuilder() {
          bitField0_ |= 0x00000040;
          onChanged();
          return getStopTimePropertiesFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * Realtime updates for certain properties defined within GTFS stop_times.txt
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;</code>
         */
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimePropertiesOrBuilder getStopTimePropertiesOrBuilder() {
          if (stopTimePropertiesBuilder_ != null) {
            return stopTimePropertiesBuilder_.getMessageOrBuilder();
          } else {
            return stopTimeProperties_ == null ?
                com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties.getDefaultInstance() : stopTimeProperties_;
          }
        }
        /**
         * <pre>
         * Realtime updates for certain properties defined within GTFS stop_times.txt
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;</code>
         */
        private com.google.protobuf.SingleFieldBuilder<
            com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties.Builder, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimePropertiesOrBuilder> 
            getStopTimePropertiesFieldBuilder() {
          if (stopTimePropertiesBuilder_ == null) {
            stopTimePropertiesBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimeProperties.Builder, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.StopTimePropertiesOrBuilder>(
                    getStopTimeProperties(),
                    getParentForChildren(),
                    isClean());
            stopTimeProperties_ = null;
          }
          return stopTimePropertiesBuilder_;
        }

        // @@protoc_insertion_point(builder_scope:transit_realtime.TripUpdate.StopTimeUpdate)
      }

      // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate.StopTimeUpdate)
      private static final com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate();
      }

      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<StopTimeUpdate>
          PARSER = new com.google.protobuf.AbstractParser<StopTimeUpdate>() {
        @java.lang.Override
        public StopTimeUpdate parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<StopTimeUpdate> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<StopTimeUpdate> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface TripPropertiesOrBuilder extends
        // @@protoc_insertion_point(interface_extends:transit_realtime.TripUpdate.TripProperties)
        com.google.protobuf.GeneratedMessage.
            ExtendableMessageOrBuilder<TripProperties> {

      /**
       * <pre>
       * Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt
       * but will start at a different service date and/or time (defined using the TripProperties.start_date and
       * TripProperties.start_time fields). See definition of trips.trip_id in (CSV) GTFS. Its value must be different
       * than the ones used in the (CSV) GTFS. Required if schedule_relationship=DUPLICATED, otherwise this field must not
       * be populated and will be ignored by consumers.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string trip_id = 1;</code>
       * @return Whether the tripId field is set.
       */
      boolean hasTripId();
      /**
       * <pre>
       * Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt
       * but will start at a different service date and/or time (defined using the TripProperties.start_date and
       * TripProperties.start_time fields). See definition of trips.trip_id in (CSV) GTFS. Its value must be different
       * than the ones used in the (CSV) GTFS. Required if schedule_relationship=DUPLICATED, otherwise this field must not
       * be populated and will be ignored by consumers.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string trip_id = 1;</code>
       * @return The tripId.
       */
      java.lang.String getTripId();
      /**
       * <pre>
       * Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt
       * but will start at a different service date and/or time (defined using the TripProperties.start_date and
       * TripProperties.start_time fields). See definition of trips.trip_id in (CSV) GTFS. Its value must be different
       * than the ones used in the (CSV) GTFS. Required if schedule_relationship=DUPLICATED, otherwise this field must not
       * be populated and will be ignored by consumers.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string trip_id = 1;</code>
       * @return The bytes for tripId.
       */
      com.google.protobuf.ByteString
          getTripIdBytes();

      /**
       * <pre>
       * Service date on which the DUPLICATED trip will be run, in YYYYMMDD format. Required if
       * schedule_relationship=DUPLICATED, otherwise this field must not be populated and will be ignored by consumers.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string start_date = 2;</code>
       * @return Whether the startDate field is set.
       */
      boolean hasStartDate();
      /**
       * <pre>
       * Service date on which the DUPLICATED trip will be run, in YYYYMMDD format. Required if
       * schedule_relationship=DUPLICATED, otherwise this field must not be populated and will be ignored by consumers.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string start_date = 2;</code>
       * @return The startDate.
       */
      java.lang.String getStartDate();
      /**
       * <pre>
       * Service date on which the DUPLICATED trip will be run, in YYYYMMDD format. Required if
       * schedule_relationship=DUPLICATED, otherwise this field must not be populated and will be ignored by consumers.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string start_date = 2;</code>
       * @return The bytes for startDate.
       */
      com.google.protobuf.ByteString
          getStartDateBytes();

      /**
       * <pre>
       * Defines the departure start time of the trip when it’s duplicated. See definition of stop_times.departure_time
       * in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset
       * between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a
       * departure_time of 10:00:00 and stop B with departure_time of 10:01:00, and this field is populated with the value
       * of 10:30:00, stop B on the duplicated trip will have a scheduled departure_time of 10:31:00. Real-time prediction
       * delay values are applied to this calculated schedule time to determine the predicted time. For example, if a
       * departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30. Real-time
       * prediction time values do not have any offset applied to them and indicate the predicted time as provided.
       * For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time
       * is 10:31:30. This field is required if schedule_relationship is DUPLICATED, otherwise this field must not be
       * populated and will be ignored by consumers.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string start_time = 3;</code>
       * @return Whether the startTime field is set.
       */
      boolean hasStartTime();
      /**
       * <pre>
       * Defines the departure start time of the trip when it’s duplicated. See definition of stop_times.departure_time
       * in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset
       * between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a
       * departure_time of 10:00:00 and stop B with departure_time of 10:01:00, and this field is populated with the value
       * of 10:30:00, stop B on the duplicated trip will have a scheduled departure_time of 10:31:00. Real-time prediction
       * delay values are applied to this calculated schedule time to determine the predicted time. For example, if a
       * departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30. Real-time
       * prediction time values do not have any offset applied to them and indicate the predicted time as provided.
       * For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time
       * is 10:31:30. This field is required if schedule_relationship is DUPLICATED, otherwise this field must not be
       * populated and will be ignored by consumers.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string start_time = 3;</code>
       * @return The startTime.
       */
      java.lang.String getStartTime();
      /**
       * <pre>
       * Defines the departure start time of the trip when it’s duplicated. See definition of stop_times.departure_time
       * in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset
       * between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a
       * departure_time of 10:00:00 and stop B with departure_time of 10:01:00, and this field is populated with the value
       * of 10:30:00, stop B on the duplicated trip will have a scheduled departure_time of 10:31:00. Real-time prediction
       * delay values are applied to this calculated schedule time to determine the predicted time. For example, if a
       * departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30. Real-time
       * prediction time values do not have any offset applied to them and indicate the predicted time as provided.
       * For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time
       * is 10:31:30. This field is required if schedule_relationship is DUPLICATED, otherwise this field must not be
       * populated and will be ignored by consumers.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string start_time = 3;</code>
       * @return The bytes for startTime.
       */
      com.google.protobuf.ByteString
          getStartTimeBytes();

      /**
       * <pre>
       * Specifies the shape of the vehicle travel path when the trip shape differs from the shape specified in
       * (CSV) GTFS or to specify it in real-time when it's not provided by (CSV) GTFS, such as a vehicle that takes differing
       * paths based on rider demand. See definition of trips.shape_id in (CSV) GTFS. If a shape is neither defined in (CSV) GTFS
       * nor in real-time, the shape is considered unknown. This field can refer to a shape defined in the (CSV) GTFS in shapes.txt
       * or a Shape in the (protobuf) real-time feed. The order of stops (stop sequences) for this trip must remain the same as
       * (CSV) GTFS. Stops that are a part of the original trip but will no longer be made, such as when a detour occurs, should
       * be marked as schedule_relationship=SKIPPED.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. 
       * </pre>
       *
       * <code>optional string shape_id = 4;</code>
       * @return Whether the shapeId field is set.
       */
      boolean hasShapeId();
      /**
       * <pre>
       * Specifies the shape of the vehicle travel path when the trip shape differs from the shape specified in
       * (CSV) GTFS or to specify it in real-time when it's not provided by (CSV) GTFS, such as a vehicle that takes differing
       * paths based on rider demand. See definition of trips.shape_id in (CSV) GTFS. If a shape is neither defined in (CSV) GTFS
       * nor in real-time, the shape is considered unknown. This field can refer to a shape defined in the (CSV) GTFS in shapes.txt
       * or a Shape in the (protobuf) real-time feed. The order of stops (stop sequences) for this trip must remain the same as
       * (CSV) GTFS. Stops that are a part of the original trip but will no longer be made, such as when a detour occurs, should
       * be marked as schedule_relationship=SKIPPED.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. 
       * </pre>
       *
       * <code>optional string shape_id = 4;</code>
       * @return The shapeId.
       */
      java.lang.String getShapeId();
      /**
       * <pre>
       * Specifies the shape of the vehicle travel path when the trip shape differs from the shape specified in
       * (CSV) GTFS or to specify it in real-time when it's not provided by (CSV) GTFS, such as a vehicle that takes differing
       * paths based on rider demand. See definition of trips.shape_id in (CSV) GTFS. If a shape is neither defined in (CSV) GTFS
       * nor in real-time, the shape is considered unknown. This field can refer to a shape defined in the (CSV) GTFS in shapes.txt
       * or a Shape in the (protobuf) real-time feed. The order of stops (stop sequences) for this trip must remain the same as
       * (CSV) GTFS. Stops that are a part of the original trip but will no longer be made, such as when a detour occurs, should
       * be marked as schedule_relationship=SKIPPED.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. 
       * </pre>
       *
       * <code>optional string shape_id = 4;</code>
       * @return The bytes for shapeId.
       */
      com.google.protobuf.ByteString
          getShapeIdBytes();
    }
    /**
     * <pre>
     * Defines updated properties of the trip, such as a new shape_id when there is a detour. Or defines the
     * trip_id, start_date, and start_time of a DUPLICATED trip. 
     * NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.TripUpdate.TripProperties}
     */
    public static final class TripProperties extends
        com.google.protobuf.GeneratedMessage.ExtendableMessage<
          TripProperties> implements
        // @@protoc_insertion_point(message_implements:transit_realtime.TripUpdate.TripProperties)
        TripPropertiesOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 28,
          /* patch= */ 3,
          /* suffix= */ "",
          TripProperties.class.getName());
      }
      // Use TripProperties.newBuilder() to construct.
      private TripProperties(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties, ?> builder) {
        super(builder);
      }
      private TripProperties() {
        tripId_ = "";
        startDate_ = "";
        startTime_ = "";
        shapeId_ = "";
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_TripProperties_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_TripProperties_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties.class, com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties.Builder.class);
      }

      private int bitField0_;
      public static final int TRIP_ID_FIELD_NUMBER = 1;
      @SuppressWarnings("serial")
      private volatile java.lang.Object tripId_ = "";
      /**
       * <pre>
       * Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt
       * but will start at a different service date and/or time (defined using the TripProperties.start_date and
       * TripProperties.start_time fields). See definition of trips.trip_id in (CSV) GTFS. Its value must be different
       * than the ones used in the (CSV) GTFS. Required if schedule_relationship=DUPLICATED, otherwise this field must not
       * be populated and will be ignored by consumers.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string trip_id = 1;</code>
       * @return Whether the tripId field is set.
       */
      @java.lang.Override
      public boolean hasTripId() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt
       * but will start at a different service date and/or time (defined using the TripProperties.start_date and
       * TripProperties.start_time fields). See definition of trips.trip_id in (CSV) GTFS. Its value must be different
       * than the ones used in the (CSV) GTFS. Required if schedule_relationship=DUPLICATED, otherwise this field must not
       * be populated and will be ignored by consumers.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string trip_id = 1;</code>
       * @return The tripId.
       */
      @java.lang.Override
      public java.lang.String getTripId() {
        java.lang.Object ref = tripId_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            tripId_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt
       * but will start at a different service date and/or time (defined using the TripProperties.start_date and
       * TripProperties.start_time fields). See definition of trips.trip_id in (CSV) GTFS. Its value must be different
       * than the ones used in the (CSV) GTFS. Required if schedule_relationship=DUPLICATED, otherwise this field must not
       * be populated and will be ignored by consumers.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string trip_id = 1;</code>
       * @return The bytes for tripId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getTripIdBytes() {
        java.lang.Object ref = tripId_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          tripId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int START_DATE_FIELD_NUMBER = 2;
      @SuppressWarnings("serial")
      private volatile java.lang.Object startDate_ = "";
      /**
       * <pre>
       * Service date on which the DUPLICATED trip will be run, in YYYYMMDD format. Required if
       * schedule_relationship=DUPLICATED, otherwise this field must not be populated and will be ignored by consumers.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string start_date = 2;</code>
       * @return Whether the startDate field is set.
       */
      @java.lang.Override
      public boolean hasStartDate() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Service date on which the DUPLICATED trip will be run, in YYYYMMDD format. Required if
       * schedule_relationship=DUPLICATED, otherwise this field must not be populated and will be ignored by consumers.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string start_date = 2;</code>
       * @return The startDate.
       */
      @java.lang.Override
      public java.lang.String getStartDate() {
        java.lang.Object ref = startDate_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            startDate_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * Service date on which the DUPLICATED trip will be run, in YYYYMMDD format. Required if
       * schedule_relationship=DUPLICATED, otherwise this field must not be populated and will be ignored by consumers.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string start_date = 2;</code>
       * @return The bytes for startDate.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getStartDateBytes() {
        java.lang.Object ref = startDate_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          startDate_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int START_TIME_FIELD_NUMBER = 3;
      @SuppressWarnings("serial")
      private volatile java.lang.Object startTime_ = "";
      /**
       * <pre>
       * Defines the departure start time of the trip when it’s duplicated. See definition of stop_times.departure_time
       * in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset
       * between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a
       * departure_time of 10:00:00 and stop B with departure_time of 10:01:00, and this field is populated with the value
       * of 10:30:00, stop B on the duplicated trip will have a scheduled departure_time of 10:31:00. Real-time prediction
       * delay values are applied to this calculated schedule time to determine the predicted time. For example, if a
       * departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30. Real-time
       * prediction time values do not have any offset applied to them and indicate the predicted time as provided.
       * For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time
       * is 10:31:30. This field is required if schedule_relationship is DUPLICATED, otherwise this field must not be
       * populated and will be ignored by consumers.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string start_time = 3;</code>
       * @return Whether the startTime field is set.
       */
      @java.lang.Override
      public boolean hasStartTime() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Defines the departure start time of the trip when it’s duplicated. See definition of stop_times.departure_time
       * in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset
       * between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a
       * departure_time of 10:00:00 and stop B with departure_time of 10:01:00, and this field is populated with the value
       * of 10:30:00, stop B on the duplicated trip will have a scheduled departure_time of 10:31:00. Real-time prediction
       * delay values are applied to this calculated schedule time to determine the predicted time. For example, if a
       * departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30. Real-time
       * prediction time values do not have any offset applied to them and indicate the predicted time as provided.
       * For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time
       * is 10:31:30. This field is required if schedule_relationship is DUPLICATED, otherwise this field must not be
       * populated and will be ignored by consumers.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string start_time = 3;</code>
       * @return The startTime.
       */
      @java.lang.Override
      public java.lang.String getStartTime() {
        java.lang.Object ref = startTime_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            startTime_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * Defines the departure start time of the trip when it’s duplicated. See definition of stop_times.departure_time
       * in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset
       * between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a
       * departure_time of 10:00:00 and stop B with departure_time of 10:01:00, and this field is populated with the value
       * of 10:30:00, stop B on the duplicated trip will have a scheduled departure_time of 10:31:00. Real-time prediction
       * delay values are applied to this calculated schedule time to determine the predicted time. For example, if a
       * departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30. Real-time
       * prediction time values do not have any offset applied to them and indicate the predicted time as provided.
       * For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time
       * is 10:31:30. This field is required if schedule_relationship is DUPLICATED, otherwise this field must not be
       * populated and will be ignored by consumers.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string start_time = 3;</code>
       * @return The bytes for startTime.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getStartTimeBytes() {
        java.lang.Object ref = startTime_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          startTime_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int SHAPE_ID_FIELD_NUMBER = 4;
      @SuppressWarnings("serial")
      private volatile java.lang.Object shapeId_ = "";
      /**
       * <pre>
       * Specifies the shape of the vehicle travel path when the trip shape differs from the shape specified in
       * (CSV) GTFS or to specify it in real-time when it's not provided by (CSV) GTFS, such as a vehicle that takes differing
       * paths based on rider demand. See definition of trips.shape_id in (CSV) GTFS. If a shape is neither defined in (CSV) GTFS
       * nor in real-time, the shape is considered unknown. This field can refer to a shape defined in the (CSV) GTFS in shapes.txt
       * or a Shape in the (protobuf) real-time feed. The order of stops (stop sequences) for this trip must remain the same as
       * (CSV) GTFS. Stops that are a part of the original trip but will no longer be made, such as when a detour occurs, should
       * be marked as schedule_relationship=SKIPPED.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. 
       * </pre>
       *
       * <code>optional string shape_id = 4;</code>
       * @return Whether the shapeId field is set.
       */
      @java.lang.Override
      public boolean hasShapeId() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Specifies the shape of the vehicle travel path when the trip shape differs from the shape specified in
       * (CSV) GTFS or to specify it in real-time when it's not provided by (CSV) GTFS, such as a vehicle that takes differing
       * paths based on rider demand. See definition of trips.shape_id in (CSV) GTFS. If a shape is neither defined in (CSV) GTFS
       * nor in real-time, the shape is considered unknown. This field can refer to a shape defined in the (CSV) GTFS in shapes.txt
       * or a Shape in the (protobuf) real-time feed. The order of stops (stop sequences) for this trip must remain the same as
       * (CSV) GTFS. Stops that are a part of the original trip but will no longer be made, such as when a detour occurs, should
       * be marked as schedule_relationship=SKIPPED.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. 
       * </pre>
       *
       * <code>optional string shape_id = 4;</code>
       * @return The shapeId.
       */
      @java.lang.Override
      public java.lang.String getShapeId() {
        java.lang.Object ref = shapeId_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            shapeId_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * Specifies the shape of the vehicle travel path when the trip shape differs from the shape specified in
       * (CSV) GTFS or to specify it in real-time when it's not provided by (CSV) GTFS, such as a vehicle that takes differing
       * paths based on rider demand. See definition of trips.shape_id in (CSV) GTFS. If a shape is neither defined in (CSV) GTFS
       * nor in real-time, the shape is considered unknown. This field can refer to a shape defined in the (CSV) GTFS in shapes.txt
       * or a Shape in the (protobuf) real-time feed. The order of stops (stop sequences) for this trip must remain the same as
       * (CSV) GTFS. Stops that are a part of the original trip but will no longer be made, such as when a detour occurs, should
       * be marked as schedule_relationship=SKIPPED.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. 
       * </pre>
       *
       * <code>optional string shape_id = 4;</code>
       * @return The bytes for shapeId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getShapeIdBytes() {
        java.lang.Object ref = shapeId_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          shapeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        if (!extensionsAreInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        com.google.protobuf.GeneratedMessage
          .ExtendableMessage.ExtensionSerializer
            extensionWriter = newExtensionSerializer();
        if (((bitField0_ & 0x00000001) != 0)) {
          com.google.protobuf.GeneratedMessage.writeString(output, 1, tripId_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          com.google.protobuf.GeneratedMessage.writeString(output, 2, startDate_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          com.google.protobuf.GeneratedMessage.writeString(output, 3, startTime_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          com.google.protobuf.GeneratedMessage.writeString(output, 4, shapeId_);
        }
        extensionWriter.writeUntil(10000, output);
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.GeneratedMessage.computeStringSize(1, tripId_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.GeneratedMessage.computeStringSize(2, startDate_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.GeneratedMessage.computeStringSize(3, startTime_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          size += com.google.protobuf.GeneratedMessage.computeStringSize(4, shapeId_);
        }
        size += extensionsSerializedSize();
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties)) {
          return super.equals(obj);
        }
        com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties other = (com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties) obj;

        if (hasTripId() != other.hasTripId()) return false;
        if (hasTripId()) {
          if (!getTripId()
              .equals(other.getTripId())) return false;
        }
        if (hasStartDate() != other.hasStartDate()) return false;
        if (hasStartDate()) {
          if (!getStartDate()
              .equals(other.getStartDate())) return false;
        }
        if (hasStartTime() != other.hasStartTime()) return false;
        if (hasStartTime()) {
          if (!getStartTime()
              .equals(other.getStartTime())) return false;
        }
        if (hasShapeId() != other.hasShapeId()) return false;
        if (hasShapeId()) {
          if (!getShapeId()
              .equals(other.getShapeId())) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        if (!getExtensionFields().equals(other.getExtensionFields()))
          return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasTripId()) {
          hash = (37 * hash) + TRIP_ID_FIELD_NUMBER;
          hash = (53 * hash) + getTripId().hashCode();
        }
        if (hasStartDate()) {
          hash = (37 * hash) + START_DATE_FIELD_NUMBER;
          hash = (53 * hash) + getStartDate().hashCode();
        }
        if (hasStartTime()) {
          hash = (37 * hash) + START_TIME_FIELD_NUMBER;
          hash = (53 * hash) + getStartTime().hashCode();
        }
        if (hasShapeId()) {
          hash = (37 * hash) + SHAPE_ID_FIELD_NUMBER;
          hash = (53 * hash) + getShapeId().hashCode();
        }
        hash = hashFields(hash, getExtensionFields());
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Defines updated properties of the trip, such as a new shape_id when there is a detour. Or defines the
       * trip_id, start_date, and start_time of a DUPLICATED trip. 
       * NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * Protobuf type {@code transit_realtime.TripUpdate.TripProperties}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.ExtendableBuilder<
            com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties, Builder> implements
          // @@protoc_insertion_point(builder_implements:transit_realtime.TripUpdate.TripProperties)
          com.google.transit.realtime.GtfsRealtime.TripUpdate.TripPropertiesOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_TripProperties_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_TripProperties_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties.class, com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties.Builder.class);
        }

        // Construct using com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          tripId_ = "";
          startDate_ = "";
          startTime_ = "";
          shapeId_ = "";
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_TripProperties_descriptor;
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties getDefaultInstanceForType() {
          return com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties.getDefaultInstance();
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties build() {
          com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties buildPartial() {
          com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties result = new com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.tripId_ = tripId_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.startDate_ = startDate_;
            to_bitField0_ |= 0x00000002;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.startTime_ = startTime_;
            to_bitField0_ |= 0x00000004;
          }
          if (((from_bitField0_ & 0x00000008) != 0)) {
            result.shapeId_ = shapeId_;
            to_bitField0_ |= 0x00000008;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties) {
            return mergeFrom((com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties other) {
          if (other == com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties.getDefaultInstance()) return this;
          if (other.hasTripId()) {
            tripId_ = other.tripId_;
            bitField0_ |= 0x00000001;
            onChanged();
          }
          if (other.hasStartDate()) {
            startDate_ = other.startDate_;
            bitField0_ |= 0x00000002;
            onChanged();
          }
          if (other.hasStartTime()) {
            startTime_ = other.startTime_;
            bitField0_ |= 0x00000004;
            onChanged();
          }
          if (other.hasShapeId()) {
            shapeId_ = other.shapeId_;
            bitField0_ |= 0x00000008;
            onChanged();
          }
          this.mergeExtensionFields(other);
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          if (!extensionsAreInitialized()) {
            return false;
          }
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 10: {
                  tripId_ = input.readBytes();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
                case 18: {
                  startDate_ = input.readBytes();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
                case 26: {
                  startTime_ = input.readBytes();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 26
                case 34: {
                  shapeId_ = input.readBytes();
                  bitField0_ |= 0x00000008;
                  break;
                } // case 34
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private java.lang.Object tripId_ = "";
        /**
         * <pre>
         * Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt
         * but will start at a different service date and/or time (defined using the TripProperties.start_date and
         * TripProperties.start_time fields). See definition of trips.trip_id in (CSV) GTFS. Its value must be different
         * than the ones used in the (CSV) GTFS. Required if schedule_relationship=DUPLICATED, otherwise this field must not
         * be populated and will be ignored by consumers.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string trip_id = 1;</code>
         * @return Whether the tripId field is set.
         */
        public boolean hasTripId() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt
         * but will start at a different service date and/or time (defined using the TripProperties.start_date and
         * TripProperties.start_time fields). See definition of trips.trip_id in (CSV) GTFS. Its value must be different
         * than the ones used in the (CSV) GTFS. Required if schedule_relationship=DUPLICATED, otherwise this field must not
         * be populated and will be ignored by consumers.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string trip_id = 1;</code>
         * @return The tripId.
         */
        public java.lang.String getTripId() {
          java.lang.Object ref = tripId_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              tripId_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt
         * but will start at a different service date and/or time (defined using the TripProperties.start_date and
         * TripProperties.start_time fields). See definition of trips.trip_id in (CSV) GTFS. Its value must be different
         * than the ones used in the (CSV) GTFS. Required if schedule_relationship=DUPLICATED, otherwise this field must not
         * be populated and will be ignored by consumers.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string trip_id = 1;</code>
         * @return The bytes for tripId.
         */
        public com.google.protobuf.ByteString
            getTripIdBytes() {
          java.lang.Object ref = tripId_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            tripId_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt
         * but will start at a different service date and/or time (defined using the TripProperties.start_date and
         * TripProperties.start_time fields). See definition of trips.trip_id in (CSV) GTFS. Its value must be different
         * than the ones used in the (CSV) GTFS. Required if schedule_relationship=DUPLICATED, otherwise this field must not
         * be populated and will be ignored by consumers.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string trip_id = 1;</code>
         * @param value The tripId to set.
         * @return This builder for chaining.
         */
        public Builder setTripId(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          tripId_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt
         * but will start at a different service date and/or time (defined using the TripProperties.start_date and
         * TripProperties.start_time fields). See definition of trips.trip_id in (CSV) GTFS. Its value must be different
         * than the ones used in the (CSV) GTFS. Required if schedule_relationship=DUPLICATED, otherwise this field must not
         * be populated and will be ignored by consumers.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string trip_id = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearTripId() {
          tripId_ = getDefaultInstance().getTripId();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt
         * but will start at a different service date and/or time (defined using the TripProperties.start_date and
         * TripProperties.start_time fields). See definition of trips.trip_id in (CSV) GTFS. Its value must be different
         * than the ones used in the (CSV) GTFS. Required if schedule_relationship=DUPLICATED, otherwise this field must not
         * be populated and will be ignored by consumers.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string trip_id = 1;</code>
         * @param value The bytes for tripId to set.
         * @return This builder for chaining.
         */
        public Builder setTripIdBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          tripId_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }

        private java.lang.Object startDate_ = "";
        /**
         * <pre>
         * Service date on which the DUPLICATED trip will be run, in YYYYMMDD format. Required if
         * schedule_relationship=DUPLICATED, otherwise this field must not be populated and will be ignored by consumers.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string start_date = 2;</code>
         * @return Whether the startDate field is set.
         */
        public boolean hasStartDate() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * Service date on which the DUPLICATED trip will be run, in YYYYMMDD format. Required if
         * schedule_relationship=DUPLICATED, otherwise this field must not be populated and will be ignored by consumers.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string start_date = 2;</code>
         * @return The startDate.
         */
        public java.lang.String getStartDate() {
          java.lang.Object ref = startDate_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              startDate_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * Service date on which the DUPLICATED trip will be run, in YYYYMMDD format. Required if
         * schedule_relationship=DUPLICATED, otherwise this field must not be populated and will be ignored by consumers.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string start_date = 2;</code>
         * @return The bytes for startDate.
         */
        public com.google.protobuf.ByteString
            getStartDateBytes() {
          java.lang.Object ref = startDate_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            startDate_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * Service date on which the DUPLICATED trip will be run, in YYYYMMDD format. Required if
         * schedule_relationship=DUPLICATED, otherwise this field must not be populated and will be ignored by consumers.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string start_date = 2;</code>
         * @param value The startDate to set.
         * @return This builder for chaining.
         */
        public Builder setStartDate(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          startDate_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Service date on which the DUPLICATED trip will be run, in YYYYMMDD format. Required if
         * schedule_relationship=DUPLICATED, otherwise this field must not be populated and will be ignored by consumers.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string start_date = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearStartDate() {
          startDate_ = getDefaultInstance().getStartDate();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Service date on which the DUPLICATED trip will be run, in YYYYMMDD format. Required if
         * schedule_relationship=DUPLICATED, otherwise this field must not be populated and will be ignored by consumers.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string start_date = 2;</code>
         * @param value The bytes for startDate to set.
         * @return This builder for chaining.
         */
        public Builder setStartDateBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          startDate_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }

        private java.lang.Object startTime_ = "";
        /**
         * <pre>
         * Defines the departure start time of the trip when it’s duplicated. See definition of stop_times.departure_time
         * in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset
         * between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a
         * departure_time of 10:00:00 and stop B with departure_time of 10:01:00, and this field is populated with the value
         * of 10:30:00, stop B on the duplicated trip will have a scheduled departure_time of 10:31:00. Real-time prediction
         * delay values are applied to this calculated schedule time to determine the predicted time. For example, if a
         * departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30. Real-time
         * prediction time values do not have any offset applied to them and indicate the predicted time as provided.
         * For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time
         * is 10:31:30. This field is required if schedule_relationship is DUPLICATED, otherwise this field must not be
         * populated and will be ignored by consumers.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string start_time = 3;</code>
         * @return Whether the startTime field is set.
         */
        public boolean hasStartTime() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * Defines the departure start time of the trip when it’s duplicated. See definition of stop_times.departure_time
         * in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset
         * between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a
         * departure_time of 10:00:00 and stop B with departure_time of 10:01:00, and this field is populated with the value
         * of 10:30:00, stop B on the duplicated trip will have a scheduled departure_time of 10:31:00. Real-time prediction
         * delay values are applied to this calculated schedule time to determine the predicted time. For example, if a
         * departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30. Real-time
         * prediction time values do not have any offset applied to them and indicate the predicted time as provided.
         * For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time
         * is 10:31:30. This field is required if schedule_relationship is DUPLICATED, otherwise this field must not be
         * populated and will be ignored by consumers.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string start_time = 3;</code>
         * @return The startTime.
         */
        public java.lang.String getStartTime() {
          java.lang.Object ref = startTime_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              startTime_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * Defines the departure start time of the trip when it’s duplicated. See definition of stop_times.departure_time
         * in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset
         * between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a
         * departure_time of 10:00:00 and stop B with departure_time of 10:01:00, and this field is populated with the value
         * of 10:30:00, stop B on the duplicated trip will have a scheduled departure_time of 10:31:00. Real-time prediction
         * delay values are applied to this calculated schedule time to determine the predicted time. For example, if a
         * departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30. Real-time
         * prediction time values do not have any offset applied to them and indicate the predicted time as provided.
         * For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time
         * is 10:31:30. This field is required if schedule_relationship is DUPLICATED, otherwise this field must not be
         * populated and will be ignored by consumers.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string start_time = 3;</code>
         * @return The bytes for startTime.
         */
        public com.google.protobuf.ByteString
            getStartTimeBytes() {
          java.lang.Object ref = startTime_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            startTime_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * Defines the departure start time of the trip when it’s duplicated. See definition of stop_times.departure_time
         * in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset
         * between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a
         * departure_time of 10:00:00 and stop B with departure_time of 10:01:00, and this field is populated with the value
         * of 10:30:00, stop B on the duplicated trip will have a scheduled departure_time of 10:31:00. Real-time prediction
         * delay values are applied to this calculated schedule time to determine the predicted time. For example, if a
         * departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30. Real-time
         * prediction time values do not have any offset applied to them and indicate the predicted time as provided.
         * For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time
         * is 10:31:30. This field is required if schedule_relationship is DUPLICATED, otherwise this field must not be
         * populated and will be ignored by consumers.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string start_time = 3;</code>
         * @param value The startTime to set.
         * @return This builder for chaining.
         */
        public Builder setStartTime(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          startTime_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Defines the departure start time of the trip when it’s duplicated. See definition of stop_times.departure_time
         * in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset
         * between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a
         * departure_time of 10:00:00 and stop B with departure_time of 10:01:00, and this field is populated with the value
         * of 10:30:00, stop B on the duplicated trip will have a scheduled departure_time of 10:31:00. Real-time prediction
         * delay values are applied to this calculated schedule time to determine the predicted time. For example, if a
         * departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30. Real-time
         * prediction time values do not have any offset applied to them and indicate the predicted time as provided.
         * For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time
         * is 10:31:30. This field is required if schedule_relationship is DUPLICATED, otherwise this field must not be
         * populated and will be ignored by consumers.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string start_time = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearStartTime() {
          startTime_ = getDefaultInstance().getStartTime();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Defines the departure start time of the trip when it’s duplicated. See definition of stop_times.departure_time
         * in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset
         * between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a
         * departure_time of 10:00:00 and stop B with departure_time of 10:01:00, and this field is populated with the value
         * of 10:30:00, stop B on the duplicated trip will have a scheduled departure_time of 10:31:00. Real-time prediction
         * delay values are applied to this calculated schedule time to determine the predicted time. For example, if a
         * departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30. Real-time
         * prediction time values do not have any offset applied to them and indicate the predicted time as provided.
         * For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time
         * is 10:31:30. This field is required if schedule_relationship is DUPLICATED, otherwise this field must not be
         * populated and will be ignored by consumers.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string start_time = 3;</code>
         * @param value The bytes for startTime to set.
         * @return This builder for chaining.
         */
        public Builder setStartTimeBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          startTime_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }

        private java.lang.Object shapeId_ = "";
        /**
         * <pre>
         * Specifies the shape of the vehicle travel path when the trip shape differs from the shape specified in
         * (CSV) GTFS or to specify it in real-time when it's not provided by (CSV) GTFS, such as a vehicle that takes differing
         * paths based on rider demand. See definition of trips.shape_id in (CSV) GTFS. If a shape is neither defined in (CSV) GTFS
         * nor in real-time, the shape is considered unknown. This field can refer to a shape defined in the (CSV) GTFS in shapes.txt
         * or a Shape in the (protobuf) real-time feed. The order of stops (stop sequences) for this trip must remain the same as
         * (CSV) GTFS. Stops that are a part of the original trip but will no longer be made, such as when a detour occurs, should
         * be marked as schedule_relationship=SKIPPED.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. 
         * </pre>
         *
         * <code>optional string shape_id = 4;</code>
         * @return Whether the shapeId field is set.
         */
        public boolean hasShapeId() {
          return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <pre>
         * Specifies the shape of the vehicle travel path when the trip shape differs from the shape specified in
         * (CSV) GTFS or to specify it in real-time when it's not provided by (CSV) GTFS, such as a vehicle that takes differing
         * paths based on rider demand. See definition of trips.shape_id in (CSV) GTFS. If a shape is neither defined in (CSV) GTFS
         * nor in real-time, the shape is considered unknown. This field can refer to a shape defined in the (CSV) GTFS in shapes.txt
         * or a Shape in the (protobuf) real-time feed. The order of stops (stop sequences) for this trip must remain the same as
         * (CSV) GTFS. Stops that are a part of the original trip but will no longer be made, such as when a detour occurs, should
         * be marked as schedule_relationship=SKIPPED.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. 
         * </pre>
         *
         * <code>optional string shape_id = 4;</code>
         * @return The shapeId.
         */
        public java.lang.String getShapeId() {
          java.lang.Object ref = shapeId_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              shapeId_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * Specifies the shape of the vehicle travel path when the trip shape differs from the shape specified in
         * (CSV) GTFS or to specify it in real-time when it's not provided by (CSV) GTFS, such as a vehicle that takes differing
         * paths based on rider demand. See definition of trips.shape_id in (CSV) GTFS. If a shape is neither defined in (CSV) GTFS
         * nor in real-time, the shape is considered unknown. This field can refer to a shape defined in the (CSV) GTFS in shapes.txt
         * or a Shape in the (protobuf) real-time feed. The order of stops (stop sequences) for this trip must remain the same as
         * (CSV) GTFS. Stops that are a part of the original trip but will no longer be made, such as when a detour occurs, should
         * be marked as schedule_relationship=SKIPPED.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. 
         * </pre>
         *
         * <code>optional string shape_id = 4;</code>
         * @return The bytes for shapeId.
         */
        public com.google.protobuf.ByteString
            getShapeIdBytes() {
          java.lang.Object ref = shapeId_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            shapeId_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * Specifies the shape of the vehicle travel path when the trip shape differs from the shape specified in
         * (CSV) GTFS or to specify it in real-time when it's not provided by (CSV) GTFS, such as a vehicle that takes differing
         * paths based on rider demand. See definition of trips.shape_id in (CSV) GTFS. If a shape is neither defined in (CSV) GTFS
         * nor in real-time, the shape is considered unknown. This field can refer to a shape defined in the (CSV) GTFS in shapes.txt
         * or a Shape in the (protobuf) real-time feed. The order of stops (stop sequences) for this trip must remain the same as
         * (CSV) GTFS. Stops that are a part of the original trip but will no longer be made, such as when a detour occurs, should
         * be marked as schedule_relationship=SKIPPED.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. 
         * </pre>
         *
         * <code>optional string shape_id = 4;</code>
         * @param value The shapeId to set.
         * @return This builder for chaining.
         */
        public Builder setShapeId(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          shapeId_ = value;
          bitField0_ |= 0x00000008;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Specifies the shape of the vehicle travel path when the trip shape differs from the shape specified in
         * (CSV) GTFS or to specify it in real-time when it's not provided by (CSV) GTFS, such as a vehicle that takes differing
         * paths based on rider demand. See definition of trips.shape_id in (CSV) GTFS. If a shape is neither defined in (CSV) GTFS
         * nor in real-time, the shape is considered unknown. This field can refer to a shape defined in the (CSV) GTFS in shapes.txt
         * or a Shape in the (protobuf) real-time feed. The order of stops (stop sequences) for this trip must remain the same as
         * (CSV) GTFS. Stops that are a part of the original trip but will no longer be made, such as when a detour occurs, should
         * be marked as schedule_relationship=SKIPPED.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. 
         * </pre>
         *
         * <code>optional string shape_id = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearShapeId() {
          shapeId_ = getDefaultInstance().getShapeId();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Specifies the shape of the vehicle travel path when the trip shape differs from the shape specified in
         * (CSV) GTFS or to specify it in real-time when it's not provided by (CSV) GTFS, such as a vehicle that takes differing
         * paths based on rider demand. See definition of trips.shape_id in (CSV) GTFS. If a shape is neither defined in (CSV) GTFS
         * nor in real-time, the shape is considered unknown. This field can refer to a shape defined in the (CSV) GTFS in shapes.txt
         * or a Shape in the (protobuf) real-time feed. The order of stops (stop sequences) for this trip must remain the same as
         * (CSV) GTFS. Stops that are a part of the original trip but will no longer be made, such as when a detour occurs, should
         * be marked as schedule_relationship=SKIPPED.
         * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. 
         * </pre>
         *
         * <code>optional string shape_id = 4;</code>
         * @param value The bytes for shapeId to set.
         * @return This builder for chaining.
         */
        public Builder setShapeIdBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          shapeId_ = value;
          bitField0_ |= 0x00000008;
          onChanged();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:transit_realtime.TripUpdate.TripProperties)
      }

      // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate.TripProperties)
      private static final com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties();
      }

      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<TripProperties>
          PARSER = new com.google.protobuf.AbstractParser<TripProperties>() {
        @java.lang.Override
        public TripProperties parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<TripProperties> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<TripProperties> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    public static final int TRIP_FIELD_NUMBER = 1;
    private com.google.transit.realtime.GtfsRealtime.TripDescriptor trip_;
    /**
     * <pre>
     * The Trip that this message applies to. There can be at most one
     * TripUpdate entity for each actual trip instance.
     * If there is none, that means there is no prediction information available.
     * It does *not* mean that the trip is progressing according to schedule.
     * </pre>
     *
     * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
     * @return Whether the trip field is set.
     */
    @java.lang.Override
    public boolean hasTrip() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The Trip that this message applies to. There can be at most one
     * TripUpdate entity for each actual trip instance.
     * If there is none, that means there is no prediction information available.
     * It does *not* mean that the trip is progressing according to schedule.
     * </pre>
     *
     * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
     * @return The trip.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripDescriptor getTrip() {
      return trip_ == null ? com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance() : trip_;
    }
    /**
     * <pre>
     * The Trip that this message applies to. There can be at most one
     * TripUpdate entity for each actual trip instance.
     * If there is none, that means there is no prediction information available.
     * It does *not* mean that the trip is progressing according to schedule.
     * </pre>
     *
     * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripDescriptorOrBuilder getTripOrBuilder() {
      return trip_ == null ? com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance() : trip_;
    }

    public static final int VEHICLE_FIELD_NUMBER = 3;
    private com.google.transit.realtime.GtfsRealtime.VehicleDescriptor vehicle_;
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
     * @return Whether the vehicle field is set.
     */
    @java.lang.Override
    public boolean hasVehicle() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
     * @return The vehicle.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.VehicleDescriptor getVehicle() {
      return vehicle_ == null ? com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.getDefaultInstance() : vehicle_;
    }
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.VehicleDescriptorOrBuilder getVehicleOrBuilder() {
      return vehicle_ == null ? com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.getDefaultInstance() : vehicle_;
    }

    public static final int STOP_TIME_UPDATE_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate> stopTimeUpdate_;
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     *
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     *
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate> getStopTimeUpdateList() {
      return stopTimeUpdate_;
    }
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     *
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     *
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdateOrBuilder> 
        getStopTimeUpdateOrBuilderList() {
      return stopTimeUpdate_;
    }
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     *
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     *
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    @java.lang.Override
    public int getStopTimeUpdateCount() {
      return stopTimeUpdate_.size();
    }
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     *
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     *
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate getStopTimeUpdate(int index) {
      return stopTimeUpdate_.get(index);
    }
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     *
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     *
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdateOrBuilder getStopTimeUpdateOrBuilder(
        int index) {
      return stopTimeUpdate_.get(index);
    }

    public static final int TIMESTAMP_FIELD_NUMBER = 4;
    private long timestamp_ = 0L;
    /**
     * <pre>
     * The most recent moment at which the vehicle's real-time progress was measured
     * to estimate StopTimes in the future. When StopTimes in the past are provided,
     * arrival/departure times may be earlier than this value. In POSIX
     * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 4;</code>
     * @return Whether the timestamp field is set.
     */
    @java.lang.Override
    public boolean hasTimestamp() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The most recent moment at which the vehicle's real-time progress was measured
     * to estimate StopTimes in the future. When StopTimes in the past are provided,
     * arrival/departure times may be earlier than this value. In POSIX
     * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 4;</code>
     * @return The timestamp.
     */
    @java.lang.Override
    public long getTimestamp() {
      return timestamp_;
    }

    public static final int DELAY_FIELD_NUMBER = 5;
    private int delay_ = 0;
    /**
     * <pre>
     * The current schedule deviation for the trip.  Delay should only be
     * specified when the prediction is given relative to some existing schedule
     * in GTFS.
     *
     * Delay (in seconds) can be positive (meaning that the vehicle is late) or
     * negative (meaning that the vehicle is ahead of schedule). Delay of 0
     * means that the vehicle is exactly on time.
     *
     * Delay information in StopTimeUpdates take precedent of trip-level delay
     * information, such that trip-level delay is only propagated until the next
     * stop along the trip with a StopTimeUpdate delay value specified.
     *
     * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
     * value indicating when the delay value was last updated, in order to
     * evaluate the freshness of the data.
     *
     * NOTE: This field is still experimental, and subject to change. It may be
     * formally adopted in the future.
     * </pre>
     *
     * <code>optional int32 delay = 5;</code>
     * @return Whether the delay field is set.
     */
    @java.lang.Override
    public boolean hasDelay() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The current schedule deviation for the trip.  Delay should only be
     * specified when the prediction is given relative to some existing schedule
     * in GTFS.
     *
     * Delay (in seconds) can be positive (meaning that the vehicle is late) or
     * negative (meaning that the vehicle is ahead of schedule). Delay of 0
     * means that the vehicle is exactly on time.
     *
     * Delay information in StopTimeUpdates take precedent of trip-level delay
     * information, such that trip-level delay is only propagated until the next
     * stop along the trip with a StopTimeUpdate delay value specified.
     *
     * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
     * value indicating when the delay value was last updated, in order to
     * evaluate the freshness of the data.
     *
     * NOTE: This field is still experimental, and subject to change. It may be
     * formally adopted in the future.
     * </pre>
     *
     * <code>optional int32 delay = 5;</code>
     * @return The delay.
     */
    @java.lang.Override
    public int getDelay() {
      return delay_;
    }

    public static final int TRIP_PROPERTIES_FIELD_NUMBER = 6;
    private com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties tripProperties_;
    /**
     * <code>optional .transit_realtime.TripUpdate.TripProperties trip_properties = 6;</code>
     * @return Whether the tripProperties field is set.
     */
    @java.lang.Override
    public boolean hasTripProperties() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <code>optional .transit_realtime.TripUpdate.TripProperties trip_properties = 6;</code>
     * @return The tripProperties.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties getTripProperties() {
      return tripProperties_ == null ? com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties.getDefaultInstance() : tripProperties_;
    }
    /**
     * <code>optional .transit_realtime.TripUpdate.TripProperties trip_properties = 6;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripUpdate.TripPropertiesOrBuilder getTripPropertiesOrBuilder() {
      return tripProperties_ == null ? com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties.getDefaultInstance() : tripProperties_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasTrip()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!getTrip().isInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (hasVehicle()) {
        if (!getVehicle().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      for (int i = 0; i < getStopTimeUpdateCount(); i++) {
        if (!getStopTimeUpdate(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasTripProperties()) {
        if (!getTripProperties().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (!extensionsAreInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessage
        .ExtendableMessage.ExtensionSerializer
          extensionWriter = newExtensionSerializer();
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getTrip());
      }
      for (int i = 0; i < stopTimeUpdate_.size(); i++) {
        output.writeMessage(2, stopTimeUpdate_.get(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(3, getVehicle());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeUInt64(4, timestamp_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeInt32(5, delay_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeMessage(6, getTripProperties());
      }
      extensionWriter.writeUntil(10000, output);
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getTrip());
      }
      for (int i = 0; i < stopTimeUpdate_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, stopTimeUpdate_.get(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getVehicle());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(4, timestamp_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(5, delay_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getTripProperties());
      }
      size += extensionsSerializedSize();
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.TripUpdate)) {
        return super.equals(obj);
      }
      com.google.transit.realtime.GtfsRealtime.TripUpdate other = (com.google.transit.realtime.GtfsRealtime.TripUpdate) obj;

      if (hasTrip() != other.hasTrip()) return false;
      if (hasTrip()) {
        if (!getTrip()
            .equals(other.getTrip())) return false;
      }
      if (hasVehicle() != other.hasVehicle()) return false;
      if (hasVehicle()) {
        if (!getVehicle()
            .equals(other.getVehicle())) return false;
      }
      if (!getStopTimeUpdateList()
          .equals(other.getStopTimeUpdateList())) return false;
      if (hasTimestamp() != other.hasTimestamp()) return false;
      if (hasTimestamp()) {
        if (getTimestamp()
            != other.getTimestamp()) return false;
      }
      if (hasDelay() != other.hasDelay()) return false;
      if (hasDelay()) {
        if (getDelay()
            != other.getDelay()) return false;
      }
      if (hasTripProperties() != other.hasTripProperties()) return false;
      if (hasTripProperties()) {
        if (!getTripProperties()
            .equals(other.getTripProperties())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      if (!getExtensionFields().equals(other.getExtensionFields()))
        return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasTrip()) {
        hash = (37 * hash) + TRIP_FIELD_NUMBER;
        hash = (53 * hash) + getTrip().hashCode();
      }
      if (hasVehicle()) {
        hash = (37 * hash) + VEHICLE_FIELD_NUMBER;
        hash = (53 * hash) + getVehicle().hashCode();
      }
      if (getStopTimeUpdateCount() > 0) {
        hash = (37 * hash) + STOP_TIME_UPDATE_FIELD_NUMBER;
        hash = (53 * hash) + getStopTimeUpdateList().hashCode();
      }
      if (hasTimestamp()) {
        hash = (37 * hash) + TIMESTAMP_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getTimestamp());
      }
      if (hasDelay()) {
        hash = (37 * hash) + DELAY_FIELD_NUMBER;
        hash = (53 * hash) + getDelay();
      }
      if (hasTripProperties()) {
        hash = (37 * hash) + TRIP_PROPERTIES_FIELD_NUMBER;
        hash = (53 * hash) + getTripProperties().hashCode();
      }
      hash = hashFields(hash, getExtensionFields());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.transit.realtime.GtfsRealtime.TripUpdate parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripUpdate parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripUpdate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripUpdate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripUpdate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripUpdate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripUpdate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripUpdate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.transit.realtime.GtfsRealtime.TripUpdate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.transit.realtime.GtfsRealtime.TripUpdate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripUpdate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripUpdate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.TripUpdate prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Realtime update of the progress of a vehicle along a trip.
     * Depending on the value of ScheduleRelationship, a TripUpdate can specify:
     * - A trip that proceeds along the schedule.
     * - A trip that proceeds along a route but has no fixed schedule.
     * - A trip that have been added or removed with regard to schedule.
     *
     * The updates can be for future, predicted arrival/departure events, or for
     * past events that already occurred.
     * Normally, updates should get more precise and more certain (see
     * uncertainty below) as the events gets closer to current time.
     * Even if that is not possible, the information for past events should be
     * precise and certain. In particular, if an update points to time in the past
     * but its update's uncertainty is not 0, the client should conclude that the
     * update is a (wrong) prediction and that the trip has not completed yet.
     *
     * Note that the update can describe a trip that is already completed.
     * To this end, it is enough to provide an update for the last stop of the trip.
     * If the time of that is in the past, the client will conclude from that that
     * the whole trip is in the past (it is possible, although inconsequential, to
     * also provide updates for preceding stops).
     * This option is most relevant for a trip that has completed ahead of schedule,
     * but according to the schedule, the trip is still proceeding at the current
     * time. Removing the updates for this trip could make the client assume
     * that the trip is still proceeding.
     * Note that the feed provider is allowed, but not required, to purge past
     * updates - this is one case where this would be practically useful.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.TripUpdate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
          com.google.transit.realtime.GtfsRealtime.TripUpdate, Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_realtime.TripUpdate)
        com.google.transit.realtime.GtfsRealtime.TripUpdateOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.TripUpdate.class, com.google.transit.realtime.GtfsRealtime.TripUpdate.Builder.class);
      }

      // Construct using com.google.transit.realtime.GtfsRealtime.TripUpdate.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getTripFieldBuilder();
          getVehicleFieldBuilder();
          getStopTimeUpdateFieldBuilder();
          getTripPropertiesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        trip_ = null;
        if (tripBuilder_ != null) {
          tripBuilder_.dispose();
          tripBuilder_ = null;
        }
        vehicle_ = null;
        if (vehicleBuilder_ != null) {
          vehicleBuilder_.dispose();
          vehicleBuilder_ = null;
        }
        if (stopTimeUpdateBuilder_ == null) {
          stopTimeUpdate_ = java.util.Collections.emptyList();
        } else {
          stopTimeUpdate_ = null;
          stopTimeUpdateBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        timestamp_ = 0L;
        delay_ = 0;
        tripProperties_ = null;
        if (tripPropertiesBuilder_ != null) {
          tripPropertiesBuilder_.dispose();
          tripPropertiesBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripUpdate_descriptor;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TripUpdate getDefaultInstanceForType() {
        return com.google.transit.realtime.GtfsRealtime.TripUpdate.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TripUpdate build() {
        com.google.transit.realtime.GtfsRealtime.TripUpdate result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TripUpdate buildPartial() {
        com.google.transit.realtime.GtfsRealtime.TripUpdate result = new com.google.transit.realtime.GtfsRealtime.TripUpdate(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(com.google.transit.realtime.GtfsRealtime.TripUpdate result) {
        if (stopTimeUpdateBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)) {
            stopTimeUpdate_ = java.util.Collections.unmodifiableList(stopTimeUpdate_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.stopTimeUpdate_ = stopTimeUpdate_;
        } else {
          result.stopTimeUpdate_ = stopTimeUpdateBuilder_.build();
        }
      }

      private void buildPartial0(com.google.transit.realtime.GtfsRealtime.TripUpdate result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.trip_ = tripBuilder_ == null
              ? trip_
              : tripBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.vehicle_ = vehicleBuilder_ == null
              ? vehicle_
              : vehicleBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.timestamp_ = timestamp_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.delay_ = delay_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.tripProperties_ = tripPropertiesBuilder_ == null
              ? tripProperties_
              : tripPropertiesBuilder_.build();
          to_bitField0_ |= 0x00000010;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.transit.realtime.GtfsRealtime.TripUpdate) {
          return mergeFrom((com.google.transit.realtime.GtfsRealtime.TripUpdate)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.TripUpdate other) {
        if (other == com.google.transit.realtime.GtfsRealtime.TripUpdate.getDefaultInstance()) return this;
        if (other.hasTrip()) {
          mergeTrip(other.getTrip());
        }
        if (other.hasVehicle()) {
          mergeVehicle(other.getVehicle());
        }
        if (stopTimeUpdateBuilder_ == null) {
          if (!other.stopTimeUpdate_.isEmpty()) {
            if (stopTimeUpdate_.isEmpty()) {
              stopTimeUpdate_ = other.stopTimeUpdate_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureStopTimeUpdateIsMutable();
              stopTimeUpdate_.addAll(other.stopTimeUpdate_);
            }
            onChanged();
          }
        } else {
          if (!other.stopTimeUpdate_.isEmpty()) {
            if (stopTimeUpdateBuilder_.isEmpty()) {
              stopTimeUpdateBuilder_.dispose();
              stopTimeUpdateBuilder_ = null;
              stopTimeUpdate_ = other.stopTimeUpdate_;
              bitField0_ = (bitField0_ & ~0x00000004);
              stopTimeUpdateBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getStopTimeUpdateFieldBuilder() : null;
            } else {
              stopTimeUpdateBuilder_.addAllMessages(other.stopTimeUpdate_);
            }
          }
        }
        if (other.hasTimestamp()) {
          setTimestamp(other.getTimestamp());
        }
        if (other.hasDelay()) {
          setDelay(other.getDelay());
        }
        if (other.hasTripProperties()) {
          mergeTripProperties(other.getTripProperties());
        }
        this.mergeExtensionFields(other);
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasTrip()) {
          return false;
        }
        if (!getTrip().isInitialized()) {
          return false;
        }
        if (hasVehicle()) {
          if (!getVehicle().isInitialized()) {
            return false;
          }
        }
        for (int i = 0; i < getStopTimeUpdateCount(); i++) {
          if (!getStopTimeUpdate(i).isInitialized()) {
            return false;
          }
        }
        if (hasTripProperties()) {
          if (!getTripProperties().isInitialized()) {
            return false;
          }
        }
        if (!extensionsAreInitialized()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getTripFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate m =
                    input.readMessage(
                        com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.parser(),
                        extensionRegistry);
                if (stopTimeUpdateBuilder_ == null) {
                  ensureStopTimeUpdateIsMutable();
                  stopTimeUpdate_.add(m);
                } else {
                  stopTimeUpdateBuilder_.addMessage(m);
                }
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getVehicleFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 26
              case 32: {
                timestamp_ = input.readUInt64();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 40: {
                delay_ = input.readInt32();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              case 50: {
                input.readMessage(
                    getTripPropertiesFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000020;
                break;
              } // case 50
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.transit.realtime.GtfsRealtime.TripDescriptor trip_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TripDescriptor, com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder, com.google.transit.realtime.GtfsRealtime.TripDescriptorOrBuilder> tripBuilder_;
      /**
       * <pre>
       * The Trip that this message applies to. There can be at most one
       * TripUpdate entity for each actual trip instance.
       * If there is none, that means there is no prediction information available.
       * It does *not* mean that the trip is progressing according to schedule.
       * </pre>
       *
       * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
       * @return Whether the trip field is set.
       */
      public boolean hasTrip() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The Trip that this message applies to. There can be at most one
       * TripUpdate entity for each actual trip instance.
       * If there is none, that means there is no prediction information available.
       * It does *not* mean that the trip is progressing according to schedule.
       * </pre>
       *
       * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
       * @return The trip.
       */
      public com.google.transit.realtime.GtfsRealtime.TripDescriptor getTrip() {
        if (tripBuilder_ == null) {
          return trip_ == null ? com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance() : trip_;
        } else {
          return tripBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The Trip that this message applies to. There can be at most one
       * TripUpdate entity for each actual trip instance.
       * If there is none, that means there is no prediction information available.
       * It does *not* mean that the trip is progressing according to schedule.
       * </pre>
       *
       * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public Builder setTrip(com.google.transit.realtime.GtfsRealtime.TripDescriptor value) {
        if (tripBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          trip_ = value;
        } else {
          tripBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The Trip that this message applies to. There can be at most one
       * TripUpdate entity for each actual trip instance.
       * If there is none, that means there is no prediction information available.
       * It does *not* mean that the trip is progressing according to schedule.
       * </pre>
       *
       * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public Builder setTrip(
          com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder builderForValue) {
        if (tripBuilder_ == null) {
          trip_ = builderForValue.build();
        } else {
          tripBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The Trip that this message applies to. There can be at most one
       * TripUpdate entity for each actual trip instance.
       * If there is none, that means there is no prediction information available.
       * It does *not* mean that the trip is progressing according to schedule.
       * </pre>
       *
       * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public Builder mergeTrip(com.google.transit.realtime.GtfsRealtime.TripDescriptor value) {
        if (tripBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            trip_ != null &&
            trip_ != com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance()) {
            getTripBuilder().mergeFrom(value);
          } else {
            trip_ = value;
          }
        } else {
          tripBuilder_.mergeFrom(value);
        }
        if (trip_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * The Trip that this message applies to. There can be at most one
       * TripUpdate entity for each actual trip instance.
       * If there is none, that means there is no prediction information available.
       * It does *not* mean that the trip is progressing according to schedule.
       * </pre>
       *
       * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public Builder clearTrip() {
        bitField0_ = (bitField0_ & ~0x00000001);
        trip_ = null;
        if (tripBuilder_ != null) {
          tripBuilder_.dispose();
          tripBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The Trip that this message applies to. There can be at most one
       * TripUpdate entity for each actual trip instance.
       * If there is none, that means there is no prediction information available.
       * It does *not* mean that the trip is progressing according to schedule.
       * </pre>
       *
       * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder getTripBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getTripFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The Trip that this message applies to. There can be at most one
       * TripUpdate entity for each actual trip instance.
       * If there is none, that means there is no prediction information available.
       * It does *not* mean that the trip is progressing according to schedule.
       * </pre>
       *
       * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripDescriptorOrBuilder getTripOrBuilder() {
        if (tripBuilder_ != null) {
          return tripBuilder_.getMessageOrBuilder();
        } else {
          return trip_ == null ?
              com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance() : trip_;
        }
      }
      /**
       * <pre>
       * The Trip that this message applies to. There can be at most one
       * TripUpdate entity for each actual trip instance.
       * If there is none, that means there is no prediction information available.
       * It does *not* mean that the trip is progressing according to schedule.
       * </pre>
       *
       * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TripDescriptor, com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder, com.google.transit.realtime.GtfsRealtime.TripDescriptorOrBuilder> 
          getTripFieldBuilder() {
        if (tripBuilder_ == null) {
          tripBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TripDescriptor, com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder, com.google.transit.realtime.GtfsRealtime.TripDescriptorOrBuilder>(
                  getTrip(),
                  getParentForChildren(),
                  isClean());
          trip_ = null;
        }
        return tripBuilder_;
      }

      private com.google.transit.realtime.GtfsRealtime.VehicleDescriptor vehicle_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.VehicleDescriptor, com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.Builder, com.google.transit.realtime.GtfsRealtime.VehicleDescriptorOrBuilder> vehicleBuilder_;
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
       * @return Whether the vehicle field is set.
       */
      public boolean hasVehicle() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
       * @return The vehicle.
       */
      public com.google.transit.realtime.GtfsRealtime.VehicleDescriptor getVehicle() {
        if (vehicleBuilder_ == null) {
          return vehicle_ == null ? com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.getDefaultInstance() : vehicle_;
        } else {
          return vehicleBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
       */
      public Builder setVehicle(com.google.transit.realtime.GtfsRealtime.VehicleDescriptor value) {
        if (vehicleBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          vehicle_ = value;
        } else {
          vehicleBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
       */
      public Builder setVehicle(
          com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.Builder builderForValue) {
        if (vehicleBuilder_ == null) {
          vehicle_ = builderForValue.build();
        } else {
          vehicleBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
       */
      public Builder mergeVehicle(com.google.transit.realtime.GtfsRealtime.VehicleDescriptor value) {
        if (vehicleBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            vehicle_ != null &&
            vehicle_ != com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.getDefaultInstance()) {
            getVehicleBuilder().mergeFrom(value);
          } else {
            vehicle_ = value;
          }
        } else {
          vehicleBuilder_.mergeFrom(value);
        }
        if (vehicle_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
       */
      public Builder clearVehicle() {
        bitField0_ = (bitField0_ & ~0x00000002);
        vehicle_ = null;
        if (vehicleBuilder_ != null) {
          vehicleBuilder_.dispose();
          vehicleBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.Builder getVehicleBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getVehicleFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.VehicleDescriptorOrBuilder getVehicleOrBuilder() {
        if (vehicleBuilder_ != null) {
          return vehicleBuilder_.getMessageOrBuilder();
        } else {
          return vehicle_ == null ?
              com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.getDefaultInstance() : vehicle_;
        }
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.VehicleDescriptor, com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.Builder, com.google.transit.realtime.GtfsRealtime.VehicleDescriptorOrBuilder> 
          getVehicleFieldBuilder() {
        if (vehicleBuilder_ == null) {
          vehicleBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.VehicleDescriptor, com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.Builder, com.google.transit.realtime.GtfsRealtime.VehicleDescriptorOrBuilder>(
                  getVehicle(),
                  getParentForChildren(),
                  isClean());
          vehicle_ = null;
        }
        return vehicleBuilder_;
      }

      private java.util.List<com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate> stopTimeUpdate_ =
        java.util.Collections.emptyList();
      private void ensureStopTimeUpdateIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          stopTimeUpdate_ = new java.util.ArrayList<com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate>(stopTimeUpdate_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.Builder, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdateOrBuilder> stopTimeUpdateBuilder_;

      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       *
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       *
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate> getStopTimeUpdateList() {
        if (stopTimeUpdateBuilder_ == null) {
          return java.util.Collections.unmodifiableList(stopTimeUpdate_);
        } else {
          return stopTimeUpdateBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       *
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       *
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public int getStopTimeUpdateCount() {
        if (stopTimeUpdateBuilder_ == null) {
          return stopTimeUpdate_.size();
        } else {
          return stopTimeUpdateBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       *
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       *
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate getStopTimeUpdate(int index) {
        if (stopTimeUpdateBuilder_ == null) {
          return stopTimeUpdate_.get(index);
        } else {
          return stopTimeUpdateBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       *
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       *
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public Builder setStopTimeUpdate(
          int index, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate value) {
        if (stopTimeUpdateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureStopTimeUpdateIsMutable();
          stopTimeUpdate_.set(index, value);
          onChanged();
        } else {
          stopTimeUpdateBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       *
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       *
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public Builder setStopTimeUpdate(
          int index, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.Builder builderForValue) {
        if (stopTimeUpdateBuilder_ == null) {
          ensureStopTimeUpdateIsMutable();
          stopTimeUpdate_.set(index, builderForValue.build());
          onChanged();
        } else {
          stopTimeUpdateBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       *
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       *
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public Builder addStopTimeUpdate(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate value) {
        if (stopTimeUpdateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureStopTimeUpdateIsMutable();
          stopTimeUpdate_.add(value);
          onChanged();
        } else {
          stopTimeUpdateBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       *
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       *
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public Builder addStopTimeUpdate(
          int index, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate value) {
        if (stopTimeUpdateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureStopTimeUpdateIsMutable();
          stopTimeUpdate_.add(index, value);
          onChanged();
        } else {
          stopTimeUpdateBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       *
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       *
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public Builder addStopTimeUpdate(
          com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.Builder builderForValue) {
        if (stopTimeUpdateBuilder_ == null) {
          ensureStopTimeUpdateIsMutable();
          stopTimeUpdate_.add(builderForValue.build());
          onChanged();
        } else {
          stopTimeUpdateBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       *
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       *
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public Builder addStopTimeUpdate(
          int index, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.Builder builderForValue) {
        if (stopTimeUpdateBuilder_ == null) {
          ensureStopTimeUpdateIsMutable();
          stopTimeUpdate_.add(index, builderForValue.build());
          onChanged();
        } else {
          stopTimeUpdateBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       *
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       *
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public Builder addAllStopTimeUpdate(
          java.lang.Iterable<? extends com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate> values) {
        if (stopTimeUpdateBuilder_ == null) {
          ensureStopTimeUpdateIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, stopTimeUpdate_);
          onChanged();
        } else {
          stopTimeUpdateBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       *
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       *
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public Builder clearStopTimeUpdate() {
        if (stopTimeUpdateBuilder_ == null) {
          stopTimeUpdate_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          stopTimeUpdateBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       *
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       *
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public Builder removeStopTimeUpdate(int index) {
        if (stopTimeUpdateBuilder_ == null) {
          ensureStopTimeUpdateIsMutable();
          stopTimeUpdate_.remove(index);
          onChanged();
        } else {
          stopTimeUpdateBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       *
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       *
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.Builder getStopTimeUpdateBuilder(
          int index) {
        return getStopTimeUpdateFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       *
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       *
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdateOrBuilder getStopTimeUpdateOrBuilder(
          int index) {
        if (stopTimeUpdateBuilder_ == null) {
          return stopTimeUpdate_.get(index);  } else {
          return stopTimeUpdateBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       *
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       *
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdateOrBuilder> 
           getStopTimeUpdateOrBuilderList() {
        if (stopTimeUpdateBuilder_ != null) {
          return stopTimeUpdateBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(stopTimeUpdate_);
        }
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       *
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       *
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.Builder addStopTimeUpdateBuilder() {
        return getStopTimeUpdateFieldBuilder().addBuilder(
            com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.getDefaultInstance());
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       *
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       *
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.Builder addStopTimeUpdateBuilder(
          int index) {
        return getStopTimeUpdateFieldBuilder().addBuilder(
            index, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.getDefaultInstance());
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       *
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       *
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.Builder> 
           getStopTimeUpdateBuilderList() {
        return getStopTimeUpdateFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.Builder, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdateOrBuilder> 
          getStopTimeUpdateFieldBuilder() {
        if (stopTimeUpdateBuilder_ == null) {
          stopTimeUpdateBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.Builder, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdateOrBuilder>(
                  stopTimeUpdate_,
                  ((bitField0_ & 0x00000004) != 0),
                  getParentForChildren(),
                  isClean());
          stopTimeUpdate_ = null;
        }
        return stopTimeUpdateBuilder_;
      }

      private long timestamp_ ;
      /**
       * <pre>
       * The most recent moment at which the vehicle's real-time progress was measured
       * to estimate StopTimes in the future. When StopTimes in the past are provided,
       * arrival/departure times may be earlier than this value. In POSIX
       * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 4;</code>
       * @return Whether the timestamp field is set.
       */
      @java.lang.Override
      public boolean hasTimestamp() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The most recent moment at which the vehicle's real-time progress was measured
       * to estimate StopTimes in the future. When StopTimes in the past are provided,
       * arrival/departure times may be earlier than this value. In POSIX
       * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 4;</code>
       * @return The timestamp.
       */
      @java.lang.Override
      public long getTimestamp() {
        return timestamp_;
      }
      /**
       * <pre>
       * The most recent moment at which the vehicle's real-time progress was measured
       * to estimate StopTimes in the future. When StopTimes in the past are provided,
       * arrival/departure times may be earlier than this value. In POSIX
       * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 4;</code>
       * @param value The timestamp to set.
       * @return This builder for chaining.
       */
      public Builder setTimestamp(long value) {

        timestamp_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The most recent moment at which the vehicle's real-time progress was measured
       * to estimate StopTimes in the future. When StopTimes in the past are provided,
       * arrival/departure times may be earlier than this value. In POSIX
       * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearTimestamp() {
        bitField0_ = (bitField0_ & ~0x00000008);
        timestamp_ = 0L;
        onChanged();
        return this;
      }

      private int delay_ ;
      /**
       * <pre>
       * The current schedule deviation for the trip.  Delay should only be
       * specified when the prediction is given relative to some existing schedule
       * in GTFS.
       *
       * Delay (in seconds) can be positive (meaning that the vehicle is late) or
       * negative (meaning that the vehicle is ahead of schedule). Delay of 0
       * means that the vehicle is exactly on time.
       *
       * Delay information in StopTimeUpdates take precedent of trip-level delay
       * information, such that trip-level delay is only propagated until the next
       * stop along the trip with a StopTimeUpdate delay value specified.
       *
       * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
       * value indicating when the delay value was last updated, in order to
       * evaluate the freshness of the data.
       *
       * NOTE: This field is still experimental, and subject to change. It may be
       * formally adopted in the future.
       * </pre>
       *
       * <code>optional int32 delay = 5;</code>
       * @return Whether the delay field is set.
       */
      @java.lang.Override
      public boolean hasDelay() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * The current schedule deviation for the trip.  Delay should only be
       * specified when the prediction is given relative to some existing schedule
       * in GTFS.
       *
       * Delay (in seconds) can be positive (meaning that the vehicle is late) or
       * negative (meaning that the vehicle is ahead of schedule). Delay of 0
       * means that the vehicle is exactly on time.
       *
       * Delay information in StopTimeUpdates take precedent of trip-level delay
       * information, such that trip-level delay is only propagated until the next
       * stop along the trip with a StopTimeUpdate delay value specified.
       *
       * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
       * value indicating when the delay value was last updated, in order to
       * evaluate the freshness of the data.
       *
       * NOTE: This field is still experimental, and subject to change. It may be
       * formally adopted in the future.
       * </pre>
       *
       * <code>optional int32 delay = 5;</code>
       * @return The delay.
       */
      @java.lang.Override
      public int getDelay() {
        return delay_;
      }
      /**
       * <pre>
       * The current schedule deviation for the trip.  Delay should only be
       * specified when the prediction is given relative to some existing schedule
       * in GTFS.
       *
       * Delay (in seconds) can be positive (meaning that the vehicle is late) or
       * negative (meaning that the vehicle is ahead of schedule). Delay of 0
       * means that the vehicle is exactly on time.
       *
       * Delay information in StopTimeUpdates take precedent of trip-level delay
       * information, such that trip-level delay is only propagated until the next
       * stop along the trip with a StopTimeUpdate delay value specified.
       *
       * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
       * value indicating when the delay value was last updated, in order to
       * evaluate the freshness of the data.
       *
       * NOTE: This field is still experimental, and subject to change. It may be
       * formally adopted in the future.
       * </pre>
       *
       * <code>optional int32 delay = 5;</code>
       * @param value The delay to set.
       * @return This builder for chaining.
       */
      public Builder setDelay(int value) {

        delay_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The current schedule deviation for the trip.  Delay should only be
       * specified when the prediction is given relative to some existing schedule
       * in GTFS.
       *
       * Delay (in seconds) can be positive (meaning that the vehicle is late) or
       * negative (meaning that the vehicle is ahead of schedule). Delay of 0
       * means that the vehicle is exactly on time.
       *
       * Delay information in StopTimeUpdates take precedent of trip-level delay
       * information, such that trip-level delay is only propagated until the next
       * stop along the trip with a StopTimeUpdate delay value specified.
       *
       * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
       * value indicating when the delay value was last updated, in order to
       * evaluate the freshness of the data.
       *
       * NOTE: This field is still experimental, and subject to change. It may be
       * formally adopted in the future.
       * </pre>
       *
       * <code>optional int32 delay = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearDelay() {
        bitField0_ = (bitField0_ & ~0x00000010);
        delay_ = 0;
        onChanged();
        return this;
      }

      private com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties tripProperties_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties, com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties.Builder, com.google.transit.realtime.GtfsRealtime.TripUpdate.TripPropertiesOrBuilder> tripPropertiesBuilder_;
      /**
       * <code>optional .transit_realtime.TripUpdate.TripProperties trip_properties = 6;</code>
       * @return Whether the tripProperties field is set.
       */
      public boolean hasTripProperties() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.TripProperties trip_properties = 6;</code>
       * @return The tripProperties.
       */
      public com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties getTripProperties() {
        if (tripPropertiesBuilder_ == null) {
          return tripProperties_ == null ? com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties.getDefaultInstance() : tripProperties_;
        } else {
          return tripPropertiesBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.TripProperties trip_properties = 6;</code>
       */
      public Builder setTripProperties(com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties value) {
        if (tripPropertiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          tripProperties_ = value;
        } else {
          tripPropertiesBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.TripProperties trip_properties = 6;</code>
       */
      public Builder setTripProperties(
          com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties.Builder builderForValue) {
        if (tripPropertiesBuilder_ == null) {
          tripProperties_ = builderForValue.build();
        } else {
          tripPropertiesBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.TripProperties trip_properties = 6;</code>
       */
      public Builder mergeTripProperties(com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties value) {
        if (tripPropertiesBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0) &&
            tripProperties_ != null &&
            tripProperties_ != com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties.getDefaultInstance()) {
            getTripPropertiesBuilder().mergeFrom(value);
          } else {
            tripProperties_ = value;
          }
        } else {
          tripPropertiesBuilder_.mergeFrom(value);
        }
        if (tripProperties_ != null) {
          bitField0_ |= 0x00000020;
          onChanged();
        }
        return this;
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.TripProperties trip_properties = 6;</code>
       */
      public Builder clearTripProperties() {
        bitField0_ = (bitField0_ & ~0x00000020);
        tripProperties_ = null;
        if (tripPropertiesBuilder_ != null) {
          tripPropertiesBuilder_.dispose();
          tripPropertiesBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.TripProperties trip_properties = 6;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties.Builder getTripPropertiesBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getTripPropertiesFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.TripProperties trip_properties = 6;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripUpdate.TripPropertiesOrBuilder getTripPropertiesOrBuilder() {
        if (tripPropertiesBuilder_ != null) {
          return tripPropertiesBuilder_.getMessageOrBuilder();
        } else {
          return tripProperties_ == null ?
              com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties.getDefaultInstance() : tripProperties_;
        }
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.TripProperties trip_properties = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties, com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties.Builder, com.google.transit.realtime.GtfsRealtime.TripUpdate.TripPropertiesOrBuilder> 
          getTripPropertiesFieldBuilder() {
        if (tripPropertiesBuilder_ == null) {
          tripPropertiesBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties, com.google.transit.realtime.GtfsRealtime.TripUpdate.TripProperties.Builder, com.google.transit.realtime.GtfsRealtime.TripUpdate.TripPropertiesOrBuilder>(
                  getTripProperties(),
                  getParentForChildren(),
                  isClean());
          tripProperties_ = null;
        }
        return tripPropertiesBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.TripUpdate)
    }

    // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate)
    private static final com.google.transit.realtime.GtfsRealtime.TripUpdate DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.TripUpdate();
    }

    public static com.google.transit.realtime.GtfsRealtime.TripUpdate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TripUpdate>
        PARSER = new com.google.protobuf.AbstractParser<TripUpdate>() {
      @java.lang.Override
      public TripUpdate parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TripUpdate> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TripUpdate> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripUpdate getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VehiclePositionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_realtime.VehiclePosition)
      com.google.protobuf.GeneratedMessage.
          ExtendableMessageOrBuilder<VehiclePosition> {

    /**
     * <pre>
     * The Trip that this vehicle is serving.
     * Can be empty or partial if the vehicle can not be identified with a given
     * trip instance.
     * </pre>
     *
     * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
     * @return Whether the trip field is set.
     */
    boolean hasTrip();
    /**
     * <pre>
     * The Trip that this vehicle is serving.
     * Can be empty or partial if the vehicle can not be identified with a given
     * trip instance.
     * </pre>
     *
     * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
     * @return The trip.
     */
    com.google.transit.realtime.GtfsRealtime.TripDescriptor getTrip();
    /**
     * <pre>
     * The Trip that this vehicle is serving.
     * Can be empty or partial if the vehicle can not be identified with a given
     * trip instance.
     * </pre>
     *
     * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TripDescriptorOrBuilder getTripOrBuilder();

    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
     * @return Whether the vehicle field is set.
     */
    boolean hasVehicle();
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
     * @return The vehicle.
     */
    com.google.transit.realtime.GtfsRealtime.VehicleDescriptor getVehicle();
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
     */
    com.google.transit.realtime.GtfsRealtime.VehicleDescriptorOrBuilder getVehicleOrBuilder();

    /**
     * <pre>
     * Current position of this vehicle.
     * </pre>
     *
     * <code>optional .transit_realtime.Position position = 2;</code>
     * @return Whether the position field is set.
     */
    boolean hasPosition();
    /**
     * <pre>
     * Current position of this vehicle.
     * </pre>
     *
     * <code>optional .transit_realtime.Position position = 2;</code>
     * @return The position.
     */
    com.google.transit.realtime.GtfsRealtime.Position getPosition();
    /**
     * <pre>
     * Current position of this vehicle.
     * </pre>
     *
     * <code>optional .transit_realtime.Position position = 2;</code>
     */
    com.google.transit.realtime.GtfsRealtime.PositionOrBuilder getPositionOrBuilder();

    /**
     * <pre>
     * The stop sequence index of the current stop. The meaning of
     * current_stop_sequence (i.e., the stop that it refers to) is determined by
     * current_status.
     * If current_status is missing IN_TRANSIT_TO is assumed.
     * </pre>
     *
     * <code>optional uint32 current_stop_sequence = 3;</code>
     * @return Whether the currentStopSequence field is set.
     */
    boolean hasCurrentStopSequence();
    /**
     * <pre>
     * The stop sequence index of the current stop. The meaning of
     * current_stop_sequence (i.e., the stop that it refers to) is determined by
     * current_status.
     * If current_status is missing IN_TRANSIT_TO is assumed.
     * </pre>
     *
     * <code>optional uint32 current_stop_sequence = 3;</code>
     * @return The currentStopSequence.
     */
    int getCurrentStopSequence();

    /**
     * <pre>
     * Identifies the current stop. The value must be the same as in stops.txt in
     * the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional string stop_id = 7;</code>
     * @return Whether the stopId field is set.
     */
    boolean hasStopId();
    /**
     * <pre>
     * Identifies the current stop. The value must be the same as in stops.txt in
     * the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional string stop_id = 7;</code>
     * @return The stopId.
     */
    java.lang.String getStopId();
    /**
     * <pre>
     * Identifies the current stop. The value must be the same as in stops.txt in
     * the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional string stop_id = 7;</code>
     * @return The bytes for stopId.
     */
    com.google.protobuf.ByteString
        getStopIdBytes();

    /**
     * <pre>
     * The exact status of the vehicle with respect to the current stop.
     * Ignored if current_stop_sequence is missing.
     * </pre>
     *
     * <code>optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];</code>
     * @return Whether the currentStatus field is set.
     */
    boolean hasCurrentStatus();
    /**
     * <pre>
     * The exact status of the vehicle with respect to the current stop.
     * Ignored if current_stop_sequence is missing.
     * </pre>
     *
     * <code>optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];</code>
     * @return The currentStatus.
     */
    com.google.transit.realtime.GtfsRealtime.VehiclePosition.VehicleStopStatus getCurrentStatus();

    /**
     * <pre>
     * Moment at which the vehicle's position was measured. In POSIX time
     * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 5;</code>
     * @return Whether the timestamp field is set.
     */
    boolean hasTimestamp();
    /**
     * <pre>
     * Moment at which the vehicle's position was measured. In POSIX time
     * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 5;</code>
     * @return The timestamp.
     */
    long getTimestamp();

    /**
     * <code>optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;</code>
     * @return Whether the congestionLevel field is set.
     */
    boolean hasCongestionLevel();
    /**
     * <code>optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;</code>
     * @return The congestionLevel.
     */
    com.google.transit.realtime.GtfsRealtime.VehiclePosition.CongestionLevel getCongestionLevel();

    /**
     * <pre>
     * If multi_carriage_status is populated with per-carriage OccupancyStatus,
     * then this field should describe the entire vehicle with all carriages accepting passengers considered.
     * </pre>
     *
     * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;</code>
     * @return Whether the occupancyStatus field is set.
     */
    boolean hasOccupancyStatus();
    /**
     * <pre>
     * If multi_carriage_status is populated with per-carriage OccupancyStatus,
     * then this field should describe the entire vehicle with all carriages accepting passengers considered.
     * </pre>
     *
     * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;</code>
     * @return The occupancyStatus.
     */
    com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus getOccupancyStatus();

    /**
     * <pre>
     * A percentage value indicating the degree of passenger occupancy in the vehicle.
     * The values are represented as an integer without decimals. 0 means 0% and 100 means 100%.
     * The value 100 should represent the total maximum occupancy the vehicle was designed for,
     * including both seated and standing capacity, and current operating regulations allow.
     * The value may exceed 100 if there are more passengers than the maximum designed capacity.
     * The precision of occupancy_percentage should be low enough that individual passengers cannot be tracked boarding or alighting the vehicle.
     * If multi_carriage_status is populated with per-carriage occupancy_percentage, 
     * then this field should describe the entire vehicle with all carriages accepting passengers considered.
     * This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional uint32 occupancy_percentage = 10;</code>
     * @return Whether the occupancyPercentage field is set.
     */
    boolean hasOccupancyPercentage();
    /**
     * <pre>
     * A percentage value indicating the degree of passenger occupancy in the vehicle.
     * The values are represented as an integer without decimals. 0 means 0% and 100 means 100%.
     * The value 100 should represent the total maximum occupancy the vehicle was designed for,
     * including both seated and standing capacity, and current operating regulations allow.
     * The value may exceed 100 if there are more passengers than the maximum designed capacity.
     * The precision of occupancy_percentage should be low enough that individual passengers cannot be tracked boarding or alighting the vehicle.
     * If multi_carriage_status is populated with per-carriage occupancy_percentage, 
     * then this field should describe the entire vehicle with all carriages accepting passengers considered.
     * This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional uint32 occupancy_percentage = 10;</code>
     * @return The occupancyPercentage.
     */
    int getOccupancyPercentage();

    /**
     * <pre>
     * Details of the multiple carriages of this given vehicle.
     * The first occurrence represents the first carriage of the vehicle, 
     * given the current direction of travel. 
     * The number of occurrences of the multi_carriage_details 
     * field represents the number of carriages of the vehicle.
     * It also includes non boardable carriages, 
     * like engines, maintenance carriages, etc… as they provide valuable 
     * information to passengers about where to stand on a platform.
     * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
     */
    java.util.List<com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails> 
        getMultiCarriageDetailsList();
    /**
     * <pre>
     * Details of the multiple carriages of this given vehicle.
     * The first occurrence represents the first carriage of the vehicle, 
     * given the current direction of travel. 
     * The number of occurrences of the multi_carriage_details 
     * field represents the number of carriages of the vehicle.
     * It also includes non boardable carriages, 
     * like engines, maintenance carriages, etc… as they provide valuable 
     * information to passengers about where to stand on a platform.
     * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
     */
    com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails getMultiCarriageDetails(int index);
    /**
     * <pre>
     * Details of the multiple carriages of this given vehicle.
     * The first occurrence represents the first carriage of the vehicle, 
     * given the current direction of travel. 
     * The number of occurrences of the multi_carriage_details 
     * field represents the number of carriages of the vehicle.
     * It also includes non boardable carriages, 
     * like engines, maintenance carriages, etc… as they provide valuable 
     * information to passengers about where to stand on a platform.
     * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
     */
    int getMultiCarriageDetailsCount();
    /**
     * <pre>
     * Details of the multiple carriages of this given vehicle.
     * The first occurrence represents the first carriage of the vehicle, 
     * given the current direction of travel. 
     * The number of occurrences of the multi_carriage_details 
     * field represents the number of carriages of the vehicle.
     * It also includes non boardable carriages, 
     * like engines, maintenance carriages, etc… as they provide valuable 
     * information to passengers about where to stand on a platform.
     * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
     */
    java.util.List<? extends com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetailsOrBuilder> 
        getMultiCarriageDetailsOrBuilderList();
    /**
     * <pre>
     * Details of the multiple carriages of this given vehicle.
     * The first occurrence represents the first carriage of the vehicle, 
     * given the current direction of travel. 
     * The number of occurrences of the multi_carriage_details 
     * field represents the number of carriages of the vehicle.
     * It also includes non boardable carriages, 
     * like engines, maintenance carriages, etc… as they provide valuable 
     * information to passengers about where to stand on a platform.
     * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
     */
    com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetailsOrBuilder getMultiCarriageDetailsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * Realtime positioning information for a given vehicle.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.VehiclePosition}
   */
  public static final class VehiclePosition extends
      com.google.protobuf.GeneratedMessage.ExtendableMessage<
        VehiclePosition> implements
      // @@protoc_insertion_point(message_implements:transit_realtime.VehiclePosition)
      VehiclePositionOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 28,
        /* patch= */ 3,
        /* suffix= */ "",
        VehiclePosition.class.getName());
    }
    // Use VehiclePosition.newBuilder() to construct.
    private VehiclePosition(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.VehiclePosition, ?> builder) {
      super(builder);
    }
    private VehiclePosition() {
      stopId_ = "";
      currentStatus_ = 2;
      congestionLevel_ = 0;
      occupancyStatus_ = 0;
      multiCarriageDetails_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_VehiclePosition_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_VehiclePosition_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.transit.realtime.GtfsRealtime.VehiclePosition.class, com.google.transit.realtime.GtfsRealtime.VehiclePosition.Builder.class);
    }

    /**
     * Protobuf enum {@code transit_realtime.VehiclePosition.VehicleStopStatus}
     */
    public enum VehicleStopStatus
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * The vehicle is just about to arrive at the stop (on a stop
       * display, the vehicle symbol typically flashes).
       * </pre>
       *
       * <code>INCOMING_AT = 0;</code>
       */
      INCOMING_AT(0),
      /**
       * <pre>
       * The vehicle is standing at the stop.
       * </pre>
       *
       * <code>STOPPED_AT = 1;</code>
       */
      STOPPED_AT(1),
      /**
       * <pre>
       * The vehicle has departed and is in transit to the next stop.
       * </pre>
       *
       * <code>IN_TRANSIT_TO = 2;</code>
       */
      IN_TRANSIT_TO(2),
      ;

      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 28,
          /* patch= */ 3,
          /* suffix= */ "",
          VehicleStopStatus.class.getName());
      }
      /**
       * <pre>
       * The vehicle is just about to arrive at the stop (on a stop
       * display, the vehicle symbol typically flashes).
       * </pre>
       *
       * <code>INCOMING_AT = 0;</code>
       */
      public static final int INCOMING_AT_VALUE = 0;
      /**
       * <pre>
       * The vehicle is standing at the stop.
       * </pre>
       *
       * <code>STOPPED_AT = 1;</code>
       */
      public static final int STOPPED_AT_VALUE = 1;
      /**
       * <pre>
       * The vehicle has departed and is in transit to the next stop.
       * </pre>
       *
       * <code>IN_TRANSIT_TO = 2;</code>
       */
      public static final int IN_TRANSIT_TO_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static VehicleStopStatus valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static VehicleStopStatus forNumber(int value) {
        switch (value) {
          case 0: return INCOMING_AT;
          case 1: return STOPPED_AT;
          case 2: return IN_TRANSIT_TO;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<VehicleStopStatus>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          VehicleStopStatus> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<VehicleStopStatus>() {
              public VehicleStopStatus findValueByNumber(int number) {
                return VehicleStopStatus.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.VehiclePosition.getDescriptor().getEnumTypes().get(0);
      }

      private static final VehicleStopStatus[] VALUES = values();

      public static VehicleStopStatus valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private VehicleStopStatus(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_realtime.VehiclePosition.VehicleStopStatus)
    }

    /**
     * <pre>
     * Congestion level that is affecting this vehicle.
     * </pre>
     *
     * Protobuf enum {@code transit_realtime.VehiclePosition.CongestionLevel}
     */
    public enum CongestionLevel
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>UNKNOWN_CONGESTION_LEVEL = 0;</code>
       */
      UNKNOWN_CONGESTION_LEVEL(0),
      /**
       * <code>RUNNING_SMOOTHLY = 1;</code>
       */
      RUNNING_SMOOTHLY(1),
      /**
       * <code>STOP_AND_GO = 2;</code>
       */
      STOP_AND_GO(2),
      /**
       * <code>CONGESTION = 3;</code>
       */
      CONGESTION(3),
      /**
       * <pre>
       * People leaving their cars.
       * </pre>
       *
       * <code>SEVERE_CONGESTION = 4;</code>
       */
      SEVERE_CONGESTION(4),
      ;

      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 28,
          /* patch= */ 3,
          /* suffix= */ "",
          CongestionLevel.class.getName());
      }
      /**
       * <code>UNKNOWN_CONGESTION_LEVEL = 0;</code>
       */
      public static final int UNKNOWN_CONGESTION_LEVEL_VALUE = 0;
      /**
       * <code>RUNNING_SMOOTHLY = 1;</code>
       */
      public static final int RUNNING_SMOOTHLY_VALUE = 1;
      /**
       * <code>STOP_AND_GO = 2;</code>
       */
      public static final int STOP_AND_GO_VALUE = 2;
      /**
       * <code>CONGESTION = 3;</code>
       */
      public static final int CONGESTION_VALUE = 3;
      /**
       * <pre>
       * People leaving their cars.
       * </pre>
       *
       * <code>SEVERE_CONGESTION = 4;</code>
       */
      public static final int SEVERE_CONGESTION_VALUE = 4;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static CongestionLevel valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static CongestionLevel forNumber(int value) {
        switch (value) {
          case 0: return UNKNOWN_CONGESTION_LEVEL;
          case 1: return RUNNING_SMOOTHLY;
          case 2: return STOP_AND_GO;
          case 3: return CONGESTION;
          case 4: return SEVERE_CONGESTION;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<CongestionLevel>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          CongestionLevel> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<CongestionLevel>() {
              public CongestionLevel findValueByNumber(int number) {
                return CongestionLevel.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.VehiclePosition.getDescriptor().getEnumTypes().get(1);
      }

      private static final CongestionLevel[] VALUES = values();

      public static CongestionLevel valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private CongestionLevel(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_realtime.VehiclePosition.CongestionLevel)
    }

    /**
     * <pre>
     * The state of passenger occupancy for the vehicle or carriage.
     * Individual producers may not publish all OccupancyStatus values. Therefore, consumers
     * must not assume that the OccupancyStatus values follow a linear scale.
     * Consumers should represent OccupancyStatus values as the state indicated 
     * and intended by the producer. Likewise, producers must use OccupancyStatus values that
     * correspond to actual vehicle occupancy states.
     * For describing passenger occupancy levels on a linear scale, see `occupancy_percentage`.
     * This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * Protobuf enum {@code transit_realtime.VehiclePosition.OccupancyStatus}
     */
    public enum OccupancyStatus
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * The vehicle or carriage is considered empty by most measures, and has few or no
       * passengers onboard, but is still accepting passengers.
       * </pre>
       *
       * <code>EMPTY = 0;</code>
       */
      EMPTY(0),
      /**
       * <pre>
       * The vehicle or carriage has a large number of seats available.
       * The amount of free seats out of the total seats available to be
       * considered large enough to fall into this category is determined at the
       * discretion of the producer.
       * </pre>
       *
       * <code>MANY_SEATS_AVAILABLE = 1;</code>
       */
      MANY_SEATS_AVAILABLE(1),
      /**
       * <pre>
       * The vehicle or carriage has a relatively small number of seats available.
       * The amount of free seats out of the total seats available to be
       * considered small enough to fall into this category is determined at the
       * discretion of the feed producer.
       * </pre>
       *
       * <code>FEW_SEATS_AVAILABLE = 2;</code>
       */
      FEW_SEATS_AVAILABLE(2),
      /**
       * <pre>
       * The vehicle or carriage can currently accommodate only standing passengers.
       * </pre>
       *
       * <code>STANDING_ROOM_ONLY = 3;</code>
       */
      STANDING_ROOM_ONLY(3),
      /**
       * <pre>
       * The vehicle or carriage can currently accommodate only standing passengers
       * and has limited space for them.
       * </pre>
       *
       * <code>CRUSHED_STANDING_ROOM_ONLY = 4;</code>
       */
      CRUSHED_STANDING_ROOM_ONLY(4),
      /**
       * <pre>
       * The vehicle or carriage is considered full by most measures, but may still be
       * allowing passengers to board.
       * </pre>
       *
       * <code>FULL = 5;</code>
       */
      FULL(5),
      /**
       * <pre>
       * The vehicle or carriage is not accepting passengers, but usually accepts passengers for boarding.
       * </pre>
       *
       * <code>NOT_ACCEPTING_PASSENGERS = 6;</code>
       */
      NOT_ACCEPTING_PASSENGERS(6),
      /**
       * <pre>
       * The vehicle or carriage doesn't have any occupancy data available at that time.
       * </pre>
       *
       * <code>NO_DATA_AVAILABLE = 7;</code>
       */
      NO_DATA_AVAILABLE(7),
      /**
       * <pre>
       * The vehicle or carriage is not boardable and never accepts passengers.
       * Useful for special vehicles or carriages (engine, maintenance carriage, etc…).
       * </pre>
       *
       * <code>NOT_BOARDABLE = 8;</code>
       */
      NOT_BOARDABLE(8),
      ;

      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 28,
          /* patch= */ 3,
          /* suffix= */ "",
          OccupancyStatus.class.getName());
      }
      /**
       * <pre>
       * The vehicle or carriage is considered empty by most measures, and has few or no
       * passengers onboard, but is still accepting passengers.
       * </pre>
       *
       * <code>EMPTY = 0;</code>
       */
      public static final int EMPTY_VALUE = 0;
      /**
       * <pre>
       * The vehicle or carriage has a large number of seats available.
       * The amount of free seats out of the total seats available to be
       * considered large enough to fall into this category is determined at the
       * discretion of the producer.
       * </pre>
       *
       * <code>MANY_SEATS_AVAILABLE = 1;</code>
       */
      public static final int MANY_SEATS_AVAILABLE_VALUE = 1;
      /**
       * <pre>
       * The vehicle or carriage has a relatively small number of seats available.
       * The amount of free seats out of the total seats available to be
       * considered small enough to fall into this category is determined at the
       * discretion of the feed producer.
       * </pre>
       *
       * <code>FEW_SEATS_AVAILABLE = 2;</code>
       */
      public static final int FEW_SEATS_AVAILABLE_VALUE = 2;
      /**
       * <pre>
       * The vehicle or carriage can currently accommodate only standing passengers.
       * </pre>
       *
       * <code>STANDING_ROOM_ONLY = 3;</code>
       */
      public static final int STANDING_ROOM_ONLY_VALUE = 3;
      /**
       * <pre>
       * The vehicle or carriage can currently accommodate only standing passengers
       * and has limited space for them.
       * </pre>
       *
       * <code>CRUSHED_STANDING_ROOM_ONLY = 4;</code>
       */
      public static final int CRUSHED_STANDING_ROOM_ONLY_VALUE = 4;
      /**
       * <pre>
       * The vehicle or carriage is considered full by most measures, but may still be
       * allowing passengers to board.
       * </pre>
       *
       * <code>FULL = 5;</code>
       */
      public static final int FULL_VALUE = 5;
      /**
       * <pre>
       * The vehicle or carriage is not accepting passengers, but usually accepts passengers for boarding.
       * </pre>
       *
       * <code>NOT_ACCEPTING_PASSENGERS = 6;</code>
       */
      public static final int NOT_ACCEPTING_PASSENGERS_VALUE = 6;
      /**
       * <pre>
       * The vehicle or carriage doesn't have any occupancy data available at that time.
       * </pre>
       *
       * <code>NO_DATA_AVAILABLE = 7;</code>
       */
      public static final int NO_DATA_AVAILABLE_VALUE = 7;
      /**
       * <pre>
       * The vehicle or carriage is not boardable and never accepts passengers.
       * Useful for special vehicles or carriages (engine, maintenance carriage, etc…).
       * </pre>
       *
       * <code>NOT_BOARDABLE = 8;</code>
       */
      public static final int NOT_BOARDABLE_VALUE = 8;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static OccupancyStatus valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static OccupancyStatus forNumber(int value) {
        switch (value) {
          case 0: return EMPTY;
          case 1: return MANY_SEATS_AVAILABLE;
          case 2: return FEW_SEATS_AVAILABLE;
          case 3: return STANDING_ROOM_ONLY;
          case 4: return CRUSHED_STANDING_ROOM_ONLY;
          case 5: return FULL;
          case 6: return NOT_ACCEPTING_PASSENGERS;
          case 7: return NO_DATA_AVAILABLE;
          case 8: return NOT_BOARDABLE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<OccupancyStatus>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          OccupancyStatus> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<OccupancyStatus>() {
              public OccupancyStatus findValueByNumber(int number) {
                return OccupancyStatus.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.VehiclePosition.getDescriptor().getEnumTypes().get(2);
      }

      private static final OccupancyStatus[] VALUES = values();

      public static OccupancyStatus valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private OccupancyStatus(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_realtime.VehiclePosition.OccupancyStatus)
    }

    public interface CarriageDetailsOrBuilder extends
        // @@protoc_insertion_point(interface_extends:transit_realtime.VehiclePosition.CarriageDetails)
        com.google.protobuf.GeneratedMessage.
            ExtendableMessageOrBuilder<CarriageDetails> {

      /**
       * <pre>
       * Identification of the carriage. Should be unique per vehicle.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       * @return Whether the id field is set.
       */
      boolean hasId();
      /**
       * <pre>
       * Identification of the carriage. Should be unique per vehicle.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       * @return The id.
       */
      java.lang.String getId();
      /**
       * <pre>
       * Identification of the carriage. Should be unique per vehicle.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       * @return The bytes for id.
       */
      com.google.protobuf.ByteString
          getIdBytes();

      /**
       * <pre>
       * User visible label that may be shown to the passenger to help identify
       * the carriage. Example: "7712", "Car ABC-32", etc...
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string label = 2;</code>
       * @return Whether the label field is set.
       */
      boolean hasLabel();
      /**
       * <pre>
       * User visible label that may be shown to the passenger to help identify
       * the carriage. Example: "7712", "Car ABC-32", etc...
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string label = 2;</code>
       * @return The label.
       */
      java.lang.String getLabel();
      /**
       * <pre>
       * User visible label that may be shown to the passenger to help identify
       * the carriage. Example: "7712", "Car ABC-32", etc...
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string label = 2;</code>
       * @return The bytes for label.
       */
      com.google.protobuf.ByteString
          getLabelBytes();

      /**
       * <pre>
       * Occupancy status for this given carriage, in this vehicle
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 3 [default = NO_DATA_AVAILABLE];</code>
       * @return Whether the occupancyStatus field is set.
       */
      boolean hasOccupancyStatus();
      /**
       * <pre>
       * Occupancy status for this given carriage, in this vehicle
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 3 [default = NO_DATA_AVAILABLE];</code>
       * @return The occupancyStatus.
       */
      com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus getOccupancyStatus();

      /**
       * <pre>
       * Occupancy percentage for this given carriage, in this vehicle.
       * Follows the same rules as "VehiclePosition.occupancy_percentage"
       * -1 in case data is not available for this given carriage (as protobuf defaults to 0 otherwise)
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional int32 occupancy_percentage = 4 [default = -1];</code>
       * @return Whether the occupancyPercentage field is set.
       */
      boolean hasOccupancyPercentage();
      /**
       * <pre>
       * Occupancy percentage for this given carriage, in this vehicle.
       * Follows the same rules as "VehiclePosition.occupancy_percentage"
       * -1 in case data is not available for this given carriage (as protobuf defaults to 0 otherwise)
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional int32 occupancy_percentage = 4 [default = -1];</code>
       * @return The occupancyPercentage.
       */
      int getOccupancyPercentage();

      /**
       * <pre>
       * Identifies the order of this carriage with respect to the other
       * carriages in the vehicle's list of CarriageDetails.
       * The first carriage in the direction of travel must have a value of 1.
       * The second value corresponds to the second carriage in the direction
       * of travel and must have a value of 2, and so forth.
       * For example, the first carriage in the direction of travel has a value of 1.
       * If the second carriage in the direction of travel has a value of 3,
       * consumers will discard data for all carriages (i.e., the multi_carriage_details field).
       * Carriages without data must be represented with a valid carriage_sequence number and the fields 
       * without data should be omitted (alternately, those fields could also be included and set to the "no data" values).
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional uint32 carriage_sequence = 5;</code>
       * @return Whether the carriageSequence field is set.
       */
      boolean hasCarriageSequence();
      /**
       * <pre>
       * Identifies the order of this carriage with respect to the other
       * carriages in the vehicle's list of CarriageDetails.
       * The first carriage in the direction of travel must have a value of 1.
       * The second value corresponds to the second carriage in the direction
       * of travel and must have a value of 2, and so forth.
       * For example, the first carriage in the direction of travel has a value of 1.
       * If the second carriage in the direction of travel has a value of 3,
       * consumers will discard data for all carriages (i.e., the multi_carriage_details field).
       * Carriages without data must be represented with a valid carriage_sequence number and the fields 
       * without data should be omitted (alternately, those fields could also be included and set to the "no data" values).
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional uint32 carriage_sequence = 5;</code>
       * @return The carriageSequence.
       */
      int getCarriageSequence();
    }
    /**
     * <pre>
     * Carriage specific details, used for vehicles composed of several carriages
     * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.VehiclePosition.CarriageDetails}
     */
    public static final class CarriageDetails extends
        com.google.protobuf.GeneratedMessage.ExtendableMessage<
          CarriageDetails> implements
        // @@protoc_insertion_point(message_implements:transit_realtime.VehiclePosition.CarriageDetails)
        CarriageDetailsOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 28,
          /* patch= */ 3,
          /* suffix= */ "",
          CarriageDetails.class.getName());
      }
      // Use CarriageDetails.newBuilder() to construct.
      private CarriageDetails(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails, ?> builder) {
        super(builder);
      }
      private CarriageDetails() {
        id_ = "";
        label_ = "";
        occupancyStatus_ = 7;
        occupancyPercentage_ = -1;
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_VehiclePosition_CarriageDetails_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_VehiclePosition_CarriageDetails_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails.class, com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails.Builder.class);
      }

      private int bitField0_;
      public static final int ID_FIELD_NUMBER = 1;
      @SuppressWarnings("serial")
      private volatile java.lang.Object id_ = "";
      /**
       * <pre>
       * Identification of the carriage. Should be unique per vehicle.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       * @return Whether the id field is set.
       */
      @java.lang.Override
      public boolean hasId() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Identification of the carriage. Should be unique per vehicle.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       * @return The id.
       */
      @java.lang.Override
      public java.lang.String getId() {
        java.lang.Object ref = id_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            id_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * Identification of the carriage. Should be unique per vehicle.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       * @return The bytes for id.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getIdBytes() {
        java.lang.Object ref = id_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          id_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int LABEL_FIELD_NUMBER = 2;
      @SuppressWarnings("serial")
      private volatile java.lang.Object label_ = "";
      /**
       * <pre>
       * User visible label that may be shown to the passenger to help identify
       * the carriage. Example: "7712", "Car ABC-32", etc...
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string label = 2;</code>
       * @return Whether the label field is set.
       */
      @java.lang.Override
      public boolean hasLabel() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * User visible label that may be shown to the passenger to help identify
       * the carriage. Example: "7712", "Car ABC-32", etc...
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string label = 2;</code>
       * @return The label.
       */
      @java.lang.Override
      public java.lang.String getLabel() {
        java.lang.Object ref = label_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            label_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * User visible label that may be shown to the passenger to help identify
       * the carriage. Example: "7712", "Car ABC-32", etc...
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string label = 2;</code>
       * @return The bytes for label.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getLabelBytes() {
        java.lang.Object ref = label_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          label_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int OCCUPANCY_STATUS_FIELD_NUMBER = 3;
      private int occupancyStatus_ = 7;
      /**
       * <pre>
       * Occupancy status for this given carriage, in this vehicle
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 3 [default = NO_DATA_AVAILABLE];</code>
       * @return Whether the occupancyStatus field is set.
       */
      @java.lang.Override public boolean hasOccupancyStatus() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Occupancy status for this given carriage, in this vehicle
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 3 [default = NO_DATA_AVAILABLE];</code>
       * @return The occupancyStatus.
       */
      @java.lang.Override public com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus getOccupancyStatus() {
        com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus result = com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus.forNumber(occupancyStatus_);
        return result == null ? com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus.NO_DATA_AVAILABLE : result;
      }

      public static final int OCCUPANCY_PERCENTAGE_FIELD_NUMBER = 4;
      private int occupancyPercentage_ = -1;
      /**
       * <pre>
       * Occupancy percentage for this given carriage, in this vehicle.
       * Follows the same rules as "VehiclePosition.occupancy_percentage"
       * -1 in case data is not available for this given carriage (as protobuf defaults to 0 otherwise)
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional int32 occupancy_percentage = 4 [default = -1];</code>
       * @return Whether the occupancyPercentage field is set.
       */
      @java.lang.Override
      public boolean hasOccupancyPercentage() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Occupancy percentage for this given carriage, in this vehicle.
       * Follows the same rules as "VehiclePosition.occupancy_percentage"
       * -1 in case data is not available for this given carriage (as protobuf defaults to 0 otherwise)
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional int32 occupancy_percentage = 4 [default = -1];</code>
       * @return The occupancyPercentage.
       */
      @java.lang.Override
      public int getOccupancyPercentage() {
        return occupancyPercentage_;
      }

      public static final int CARRIAGE_SEQUENCE_FIELD_NUMBER = 5;
      private int carriageSequence_ = 0;
      /**
       * <pre>
       * Identifies the order of this carriage with respect to the other
       * carriages in the vehicle's list of CarriageDetails.
       * The first carriage in the direction of travel must have a value of 1.
       * The second value corresponds to the second carriage in the direction
       * of travel and must have a value of 2, and so forth.
       * For example, the first carriage in the direction of travel has a value of 1.
       * If the second carriage in the direction of travel has a value of 3,
       * consumers will discard data for all carriages (i.e., the multi_carriage_details field).
       * Carriages without data must be represented with a valid carriage_sequence number and the fields 
       * without data should be omitted (alternately, those fields could also be included and set to the "no data" values).
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional uint32 carriage_sequence = 5;</code>
       * @return Whether the carriageSequence field is set.
       */
      @java.lang.Override
      public boolean hasCarriageSequence() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Identifies the order of this carriage with respect to the other
       * carriages in the vehicle's list of CarriageDetails.
       * The first carriage in the direction of travel must have a value of 1.
       * The second value corresponds to the second carriage in the direction
       * of travel and must have a value of 2, and so forth.
       * For example, the first carriage in the direction of travel has a value of 1.
       * If the second carriage in the direction of travel has a value of 3,
       * consumers will discard data for all carriages (i.e., the multi_carriage_details field).
       * Carriages without data must be represented with a valid carriage_sequence number and the fields 
       * without data should be omitted (alternately, those fields could also be included and set to the "no data" values).
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional uint32 carriage_sequence = 5;</code>
       * @return The carriageSequence.
       */
      @java.lang.Override
      public int getCarriageSequence() {
        return carriageSequence_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        if (!extensionsAreInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        com.google.protobuf.GeneratedMessage
          .ExtendableMessage.ExtensionSerializer
            extensionWriter = newExtensionSerializer();
        if (((bitField0_ & 0x00000001) != 0)) {
          com.google.protobuf.GeneratedMessage.writeString(output, 1, id_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          com.google.protobuf.GeneratedMessage.writeString(output, 2, label_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          output.writeEnum(3, occupancyStatus_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          output.writeInt32(4, occupancyPercentage_);
        }
        if (((bitField0_ & 0x00000010) != 0)) {
          output.writeUInt32(5, carriageSequence_);
        }
        extensionWriter.writeUntil(10000, output);
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.GeneratedMessage.computeStringSize(1, id_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.GeneratedMessage.computeStringSize(2, label_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(3, occupancyStatus_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(4, occupancyPercentage_);
        }
        if (((bitField0_ & 0x00000010) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(5, carriageSequence_);
        }
        size += extensionsSerializedSize();
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails)) {
          return super.equals(obj);
        }
        com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails other = (com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails) obj;

        if (hasId() != other.hasId()) return false;
        if (hasId()) {
          if (!getId()
              .equals(other.getId())) return false;
        }
        if (hasLabel() != other.hasLabel()) return false;
        if (hasLabel()) {
          if (!getLabel()
              .equals(other.getLabel())) return false;
        }
        if (hasOccupancyStatus() != other.hasOccupancyStatus()) return false;
        if (hasOccupancyStatus()) {
          if (occupancyStatus_ != other.occupancyStatus_) return false;
        }
        if (hasOccupancyPercentage() != other.hasOccupancyPercentage()) return false;
        if (hasOccupancyPercentage()) {
          if (getOccupancyPercentage()
              != other.getOccupancyPercentage()) return false;
        }
        if (hasCarriageSequence() != other.hasCarriageSequence()) return false;
        if (hasCarriageSequence()) {
          if (getCarriageSequence()
              != other.getCarriageSequence()) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        if (!getExtensionFields().equals(other.getExtensionFields()))
          return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasId()) {
          hash = (37 * hash) + ID_FIELD_NUMBER;
          hash = (53 * hash) + getId().hashCode();
        }
        if (hasLabel()) {
          hash = (37 * hash) + LABEL_FIELD_NUMBER;
          hash = (53 * hash) + getLabel().hashCode();
        }
        if (hasOccupancyStatus()) {
          hash = (37 * hash) + OCCUPANCY_STATUS_FIELD_NUMBER;
          hash = (53 * hash) + occupancyStatus_;
        }
        if (hasOccupancyPercentage()) {
          hash = (37 * hash) + OCCUPANCY_PERCENTAGE_FIELD_NUMBER;
          hash = (53 * hash) + getOccupancyPercentage();
        }
        if (hasCarriageSequence()) {
          hash = (37 * hash) + CARRIAGE_SEQUENCE_FIELD_NUMBER;
          hash = (53 * hash) + getCarriageSequence();
        }
        hash = hashFields(hash, getExtensionFields());
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Carriage specific details, used for vehicles composed of several carriages
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * Protobuf type {@code transit_realtime.VehiclePosition.CarriageDetails}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.ExtendableBuilder<
            com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails, Builder> implements
          // @@protoc_insertion_point(builder_implements:transit_realtime.VehiclePosition.CarriageDetails)
          com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetailsOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_VehiclePosition_CarriageDetails_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_VehiclePosition_CarriageDetails_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails.class, com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails.Builder.class);
        }

        // Construct using com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          id_ = "";
          label_ = "";
          occupancyStatus_ = 7;
          occupancyPercentage_ = -1;
          carriageSequence_ = 0;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_VehiclePosition_CarriageDetails_descriptor;
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails getDefaultInstanceForType() {
          return com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails.getDefaultInstance();
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails build() {
          com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails buildPartial() {
          com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails result = new com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.id_ = id_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.label_ = label_;
            to_bitField0_ |= 0x00000002;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.occupancyStatus_ = occupancyStatus_;
            to_bitField0_ |= 0x00000004;
          }
          if (((from_bitField0_ & 0x00000008) != 0)) {
            result.occupancyPercentage_ = occupancyPercentage_;
            to_bitField0_ |= 0x00000008;
          }
          if (((from_bitField0_ & 0x00000010) != 0)) {
            result.carriageSequence_ = carriageSequence_;
            to_bitField0_ |= 0x00000010;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails) {
            return mergeFrom((com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails other) {
          if (other == com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails.getDefaultInstance()) return this;
          if (other.hasId()) {
            id_ = other.id_;
            bitField0_ |= 0x00000001;
            onChanged();
          }
          if (other.hasLabel()) {
            label_ = other.label_;
            bitField0_ |= 0x00000002;
            onChanged();
          }
          if (other.hasOccupancyStatus()) {
            setOccupancyStatus(other.getOccupancyStatus());
          }
          if (other.hasOccupancyPercentage()) {
            setOccupancyPercentage(other.getOccupancyPercentage());
          }
          if (other.hasCarriageSequence()) {
            setCarriageSequence(other.getCarriageSequence());
          }
          this.mergeExtensionFields(other);
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          if (!extensionsAreInitialized()) {
            return false;
          }
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 10: {
                  id_ = input.readBytes();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
                case 18: {
                  label_ = input.readBytes();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
                case 24: {
                  int tmpRaw = input.readEnum();
                  com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus tmpValue =
                      com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(3, tmpRaw);
                  } else {
                    occupancyStatus_ = tmpRaw;
                    bitField0_ |= 0x00000004;
                  }
                  break;
                } // case 24
                case 32: {
                  occupancyPercentage_ = input.readInt32();
                  bitField0_ |= 0x00000008;
                  break;
                } // case 32
                case 40: {
                  carriageSequence_ = input.readUInt32();
                  bitField0_ |= 0x00000010;
                  break;
                } // case 40
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private java.lang.Object id_ = "";
        /**
         * <pre>
         * Identification of the carriage. Should be unique per vehicle.
         * </pre>
         *
         * <code>optional string id = 1;</code>
         * @return Whether the id field is set.
         */
        public boolean hasId() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * Identification of the carriage. Should be unique per vehicle.
         * </pre>
         *
         * <code>optional string id = 1;</code>
         * @return The id.
         */
        public java.lang.String getId() {
          java.lang.Object ref = id_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              id_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * Identification of the carriage. Should be unique per vehicle.
         * </pre>
         *
         * <code>optional string id = 1;</code>
         * @return The bytes for id.
         */
        public com.google.protobuf.ByteString
            getIdBytes() {
          java.lang.Object ref = id_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            id_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * Identification of the carriage. Should be unique per vehicle.
         * </pre>
         *
         * <code>optional string id = 1;</code>
         * @param value The id to set.
         * @return This builder for chaining.
         */
        public Builder setId(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          id_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Identification of the carriage. Should be unique per vehicle.
         * </pre>
         *
         * <code>optional string id = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearId() {
          id_ = getDefaultInstance().getId();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Identification of the carriage. Should be unique per vehicle.
         * </pre>
         *
         * <code>optional string id = 1;</code>
         * @param value The bytes for id to set.
         * @return This builder for chaining.
         */
        public Builder setIdBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          id_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }

        private java.lang.Object label_ = "";
        /**
         * <pre>
         * User visible label that may be shown to the passenger to help identify
         * the carriage. Example: "7712", "Car ABC-32", etc...
         * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string label = 2;</code>
         * @return Whether the label field is set.
         */
        public boolean hasLabel() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * User visible label that may be shown to the passenger to help identify
         * the carriage. Example: "7712", "Car ABC-32", etc...
         * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string label = 2;</code>
         * @return The label.
         */
        public java.lang.String getLabel() {
          java.lang.Object ref = label_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              label_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * User visible label that may be shown to the passenger to help identify
         * the carriage. Example: "7712", "Car ABC-32", etc...
         * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string label = 2;</code>
         * @return The bytes for label.
         */
        public com.google.protobuf.ByteString
            getLabelBytes() {
          java.lang.Object ref = label_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            label_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * User visible label that may be shown to the passenger to help identify
         * the carriage. Example: "7712", "Car ABC-32", etc...
         * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string label = 2;</code>
         * @param value The label to set.
         * @return This builder for chaining.
         */
        public Builder setLabel(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          label_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * User visible label that may be shown to the passenger to help identify
         * the carriage. Example: "7712", "Car ABC-32", etc...
         * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string label = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearLabel() {
          label_ = getDefaultInstance().getLabel();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * User visible label that may be shown to the passenger to help identify
         * the carriage. Example: "7712", "Car ABC-32", etc...
         * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional string label = 2;</code>
         * @param value The bytes for label to set.
         * @return This builder for chaining.
         */
        public Builder setLabelBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          label_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }

        private int occupancyStatus_ = 7;
        /**
         * <pre>
         * Occupancy status for this given carriage, in this vehicle
         * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 3 [default = NO_DATA_AVAILABLE];</code>
         * @return Whether the occupancyStatus field is set.
         */
        @java.lang.Override public boolean hasOccupancyStatus() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * Occupancy status for this given carriage, in this vehicle
         * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 3 [default = NO_DATA_AVAILABLE];</code>
         * @return The occupancyStatus.
         */
        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus getOccupancyStatus() {
          com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus result = com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus.forNumber(occupancyStatus_);
          return result == null ? com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus.NO_DATA_AVAILABLE : result;
        }
        /**
         * <pre>
         * Occupancy status for this given carriage, in this vehicle
         * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 3 [default = NO_DATA_AVAILABLE];</code>
         * @param value The occupancyStatus to set.
         * @return This builder for chaining.
         */
        public Builder setOccupancyStatus(com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000004;
          occupancyStatus_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Occupancy status for this given carriage, in this vehicle
         * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 3 [default = NO_DATA_AVAILABLE];</code>
         * @return This builder for chaining.
         */
        public Builder clearOccupancyStatus() {
          bitField0_ = (bitField0_ & ~0x00000004);
          occupancyStatus_ = 7;
          onChanged();
          return this;
        }

        private int occupancyPercentage_ = -1;
        /**
         * <pre>
         * Occupancy percentage for this given carriage, in this vehicle.
         * Follows the same rules as "VehiclePosition.occupancy_percentage"
         * -1 in case data is not available for this given carriage (as protobuf defaults to 0 otherwise)
         * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional int32 occupancy_percentage = 4 [default = -1];</code>
         * @return Whether the occupancyPercentage field is set.
         */
        @java.lang.Override
        public boolean hasOccupancyPercentage() {
          return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <pre>
         * Occupancy percentage for this given carriage, in this vehicle.
         * Follows the same rules as "VehiclePosition.occupancy_percentage"
         * -1 in case data is not available for this given carriage (as protobuf defaults to 0 otherwise)
         * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional int32 occupancy_percentage = 4 [default = -1];</code>
         * @return The occupancyPercentage.
         */
        @java.lang.Override
        public int getOccupancyPercentage() {
          return occupancyPercentage_;
        }
        /**
         * <pre>
         * Occupancy percentage for this given carriage, in this vehicle.
         * Follows the same rules as "VehiclePosition.occupancy_percentage"
         * -1 in case data is not available for this given carriage (as protobuf defaults to 0 otherwise)
         * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional int32 occupancy_percentage = 4 [default = -1];</code>
         * @param value The occupancyPercentage to set.
         * @return This builder for chaining.
         */
        public Builder setOccupancyPercentage(int value) {

          occupancyPercentage_ = value;
          bitField0_ |= 0x00000008;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Occupancy percentage for this given carriage, in this vehicle.
         * Follows the same rules as "VehiclePosition.occupancy_percentage"
         * -1 in case data is not available for this given carriage (as protobuf defaults to 0 otherwise)
         * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional int32 occupancy_percentage = 4 [default = -1];</code>
         * @return This builder for chaining.
         */
        public Builder clearOccupancyPercentage() {
          bitField0_ = (bitField0_ & ~0x00000008);
          occupancyPercentage_ = -1;
          onChanged();
          return this;
        }

        private int carriageSequence_ ;
        /**
         * <pre>
         * Identifies the order of this carriage with respect to the other
         * carriages in the vehicle's list of CarriageDetails.
         * The first carriage in the direction of travel must have a value of 1.
         * The second value corresponds to the second carriage in the direction
         * of travel and must have a value of 2, and so forth.
         * For example, the first carriage in the direction of travel has a value of 1.
         * If the second carriage in the direction of travel has a value of 3,
         * consumers will discard data for all carriages (i.e., the multi_carriage_details field).
         * Carriages without data must be represented with a valid carriage_sequence number and the fields 
         * without data should be omitted (alternately, those fields could also be included and set to the "no data" values).
         * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional uint32 carriage_sequence = 5;</code>
         * @return Whether the carriageSequence field is set.
         */
        @java.lang.Override
        public boolean hasCarriageSequence() {
          return ((bitField0_ & 0x00000010) != 0);
        }
        /**
         * <pre>
         * Identifies the order of this carriage with respect to the other
         * carriages in the vehicle's list of CarriageDetails.
         * The first carriage in the direction of travel must have a value of 1.
         * The second value corresponds to the second carriage in the direction
         * of travel and must have a value of 2, and so forth.
         * For example, the first carriage in the direction of travel has a value of 1.
         * If the second carriage in the direction of travel has a value of 3,
         * consumers will discard data for all carriages (i.e., the multi_carriage_details field).
         * Carriages without data must be represented with a valid carriage_sequence number and the fields 
         * without data should be omitted (alternately, those fields could also be included and set to the "no data" values).
         * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional uint32 carriage_sequence = 5;</code>
         * @return The carriageSequence.
         */
        @java.lang.Override
        public int getCarriageSequence() {
          return carriageSequence_;
        }
        /**
         * <pre>
         * Identifies the order of this carriage with respect to the other
         * carriages in the vehicle's list of CarriageDetails.
         * The first carriage in the direction of travel must have a value of 1.
         * The second value corresponds to the second carriage in the direction
         * of travel and must have a value of 2, and so forth.
         * For example, the first carriage in the direction of travel has a value of 1.
         * If the second carriage in the direction of travel has a value of 3,
         * consumers will discard data for all carriages (i.e., the multi_carriage_details field).
         * Carriages without data must be represented with a valid carriage_sequence number and the fields 
         * without data should be omitted (alternately, those fields could also be included and set to the "no data" values).
         * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional uint32 carriage_sequence = 5;</code>
         * @param value The carriageSequence to set.
         * @return This builder for chaining.
         */
        public Builder setCarriageSequence(int value) {

          carriageSequence_ = value;
          bitField0_ |= 0x00000010;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Identifies the order of this carriage with respect to the other
         * carriages in the vehicle's list of CarriageDetails.
         * The first carriage in the direction of travel must have a value of 1.
         * The second value corresponds to the second carriage in the direction
         * of travel and must have a value of 2, and so forth.
         * For example, the first carriage in the direction of travel has a value of 1.
         * If the second carriage in the direction of travel has a value of 3,
         * consumers will discard data for all carriages (i.e., the multi_carriage_details field).
         * Carriages without data must be represented with a valid carriage_sequence number and the fields 
         * without data should be omitted (alternately, those fields could also be included and set to the "no data" values).
         * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
         * </pre>
         *
         * <code>optional uint32 carriage_sequence = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearCarriageSequence() {
          bitField0_ = (bitField0_ & ~0x00000010);
          carriageSequence_ = 0;
          onChanged();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:transit_realtime.VehiclePosition.CarriageDetails)
      }

      // @@protoc_insertion_point(class_scope:transit_realtime.VehiclePosition.CarriageDetails)
      private static final com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails();
      }

      public static com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<CarriageDetails>
          PARSER = new com.google.protobuf.AbstractParser<CarriageDetails>() {
        @java.lang.Override
        public CarriageDetails parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<CarriageDetails> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<CarriageDetails> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    public static final int TRIP_FIELD_NUMBER = 1;
    private com.google.transit.realtime.GtfsRealtime.TripDescriptor trip_;
    /**
     * <pre>
     * The Trip that this vehicle is serving.
     * Can be empty or partial if the vehicle can not be identified with a given
     * trip instance.
     * </pre>
     *
     * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
     * @return Whether the trip field is set.
     */
    @java.lang.Override
    public boolean hasTrip() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The Trip that this vehicle is serving.
     * Can be empty or partial if the vehicle can not be identified with a given
     * trip instance.
     * </pre>
     *
     * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
     * @return The trip.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripDescriptor getTrip() {
      return trip_ == null ? com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance() : trip_;
    }
    /**
     * <pre>
     * The Trip that this vehicle is serving.
     * Can be empty or partial if the vehicle can not be identified with a given
     * trip instance.
     * </pre>
     *
     * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripDescriptorOrBuilder getTripOrBuilder() {
      return trip_ == null ? com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance() : trip_;
    }

    public static final int VEHICLE_FIELD_NUMBER = 8;
    private com.google.transit.realtime.GtfsRealtime.VehicleDescriptor vehicle_;
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
     * @return Whether the vehicle field is set.
     */
    @java.lang.Override
    public boolean hasVehicle() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
     * @return The vehicle.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.VehicleDescriptor getVehicle() {
      return vehicle_ == null ? com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.getDefaultInstance() : vehicle_;
    }
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.VehicleDescriptorOrBuilder getVehicleOrBuilder() {
      return vehicle_ == null ? com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.getDefaultInstance() : vehicle_;
    }

    public static final int POSITION_FIELD_NUMBER = 2;
    private com.google.transit.realtime.GtfsRealtime.Position position_;
    /**
     * <pre>
     * Current position of this vehicle.
     * </pre>
     *
     * <code>optional .transit_realtime.Position position = 2;</code>
     * @return Whether the position field is set.
     */
    @java.lang.Override
    public boolean hasPosition() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Current position of this vehicle.
     * </pre>
     *
     * <code>optional .transit_realtime.Position position = 2;</code>
     * @return The position.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.Position getPosition() {
      return position_ == null ? com.google.transit.realtime.GtfsRealtime.Position.getDefaultInstance() : position_;
    }
    /**
     * <pre>
     * Current position of this vehicle.
     * </pre>
     *
     * <code>optional .transit_realtime.Position position = 2;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.PositionOrBuilder getPositionOrBuilder() {
      return position_ == null ? com.google.transit.realtime.GtfsRealtime.Position.getDefaultInstance() : position_;
    }

    public static final int CURRENT_STOP_SEQUENCE_FIELD_NUMBER = 3;
    private int currentStopSequence_ = 0;
    /**
     * <pre>
     * The stop sequence index of the current stop. The meaning of
     * current_stop_sequence (i.e., the stop that it refers to) is determined by
     * current_status.
     * If current_status is missing IN_TRANSIT_TO is assumed.
     * </pre>
     *
     * <code>optional uint32 current_stop_sequence = 3;</code>
     * @return Whether the currentStopSequence field is set.
     */
    @java.lang.Override
    public boolean hasCurrentStopSequence() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The stop sequence index of the current stop. The meaning of
     * current_stop_sequence (i.e., the stop that it refers to) is determined by
     * current_status.
     * If current_status is missing IN_TRANSIT_TO is assumed.
     * </pre>
     *
     * <code>optional uint32 current_stop_sequence = 3;</code>
     * @return The currentStopSequence.
     */
    @java.lang.Override
    public int getCurrentStopSequence() {
      return currentStopSequence_;
    }

    public static final int STOP_ID_FIELD_NUMBER = 7;
    @SuppressWarnings("serial")
    private volatile java.lang.Object stopId_ = "";
    /**
     * <pre>
     * Identifies the current stop. The value must be the same as in stops.txt in
     * the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional string stop_id = 7;</code>
     * @return Whether the stopId field is set.
     */
    @java.lang.Override
    public boolean hasStopId() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Identifies the current stop. The value must be the same as in stops.txt in
     * the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional string stop_id = 7;</code>
     * @return The stopId.
     */
    @java.lang.Override
    public java.lang.String getStopId() {
      java.lang.Object ref = stopId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          stopId_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Identifies the current stop. The value must be the same as in stops.txt in
     * the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional string stop_id = 7;</code>
     * @return The bytes for stopId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStopIdBytes() {
      java.lang.Object ref = stopId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        stopId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CURRENT_STATUS_FIELD_NUMBER = 4;
    private int currentStatus_ = 2;
    /**
     * <pre>
     * The exact status of the vehicle with respect to the current stop.
     * Ignored if current_stop_sequence is missing.
     * </pre>
     *
     * <code>optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];</code>
     * @return Whether the currentStatus field is set.
     */
    @java.lang.Override public boolean hasCurrentStatus() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * The exact status of the vehicle with respect to the current stop.
     * Ignored if current_stop_sequence is missing.
     * </pre>
     *
     * <code>optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];</code>
     * @return The currentStatus.
     */
    @java.lang.Override public com.google.transit.realtime.GtfsRealtime.VehiclePosition.VehicleStopStatus getCurrentStatus() {
      com.google.transit.realtime.GtfsRealtime.VehiclePosition.VehicleStopStatus result = com.google.transit.realtime.GtfsRealtime.VehiclePosition.VehicleStopStatus.forNumber(currentStatus_);
      return result == null ? com.google.transit.realtime.GtfsRealtime.VehiclePosition.VehicleStopStatus.IN_TRANSIT_TO : result;
    }

    public static final int TIMESTAMP_FIELD_NUMBER = 5;
    private long timestamp_ = 0L;
    /**
     * <pre>
     * Moment at which the vehicle's position was measured. In POSIX time
     * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 5;</code>
     * @return Whether the timestamp field is set.
     */
    @java.lang.Override
    public boolean hasTimestamp() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Moment at which the vehicle's position was measured. In POSIX time
     * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 5;</code>
     * @return The timestamp.
     */
    @java.lang.Override
    public long getTimestamp() {
      return timestamp_;
    }

    public static final int CONGESTION_LEVEL_FIELD_NUMBER = 6;
    private int congestionLevel_ = 0;
    /**
     * <code>optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;</code>
     * @return Whether the congestionLevel field is set.
     */
    @java.lang.Override public boolean hasCongestionLevel() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <code>optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;</code>
     * @return The congestionLevel.
     */
    @java.lang.Override public com.google.transit.realtime.GtfsRealtime.VehiclePosition.CongestionLevel getCongestionLevel() {
      com.google.transit.realtime.GtfsRealtime.VehiclePosition.CongestionLevel result = com.google.transit.realtime.GtfsRealtime.VehiclePosition.CongestionLevel.forNumber(congestionLevel_);
      return result == null ? com.google.transit.realtime.GtfsRealtime.VehiclePosition.CongestionLevel.UNKNOWN_CONGESTION_LEVEL : result;
    }

    public static final int OCCUPANCY_STATUS_FIELD_NUMBER = 9;
    private int occupancyStatus_ = 0;
    /**
     * <pre>
     * If multi_carriage_status is populated with per-carriage OccupancyStatus,
     * then this field should describe the entire vehicle with all carriages accepting passengers considered.
     * </pre>
     *
     * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;</code>
     * @return Whether the occupancyStatus field is set.
     */
    @java.lang.Override public boolean hasOccupancyStatus() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * If multi_carriage_status is populated with per-carriage OccupancyStatus,
     * then this field should describe the entire vehicle with all carriages accepting passengers considered.
     * </pre>
     *
     * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;</code>
     * @return The occupancyStatus.
     */
    @java.lang.Override public com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus getOccupancyStatus() {
      com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus result = com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus.forNumber(occupancyStatus_);
      return result == null ? com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus.EMPTY : result;
    }

    public static final int OCCUPANCY_PERCENTAGE_FIELD_NUMBER = 10;
    private int occupancyPercentage_ = 0;
    /**
     * <pre>
     * A percentage value indicating the degree of passenger occupancy in the vehicle.
     * The values are represented as an integer without decimals. 0 means 0% and 100 means 100%.
     * The value 100 should represent the total maximum occupancy the vehicle was designed for,
     * including both seated and standing capacity, and current operating regulations allow.
     * The value may exceed 100 if there are more passengers than the maximum designed capacity.
     * The precision of occupancy_percentage should be low enough that individual passengers cannot be tracked boarding or alighting the vehicle.
     * If multi_carriage_status is populated with per-carriage occupancy_percentage, 
     * then this field should describe the entire vehicle with all carriages accepting passengers considered.
     * This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional uint32 occupancy_percentage = 10;</code>
     * @return Whether the occupancyPercentage field is set.
     */
    @java.lang.Override
    public boolean hasOccupancyPercentage() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * A percentage value indicating the degree of passenger occupancy in the vehicle.
     * The values are represented as an integer without decimals. 0 means 0% and 100 means 100%.
     * The value 100 should represent the total maximum occupancy the vehicle was designed for,
     * including both seated and standing capacity, and current operating regulations allow.
     * The value may exceed 100 if there are more passengers than the maximum designed capacity.
     * The precision of occupancy_percentage should be low enough that individual passengers cannot be tracked boarding or alighting the vehicle.
     * If multi_carriage_status is populated with per-carriage occupancy_percentage, 
     * then this field should describe the entire vehicle with all carriages accepting passengers considered.
     * This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional uint32 occupancy_percentage = 10;</code>
     * @return The occupancyPercentage.
     */
    @java.lang.Override
    public int getOccupancyPercentage() {
      return occupancyPercentage_;
    }

    public static final int MULTI_CARRIAGE_DETAILS_FIELD_NUMBER = 11;
    @SuppressWarnings("serial")
    private java.util.List<com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails> multiCarriageDetails_;
    /**
     * <pre>
     * Details of the multiple carriages of this given vehicle.
     * The first occurrence represents the first carriage of the vehicle, 
     * given the current direction of travel. 
     * The number of occurrences of the multi_carriage_details 
     * field represents the number of carriages of the vehicle.
     * It also includes non boardable carriages, 
     * like engines, maintenance carriages, etc… as they provide valuable 
     * information to passengers about where to stand on a platform.
     * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails> getMultiCarriageDetailsList() {
      return multiCarriageDetails_;
    }
    /**
     * <pre>
     * Details of the multiple carriages of this given vehicle.
     * The first occurrence represents the first carriage of the vehicle, 
     * given the current direction of travel. 
     * The number of occurrences of the multi_carriage_details 
     * field represents the number of carriages of the vehicle.
     * It also includes non boardable carriages, 
     * like engines, maintenance carriages, etc… as they provide valuable 
     * information to passengers about where to stand on a platform.
     * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
     */
    @java.lang.Override
    public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetailsOrBuilder> 
        getMultiCarriageDetailsOrBuilderList() {
      return multiCarriageDetails_;
    }
    /**
     * <pre>
     * Details of the multiple carriages of this given vehicle.
     * The first occurrence represents the first carriage of the vehicle, 
     * given the current direction of travel. 
     * The number of occurrences of the multi_carriage_details 
     * field represents the number of carriages of the vehicle.
     * It also includes non boardable carriages, 
     * like engines, maintenance carriages, etc… as they provide valuable 
     * information to passengers about where to stand on a platform.
     * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
     */
    @java.lang.Override
    public int getMultiCarriageDetailsCount() {
      return multiCarriageDetails_.size();
    }
    /**
     * <pre>
     * Details of the multiple carriages of this given vehicle.
     * The first occurrence represents the first carriage of the vehicle, 
     * given the current direction of travel. 
     * The number of occurrences of the multi_carriage_details 
     * field represents the number of carriages of the vehicle.
     * It also includes non boardable carriages, 
     * like engines, maintenance carriages, etc… as they provide valuable 
     * information to passengers about where to stand on a platform.
     * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails getMultiCarriageDetails(int index) {
      return multiCarriageDetails_.get(index);
    }
    /**
     * <pre>
     * Details of the multiple carriages of this given vehicle.
     * The first occurrence represents the first carriage of the vehicle, 
     * given the current direction of travel. 
     * The number of occurrences of the multi_carriage_details 
     * field represents the number of carriages of the vehicle.
     * It also includes non boardable carriages, 
     * like engines, maintenance carriages, etc… as they provide valuable 
     * information to passengers about where to stand on a platform.
     * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetailsOrBuilder getMultiCarriageDetailsOrBuilder(
        int index) {
      return multiCarriageDetails_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (hasTrip()) {
        if (!getTrip().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasVehicle()) {
        if (!getVehicle().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasPosition()) {
        if (!getPosition().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      for (int i = 0; i < getMultiCarriageDetailsCount(); i++) {
        if (!getMultiCarriageDetails(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (!extensionsAreInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessage
        .ExtendableMessage.ExtensionSerializer
          extensionWriter = newExtensionSerializer();
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getTrip());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(2, getPosition());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeUInt32(3, currentStopSequence_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeEnum(4, currentStatus_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeUInt64(5, timestamp_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeEnum(6, congestionLevel_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 7, stopId_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(8, getVehicle());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeEnum(9, occupancyStatus_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeUInt32(10, occupancyPercentage_);
      }
      for (int i = 0; i < multiCarriageDetails_.size(); i++) {
        output.writeMessage(11, multiCarriageDetails_.get(i));
      }
      extensionWriter.writeUntil(10000, output);
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getTrip());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getPosition());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(3, currentStopSequence_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(4, currentStatus_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(5, timestamp_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(6, congestionLevel_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(7, stopId_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getVehicle());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(9, occupancyStatus_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(10, occupancyPercentage_);
      }
      for (int i = 0; i < multiCarriageDetails_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, multiCarriageDetails_.get(i));
      }
      size += extensionsSerializedSize();
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.VehiclePosition)) {
        return super.equals(obj);
      }
      com.google.transit.realtime.GtfsRealtime.VehiclePosition other = (com.google.transit.realtime.GtfsRealtime.VehiclePosition) obj;

      if (hasTrip() != other.hasTrip()) return false;
      if (hasTrip()) {
        if (!getTrip()
            .equals(other.getTrip())) return false;
      }
      if (hasVehicle() != other.hasVehicle()) return false;
      if (hasVehicle()) {
        if (!getVehicle()
            .equals(other.getVehicle())) return false;
      }
      if (hasPosition() != other.hasPosition()) return false;
      if (hasPosition()) {
        if (!getPosition()
            .equals(other.getPosition())) return false;
      }
      if (hasCurrentStopSequence() != other.hasCurrentStopSequence()) return false;
      if (hasCurrentStopSequence()) {
        if (getCurrentStopSequence()
            != other.getCurrentStopSequence()) return false;
      }
      if (hasStopId() != other.hasStopId()) return false;
      if (hasStopId()) {
        if (!getStopId()
            .equals(other.getStopId())) return false;
      }
      if (hasCurrentStatus() != other.hasCurrentStatus()) return false;
      if (hasCurrentStatus()) {
        if (currentStatus_ != other.currentStatus_) return false;
      }
      if (hasTimestamp() != other.hasTimestamp()) return false;
      if (hasTimestamp()) {
        if (getTimestamp()
            != other.getTimestamp()) return false;
      }
      if (hasCongestionLevel() != other.hasCongestionLevel()) return false;
      if (hasCongestionLevel()) {
        if (congestionLevel_ != other.congestionLevel_) return false;
      }
      if (hasOccupancyStatus() != other.hasOccupancyStatus()) return false;
      if (hasOccupancyStatus()) {
        if (occupancyStatus_ != other.occupancyStatus_) return false;
      }
      if (hasOccupancyPercentage() != other.hasOccupancyPercentage()) return false;
      if (hasOccupancyPercentage()) {
        if (getOccupancyPercentage()
            != other.getOccupancyPercentage()) return false;
      }
      if (!getMultiCarriageDetailsList()
          .equals(other.getMultiCarriageDetailsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      if (!getExtensionFields().equals(other.getExtensionFields()))
        return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasTrip()) {
        hash = (37 * hash) + TRIP_FIELD_NUMBER;
        hash = (53 * hash) + getTrip().hashCode();
      }
      if (hasVehicle()) {
        hash = (37 * hash) + VEHICLE_FIELD_NUMBER;
        hash = (53 * hash) + getVehicle().hashCode();
      }
      if (hasPosition()) {
        hash = (37 * hash) + POSITION_FIELD_NUMBER;
        hash = (53 * hash) + getPosition().hashCode();
      }
      if (hasCurrentStopSequence()) {
        hash = (37 * hash) + CURRENT_STOP_SEQUENCE_FIELD_NUMBER;
        hash = (53 * hash) + getCurrentStopSequence();
      }
      if (hasStopId()) {
        hash = (37 * hash) + STOP_ID_FIELD_NUMBER;
        hash = (53 * hash) + getStopId().hashCode();
      }
      if (hasCurrentStatus()) {
        hash = (37 * hash) + CURRENT_STATUS_FIELD_NUMBER;
        hash = (53 * hash) + currentStatus_;
      }
      if (hasTimestamp()) {
        hash = (37 * hash) + TIMESTAMP_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getTimestamp());
      }
      if (hasCongestionLevel()) {
        hash = (37 * hash) + CONGESTION_LEVEL_FIELD_NUMBER;
        hash = (53 * hash) + congestionLevel_;
      }
      if (hasOccupancyStatus()) {
        hash = (37 * hash) + OCCUPANCY_STATUS_FIELD_NUMBER;
        hash = (53 * hash) + occupancyStatus_;
      }
      if (hasOccupancyPercentage()) {
        hash = (37 * hash) + OCCUPANCY_PERCENTAGE_FIELD_NUMBER;
        hash = (53 * hash) + getOccupancyPercentage();
      }
      if (getMultiCarriageDetailsCount() > 0) {
        hash = (37 * hash) + MULTI_CARRIAGE_DETAILS_FIELD_NUMBER;
        hash = (53 * hash) + getMultiCarriageDetailsList().hashCode();
      }
      hash = hashFields(hash, getExtensionFields());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.VehiclePosition prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Realtime positioning information for a given vehicle.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.VehiclePosition}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
          com.google.transit.realtime.GtfsRealtime.VehiclePosition, Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_realtime.VehiclePosition)
        com.google.transit.realtime.GtfsRealtime.VehiclePositionOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_VehiclePosition_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_VehiclePosition_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.VehiclePosition.class, com.google.transit.realtime.GtfsRealtime.VehiclePosition.Builder.class);
      }

      // Construct using com.google.transit.realtime.GtfsRealtime.VehiclePosition.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getTripFieldBuilder();
          getVehicleFieldBuilder();
          getPositionFieldBuilder();
          getMultiCarriageDetailsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        trip_ = null;
        if (tripBuilder_ != null) {
          tripBuilder_.dispose();
          tripBuilder_ = null;
        }
        vehicle_ = null;
        if (vehicleBuilder_ != null) {
          vehicleBuilder_.dispose();
          vehicleBuilder_ = null;
        }
        position_ = null;
        if (positionBuilder_ != null) {
          positionBuilder_.dispose();
          positionBuilder_ = null;
        }
        currentStopSequence_ = 0;
        stopId_ = "";
        currentStatus_ = 2;
        timestamp_ = 0L;
        congestionLevel_ = 0;
        occupancyStatus_ = 0;
        occupancyPercentage_ = 0;
        if (multiCarriageDetailsBuilder_ == null) {
          multiCarriageDetails_ = java.util.Collections.emptyList();
        } else {
          multiCarriageDetails_ = null;
          multiCarriageDetailsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000400);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_VehiclePosition_descriptor;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.VehiclePosition getDefaultInstanceForType() {
        return com.google.transit.realtime.GtfsRealtime.VehiclePosition.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.VehiclePosition build() {
        com.google.transit.realtime.GtfsRealtime.VehiclePosition result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.VehiclePosition buildPartial() {
        com.google.transit.realtime.GtfsRealtime.VehiclePosition result = new com.google.transit.realtime.GtfsRealtime.VehiclePosition(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(com.google.transit.realtime.GtfsRealtime.VehiclePosition result) {
        if (multiCarriageDetailsBuilder_ == null) {
          if (((bitField0_ & 0x00000400) != 0)) {
            multiCarriageDetails_ = java.util.Collections.unmodifiableList(multiCarriageDetails_);
            bitField0_ = (bitField0_ & ~0x00000400);
          }
          result.multiCarriageDetails_ = multiCarriageDetails_;
        } else {
          result.multiCarriageDetails_ = multiCarriageDetailsBuilder_.build();
        }
      }

      private void buildPartial0(com.google.transit.realtime.GtfsRealtime.VehiclePosition result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.trip_ = tripBuilder_ == null
              ? trip_
              : tripBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.vehicle_ = vehicleBuilder_ == null
              ? vehicle_
              : vehicleBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.position_ = positionBuilder_ == null
              ? position_
              : positionBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.currentStopSequence_ = currentStopSequence_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.stopId_ = stopId_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.currentStatus_ = currentStatus_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.timestamp_ = timestamp_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.congestionLevel_ = congestionLevel_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.occupancyStatus_ = occupancyStatus_;
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.occupancyPercentage_ = occupancyPercentage_;
          to_bitField0_ |= 0x00000200;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.transit.realtime.GtfsRealtime.VehiclePosition) {
          return mergeFrom((com.google.transit.realtime.GtfsRealtime.VehiclePosition)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.VehiclePosition other) {
        if (other == com.google.transit.realtime.GtfsRealtime.VehiclePosition.getDefaultInstance()) return this;
        if (other.hasTrip()) {
          mergeTrip(other.getTrip());
        }
        if (other.hasVehicle()) {
          mergeVehicle(other.getVehicle());
        }
        if (other.hasPosition()) {
          mergePosition(other.getPosition());
        }
        if (other.hasCurrentStopSequence()) {
          setCurrentStopSequence(other.getCurrentStopSequence());
        }
        if (other.hasStopId()) {
          stopId_ = other.stopId_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (other.hasCurrentStatus()) {
          setCurrentStatus(other.getCurrentStatus());
        }
        if (other.hasTimestamp()) {
          setTimestamp(other.getTimestamp());
        }
        if (other.hasCongestionLevel()) {
          setCongestionLevel(other.getCongestionLevel());
        }
        if (other.hasOccupancyStatus()) {
          setOccupancyStatus(other.getOccupancyStatus());
        }
        if (other.hasOccupancyPercentage()) {
          setOccupancyPercentage(other.getOccupancyPercentage());
        }
        if (multiCarriageDetailsBuilder_ == null) {
          if (!other.multiCarriageDetails_.isEmpty()) {
            if (multiCarriageDetails_.isEmpty()) {
              multiCarriageDetails_ = other.multiCarriageDetails_;
              bitField0_ = (bitField0_ & ~0x00000400);
            } else {
              ensureMultiCarriageDetailsIsMutable();
              multiCarriageDetails_.addAll(other.multiCarriageDetails_);
            }
            onChanged();
          }
        } else {
          if (!other.multiCarriageDetails_.isEmpty()) {
            if (multiCarriageDetailsBuilder_.isEmpty()) {
              multiCarriageDetailsBuilder_.dispose();
              multiCarriageDetailsBuilder_ = null;
              multiCarriageDetails_ = other.multiCarriageDetails_;
              bitField0_ = (bitField0_ & ~0x00000400);
              multiCarriageDetailsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getMultiCarriageDetailsFieldBuilder() : null;
            } else {
              multiCarriageDetailsBuilder_.addAllMessages(other.multiCarriageDetails_);
            }
          }
        }
        this.mergeExtensionFields(other);
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (hasTrip()) {
          if (!getTrip().isInitialized()) {
            return false;
          }
        }
        if (hasVehicle()) {
          if (!getVehicle().isInitialized()) {
            return false;
          }
        }
        if (hasPosition()) {
          if (!getPosition().isInitialized()) {
            return false;
          }
        }
        for (int i = 0; i < getMultiCarriageDetailsCount(); i++) {
          if (!getMultiCarriageDetails(i).isInitialized()) {
            return false;
          }
        }
        if (!extensionsAreInitialized()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getTripFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getPositionFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 18
              case 24: {
                currentStopSequence_ = input.readUInt32();
                bitField0_ |= 0x00000008;
                break;
              } // case 24
              case 32: {
                int tmpRaw = input.readEnum();
                com.google.transit.realtime.GtfsRealtime.VehiclePosition.VehicleStopStatus tmpValue =
                    com.google.transit.realtime.GtfsRealtime.VehiclePosition.VehicleStopStatus.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(4, tmpRaw);
                } else {
                  currentStatus_ = tmpRaw;
                  bitField0_ |= 0x00000020;
                }
                break;
              } // case 32
              case 40: {
                timestamp_ = input.readUInt64();
                bitField0_ |= 0x00000040;
                break;
              } // case 40
              case 48: {
                int tmpRaw = input.readEnum();
                com.google.transit.realtime.GtfsRealtime.VehiclePosition.CongestionLevel tmpValue =
                    com.google.transit.realtime.GtfsRealtime.VehiclePosition.CongestionLevel.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(6, tmpRaw);
                } else {
                  congestionLevel_ = tmpRaw;
                  bitField0_ |= 0x00000080;
                }
                break;
              } // case 48
              case 58: {
                stopId_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 58
              case 66: {
                input.readMessage(
                    getVehicleFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 66
              case 72: {
                int tmpRaw = input.readEnum();
                com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus tmpValue =
                    com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(9, tmpRaw);
                } else {
                  occupancyStatus_ = tmpRaw;
                  bitField0_ |= 0x00000100;
                }
                break;
              } // case 72
              case 80: {
                occupancyPercentage_ = input.readUInt32();
                bitField0_ |= 0x00000200;
                break;
              } // case 80
              case 90: {
                com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails m =
                    input.readMessage(
                        com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails.parser(),
                        extensionRegistry);
                if (multiCarriageDetailsBuilder_ == null) {
                  ensureMultiCarriageDetailsIsMutable();
                  multiCarriageDetails_.add(m);
                } else {
                  multiCarriageDetailsBuilder_.addMessage(m);
                }
                break;
              } // case 90
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.transit.realtime.GtfsRealtime.TripDescriptor trip_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TripDescriptor, com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder, com.google.transit.realtime.GtfsRealtime.TripDescriptorOrBuilder> tripBuilder_;
      /**
       * <pre>
       * The Trip that this vehicle is serving.
       * Can be empty or partial if the vehicle can not be identified with a given
       * trip instance.
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
       * @return Whether the trip field is set.
       */
      public boolean hasTrip() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The Trip that this vehicle is serving.
       * Can be empty or partial if the vehicle can not be identified with a given
       * trip instance.
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
       * @return The trip.
       */
      public com.google.transit.realtime.GtfsRealtime.TripDescriptor getTrip() {
        if (tripBuilder_ == null) {
          return trip_ == null ? com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance() : trip_;
        } else {
          return tripBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The Trip that this vehicle is serving.
       * Can be empty or partial if the vehicle can not be identified with a given
       * trip instance.
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public Builder setTrip(com.google.transit.realtime.GtfsRealtime.TripDescriptor value) {
        if (tripBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          trip_ = value;
        } else {
          tripBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The Trip that this vehicle is serving.
       * Can be empty or partial if the vehicle can not be identified with a given
       * trip instance.
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public Builder setTrip(
          com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder builderForValue) {
        if (tripBuilder_ == null) {
          trip_ = builderForValue.build();
        } else {
          tripBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The Trip that this vehicle is serving.
       * Can be empty or partial if the vehicle can not be identified with a given
       * trip instance.
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public Builder mergeTrip(com.google.transit.realtime.GtfsRealtime.TripDescriptor value) {
        if (tripBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            trip_ != null &&
            trip_ != com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance()) {
            getTripBuilder().mergeFrom(value);
          } else {
            trip_ = value;
          }
        } else {
          tripBuilder_.mergeFrom(value);
        }
        if (trip_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * The Trip that this vehicle is serving.
       * Can be empty or partial if the vehicle can not be identified with a given
       * trip instance.
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public Builder clearTrip() {
        bitField0_ = (bitField0_ & ~0x00000001);
        trip_ = null;
        if (tripBuilder_ != null) {
          tripBuilder_.dispose();
          tripBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The Trip that this vehicle is serving.
       * Can be empty or partial if the vehicle can not be identified with a given
       * trip instance.
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder getTripBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getTripFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The Trip that this vehicle is serving.
       * Can be empty or partial if the vehicle can not be identified with a given
       * trip instance.
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripDescriptorOrBuilder getTripOrBuilder() {
        if (tripBuilder_ != null) {
          return tripBuilder_.getMessageOrBuilder();
        } else {
          return trip_ == null ?
              com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance() : trip_;
        }
      }
      /**
       * <pre>
       * The Trip that this vehicle is serving.
       * Can be empty or partial if the vehicle can not be identified with a given
       * trip instance.
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TripDescriptor, com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder, com.google.transit.realtime.GtfsRealtime.TripDescriptorOrBuilder> 
          getTripFieldBuilder() {
        if (tripBuilder_ == null) {
          tripBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TripDescriptor, com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder, com.google.transit.realtime.GtfsRealtime.TripDescriptorOrBuilder>(
                  getTrip(),
                  getParentForChildren(),
                  isClean());
          trip_ = null;
        }
        return tripBuilder_;
      }

      private com.google.transit.realtime.GtfsRealtime.VehicleDescriptor vehicle_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.VehicleDescriptor, com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.Builder, com.google.transit.realtime.GtfsRealtime.VehicleDescriptorOrBuilder> vehicleBuilder_;
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
       * @return Whether the vehicle field is set.
       */
      public boolean hasVehicle() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
       * @return The vehicle.
       */
      public com.google.transit.realtime.GtfsRealtime.VehicleDescriptor getVehicle() {
        if (vehicleBuilder_ == null) {
          return vehicle_ == null ? com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.getDefaultInstance() : vehicle_;
        } else {
          return vehicleBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
       */
      public Builder setVehicle(com.google.transit.realtime.GtfsRealtime.VehicleDescriptor value) {
        if (vehicleBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          vehicle_ = value;
        } else {
          vehicleBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
       */
      public Builder setVehicle(
          com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.Builder builderForValue) {
        if (vehicleBuilder_ == null) {
          vehicle_ = builderForValue.build();
        } else {
          vehicleBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
       */
      public Builder mergeVehicle(com.google.transit.realtime.GtfsRealtime.VehicleDescriptor value) {
        if (vehicleBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            vehicle_ != null &&
            vehicle_ != com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.getDefaultInstance()) {
            getVehicleBuilder().mergeFrom(value);
          } else {
            vehicle_ = value;
          }
        } else {
          vehicleBuilder_.mergeFrom(value);
        }
        if (vehicle_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
       */
      public Builder clearVehicle() {
        bitField0_ = (bitField0_ & ~0x00000002);
        vehicle_ = null;
        if (vehicleBuilder_ != null) {
          vehicleBuilder_.dispose();
          vehicleBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.Builder getVehicleBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getVehicleFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.VehicleDescriptorOrBuilder getVehicleOrBuilder() {
        if (vehicleBuilder_ != null) {
          return vehicleBuilder_.getMessageOrBuilder();
        } else {
          return vehicle_ == null ?
              com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.getDefaultInstance() : vehicle_;
        }
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.VehicleDescriptor, com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.Builder, com.google.transit.realtime.GtfsRealtime.VehicleDescriptorOrBuilder> 
          getVehicleFieldBuilder() {
        if (vehicleBuilder_ == null) {
          vehicleBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.VehicleDescriptor, com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.Builder, com.google.transit.realtime.GtfsRealtime.VehicleDescriptorOrBuilder>(
                  getVehicle(),
                  getParentForChildren(),
                  isClean());
          vehicle_ = null;
        }
        return vehicleBuilder_;
      }

      private com.google.transit.realtime.GtfsRealtime.Position position_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.Position, com.google.transit.realtime.GtfsRealtime.Position.Builder, com.google.transit.realtime.GtfsRealtime.PositionOrBuilder> positionBuilder_;
      /**
       * <pre>
       * Current position of this vehicle.
       * </pre>
       *
       * <code>optional .transit_realtime.Position position = 2;</code>
       * @return Whether the position field is set.
       */
      public boolean hasPosition() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Current position of this vehicle.
       * </pre>
       *
       * <code>optional .transit_realtime.Position position = 2;</code>
       * @return The position.
       */
      public com.google.transit.realtime.GtfsRealtime.Position getPosition() {
        if (positionBuilder_ == null) {
          return position_ == null ? com.google.transit.realtime.GtfsRealtime.Position.getDefaultInstance() : position_;
        } else {
          return positionBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Current position of this vehicle.
       * </pre>
       *
       * <code>optional .transit_realtime.Position position = 2;</code>
       */
      public Builder setPosition(com.google.transit.realtime.GtfsRealtime.Position value) {
        if (positionBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          position_ = value;
        } else {
          positionBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Current position of this vehicle.
       * </pre>
       *
       * <code>optional .transit_realtime.Position position = 2;</code>
       */
      public Builder setPosition(
          com.google.transit.realtime.GtfsRealtime.Position.Builder builderForValue) {
        if (positionBuilder_ == null) {
          position_ = builderForValue.build();
        } else {
          positionBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Current position of this vehicle.
       * </pre>
       *
       * <code>optional .transit_realtime.Position position = 2;</code>
       */
      public Builder mergePosition(com.google.transit.realtime.GtfsRealtime.Position value) {
        if (positionBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            position_ != null &&
            position_ != com.google.transit.realtime.GtfsRealtime.Position.getDefaultInstance()) {
            getPositionBuilder().mergeFrom(value);
          } else {
            position_ = value;
          }
        } else {
          positionBuilder_.mergeFrom(value);
        }
        if (position_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Current position of this vehicle.
       * </pre>
       *
       * <code>optional .transit_realtime.Position position = 2;</code>
       */
      public Builder clearPosition() {
        bitField0_ = (bitField0_ & ~0x00000004);
        position_ = null;
        if (positionBuilder_ != null) {
          positionBuilder_.dispose();
          positionBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Current position of this vehicle.
       * </pre>
       *
       * <code>optional .transit_realtime.Position position = 2;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.Position.Builder getPositionBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getPositionFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Current position of this vehicle.
       * </pre>
       *
       * <code>optional .transit_realtime.Position position = 2;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.PositionOrBuilder getPositionOrBuilder() {
        if (positionBuilder_ != null) {
          return positionBuilder_.getMessageOrBuilder();
        } else {
          return position_ == null ?
              com.google.transit.realtime.GtfsRealtime.Position.getDefaultInstance() : position_;
        }
      }
      /**
       * <pre>
       * Current position of this vehicle.
       * </pre>
       *
       * <code>optional .transit_realtime.Position position = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.Position, com.google.transit.realtime.GtfsRealtime.Position.Builder, com.google.transit.realtime.GtfsRealtime.PositionOrBuilder> 
          getPositionFieldBuilder() {
        if (positionBuilder_ == null) {
          positionBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.Position, com.google.transit.realtime.GtfsRealtime.Position.Builder, com.google.transit.realtime.GtfsRealtime.PositionOrBuilder>(
                  getPosition(),
                  getParentForChildren(),
                  isClean());
          position_ = null;
        }
        return positionBuilder_;
      }

      private int currentStopSequence_ ;
      /**
       * <pre>
       * The stop sequence index of the current stop. The meaning of
       * current_stop_sequence (i.e., the stop that it refers to) is determined by
       * current_status.
       * If current_status is missing IN_TRANSIT_TO is assumed.
       * </pre>
       *
       * <code>optional uint32 current_stop_sequence = 3;</code>
       * @return Whether the currentStopSequence field is set.
       */
      @java.lang.Override
      public boolean hasCurrentStopSequence() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The stop sequence index of the current stop. The meaning of
       * current_stop_sequence (i.e., the stop that it refers to) is determined by
       * current_status.
       * If current_status is missing IN_TRANSIT_TO is assumed.
       * </pre>
       *
       * <code>optional uint32 current_stop_sequence = 3;</code>
       * @return The currentStopSequence.
       */
      @java.lang.Override
      public int getCurrentStopSequence() {
        return currentStopSequence_;
      }
      /**
       * <pre>
       * The stop sequence index of the current stop. The meaning of
       * current_stop_sequence (i.e., the stop that it refers to) is determined by
       * current_status.
       * If current_status is missing IN_TRANSIT_TO is assumed.
       * </pre>
       *
       * <code>optional uint32 current_stop_sequence = 3;</code>
       * @param value The currentStopSequence to set.
       * @return This builder for chaining.
       */
      public Builder setCurrentStopSequence(int value) {

        currentStopSequence_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The stop sequence index of the current stop. The meaning of
       * current_stop_sequence (i.e., the stop that it refers to) is determined by
       * current_status.
       * If current_status is missing IN_TRANSIT_TO is assumed.
       * </pre>
       *
       * <code>optional uint32 current_stop_sequence = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearCurrentStopSequence() {
        bitField0_ = (bitField0_ & ~0x00000008);
        currentStopSequence_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object stopId_ = "";
      /**
       * <pre>
       * Identifies the current stop. The value must be the same as in stops.txt in
       * the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 7;</code>
       * @return Whether the stopId field is set.
       */
      public boolean hasStopId() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Identifies the current stop. The value must be the same as in stops.txt in
       * the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 7;</code>
       * @return The stopId.
       */
      public java.lang.String getStopId() {
        java.lang.Object ref = stopId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            stopId_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Identifies the current stop. The value must be the same as in stops.txt in
       * the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 7;</code>
       * @return The bytes for stopId.
       */
      public com.google.protobuf.ByteString
          getStopIdBytes() {
        java.lang.Object ref = stopId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          stopId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Identifies the current stop. The value must be the same as in stops.txt in
       * the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 7;</code>
       * @param value The stopId to set.
       * @return This builder for chaining.
       */
      public Builder setStopId(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        stopId_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies the current stop. The value must be the same as in stops.txt in
       * the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearStopId() {
        stopId_ = getDefaultInstance().getStopId();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies the current stop. The value must be the same as in stops.txt in
       * the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 7;</code>
       * @param value The bytes for stopId to set.
       * @return This builder for chaining.
       */
      public Builder setStopIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        stopId_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private int currentStatus_ = 2;
      /**
       * <pre>
       * The exact status of the vehicle with respect to the current stop.
       * Ignored if current_stop_sequence is missing.
       * </pre>
       *
       * <code>optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];</code>
       * @return Whether the currentStatus field is set.
       */
      @java.lang.Override public boolean hasCurrentStatus() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * The exact status of the vehicle with respect to the current stop.
       * Ignored if current_stop_sequence is missing.
       * </pre>
       *
       * <code>optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];</code>
       * @return The currentStatus.
       */
      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.VehiclePosition.VehicleStopStatus getCurrentStatus() {
        com.google.transit.realtime.GtfsRealtime.VehiclePosition.VehicleStopStatus result = com.google.transit.realtime.GtfsRealtime.VehiclePosition.VehicleStopStatus.forNumber(currentStatus_);
        return result == null ? com.google.transit.realtime.GtfsRealtime.VehiclePosition.VehicleStopStatus.IN_TRANSIT_TO : result;
      }
      /**
       * <pre>
       * The exact status of the vehicle with respect to the current stop.
       * Ignored if current_stop_sequence is missing.
       * </pre>
       *
       * <code>optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];</code>
       * @param value The currentStatus to set.
       * @return This builder for chaining.
       */
      public Builder setCurrentStatus(com.google.transit.realtime.GtfsRealtime.VehiclePosition.VehicleStopStatus value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000020;
        currentStatus_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The exact status of the vehicle with respect to the current stop.
       * Ignored if current_stop_sequence is missing.
       * </pre>
       *
       * <code>optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];</code>
       * @return This builder for chaining.
       */
      public Builder clearCurrentStatus() {
        bitField0_ = (bitField0_ & ~0x00000020);
        currentStatus_ = 2;
        onChanged();
        return this;
      }

      private long timestamp_ ;
      /**
       * <pre>
       * Moment at which the vehicle's position was measured. In POSIX time
       * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 5;</code>
       * @return Whether the timestamp field is set.
       */
      @java.lang.Override
      public boolean hasTimestamp() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Moment at which the vehicle's position was measured. In POSIX time
       * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 5;</code>
       * @return The timestamp.
       */
      @java.lang.Override
      public long getTimestamp() {
        return timestamp_;
      }
      /**
       * <pre>
       * Moment at which the vehicle's position was measured. In POSIX time
       * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 5;</code>
       * @param value The timestamp to set.
       * @return This builder for chaining.
       */
      public Builder setTimestamp(long value) {

        timestamp_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Moment at which the vehicle's position was measured. In POSIX time
       * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearTimestamp() {
        bitField0_ = (bitField0_ & ~0x00000040);
        timestamp_ = 0L;
        onChanged();
        return this;
      }

      private int congestionLevel_ = 0;
      /**
       * <code>optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;</code>
       * @return Whether the congestionLevel field is set.
       */
      @java.lang.Override public boolean hasCongestionLevel() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <code>optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;</code>
       * @return The congestionLevel.
       */
      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.VehiclePosition.CongestionLevel getCongestionLevel() {
        com.google.transit.realtime.GtfsRealtime.VehiclePosition.CongestionLevel result = com.google.transit.realtime.GtfsRealtime.VehiclePosition.CongestionLevel.forNumber(congestionLevel_);
        return result == null ? com.google.transit.realtime.GtfsRealtime.VehiclePosition.CongestionLevel.UNKNOWN_CONGESTION_LEVEL : result;
      }
      /**
       * <code>optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;</code>
       * @param value The congestionLevel to set.
       * @return This builder for chaining.
       */
      public Builder setCongestionLevel(com.google.transit.realtime.GtfsRealtime.VehiclePosition.CongestionLevel value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000080;
        congestionLevel_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearCongestionLevel() {
        bitField0_ = (bitField0_ & ~0x00000080);
        congestionLevel_ = 0;
        onChanged();
        return this;
      }

      private int occupancyStatus_ = 0;
      /**
       * <pre>
       * If multi_carriage_status is populated with per-carriage OccupancyStatus,
       * then this field should describe the entire vehicle with all carriages accepting passengers considered.
       * </pre>
       *
       * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;</code>
       * @return Whether the occupancyStatus field is set.
       */
      @java.lang.Override public boolean hasOccupancyStatus() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * If multi_carriage_status is populated with per-carriage OccupancyStatus,
       * then this field should describe the entire vehicle with all carriages accepting passengers considered.
       * </pre>
       *
       * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;</code>
       * @return The occupancyStatus.
       */
      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus getOccupancyStatus() {
        com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus result = com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus.forNumber(occupancyStatus_);
        return result == null ? com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus.EMPTY : result;
      }
      /**
       * <pre>
       * If multi_carriage_status is populated with per-carriage OccupancyStatus,
       * then this field should describe the entire vehicle with all carriages accepting passengers considered.
       * </pre>
       *
       * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;</code>
       * @param value The occupancyStatus to set.
       * @return This builder for chaining.
       */
      public Builder setOccupancyStatus(com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000100;
        occupancyStatus_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If multi_carriage_status is populated with per-carriage OccupancyStatus,
       * then this field should describe the entire vehicle with all carriages accepting passengers considered.
       * </pre>
       *
       * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearOccupancyStatus() {
        bitField0_ = (bitField0_ & ~0x00000100);
        occupancyStatus_ = 0;
        onChanged();
        return this;
      }

      private int occupancyPercentage_ ;
      /**
       * <pre>
       * A percentage value indicating the degree of passenger occupancy in the vehicle.
       * The values are represented as an integer without decimals. 0 means 0% and 100 means 100%.
       * The value 100 should represent the total maximum occupancy the vehicle was designed for,
       * including both seated and standing capacity, and current operating regulations allow.
       * The value may exceed 100 if there are more passengers than the maximum designed capacity.
       * The precision of occupancy_percentage should be low enough that individual passengers cannot be tracked boarding or alighting the vehicle.
       * If multi_carriage_status is populated with per-carriage occupancy_percentage, 
       * then this field should describe the entire vehicle with all carriages accepting passengers considered.
       * This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional uint32 occupancy_percentage = 10;</code>
       * @return Whether the occupancyPercentage field is set.
       */
      @java.lang.Override
      public boolean hasOccupancyPercentage() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * A percentage value indicating the degree of passenger occupancy in the vehicle.
       * The values are represented as an integer without decimals. 0 means 0% and 100 means 100%.
       * The value 100 should represent the total maximum occupancy the vehicle was designed for,
       * including both seated and standing capacity, and current operating regulations allow.
       * The value may exceed 100 if there are more passengers than the maximum designed capacity.
       * The precision of occupancy_percentage should be low enough that individual passengers cannot be tracked boarding or alighting the vehicle.
       * If multi_carriage_status is populated with per-carriage occupancy_percentage, 
       * then this field should describe the entire vehicle with all carriages accepting passengers considered.
       * This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional uint32 occupancy_percentage = 10;</code>
       * @return The occupancyPercentage.
       */
      @java.lang.Override
      public int getOccupancyPercentage() {
        return occupancyPercentage_;
      }
      /**
       * <pre>
       * A percentage value indicating the degree of passenger occupancy in the vehicle.
       * The values are represented as an integer without decimals. 0 means 0% and 100 means 100%.
       * The value 100 should represent the total maximum occupancy the vehicle was designed for,
       * including both seated and standing capacity, and current operating regulations allow.
       * The value may exceed 100 if there are more passengers than the maximum designed capacity.
       * The precision of occupancy_percentage should be low enough that individual passengers cannot be tracked boarding or alighting the vehicle.
       * If multi_carriage_status is populated with per-carriage occupancy_percentage, 
       * then this field should describe the entire vehicle with all carriages accepting passengers considered.
       * This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional uint32 occupancy_percentage = 10;</code>
       * @param value The occupancyPercentage to set.
       * @return This builder for chaining.
       */
      public Builder setOccupancyPercentage(int value) {

        occupancyPercentage_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A percentage value indicating the degree of passenger occupancy in the vehicle.
       * The values are represented as an integer without decimals. 0 means 0% and 100 means 100%.
       * The value 100 should represent the total maximum occupancy the vehicle was designed for,
       * including both seated and standing capacity, and current operating regulations allow.
       * The value may exceed 100 if there are more passengers than the maximum designed capacity.
       * The precision of occupancy_percentage should be low enough that individual passengers cannot be tracked boarding or alighting the vehicle.
       * If multi_carriage_status is populated with per-carriage occupancy_percentage, 
       * then this field should describe the entire vehicle with all carriages accepting passengers considered.
       * This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional uint32 occupancy_percentage = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearOccupancyPercentage() {
        bitField0_ = (bitField0_ & ~0x00000200);
        occupancyPercentage_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails> multiCarriageDetails_ =
        java.util.Collections.emptyList();
      private void ensureMultiCarriageDetailsIsMutable() {
        if (!((bitField0_ & 0x00000400) != 0)) {
          multiCarriageDetails_ = new java.util.ArrayList<com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails>(multiCarriageDetails_);
          bitField0_ |= 0x00000400;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails, com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails.Builder, com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetailsOrBuilder> multiCarriageDetailsBuilder_;

      /**
       * <pre>
       * Details of the multiple carriages of this given vehicle.
       * The first occurrence represents the first carriage of the vehicle, 
       * given the current direction of travel. 
       * The number of occurrences of the multi_carriage_details 
       * field represents the number of carriages of the vehicle.
       * It also includes non boardable carriages, 
       * like engines, maintenance carriages, etc… as they provide valuable 
       * information to passengers about where to stand on a platform.
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails> getMultiCarriageDetailsList() {
        if (multiCarriageDetailsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(multiCarriageDetails_);
        } else {
          return multiCarriageDetailsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Details of the multiple carriages of this given vehicle.
       * The first occurrence represents the first carriage of the vehicle, 
       * given the current direction of travel. 
       * The number of occurrences of the multi_carriage_details 
       * field represents the number of carriages of the vehicle.
       * It also includes non boardable carriages, 
       * like engines, maintenance carriages, etc… as they provide valuable 
       * information to passengers about where to stand on a platform.
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
       */
      public int getMultiCarriageDetailsCount() {
        if (multiCarriageDetailsBuilder_ == null) {
          return multiCarriageDetails_.size();
        } else {
          return multiCarriageDetailsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Details of the multiple carriages of this given vehicle.
       * The first occurrence represents the first carriage of the vehicle, 
       * given the current direction of travel. 
       * The number of occurrences of the multi_carriage_details 
       * field represents the number of carriages of the vehicle.
       * It also includes non boardable carriages, 
       * like engines, maintenance carriages, etc… as they provide valuable 
       * information to passengers about where to stand on a platform.
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails getMultiCarriageDetails(int index) {
        if (multiCarriageDetailsBuilder_ == null) {
          return multiCarriageDetails_.get(index);
        } else {
          return multiCarriageDetailsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Details of the multiple carriages of this given vehicle.
       * The first occurrence represents the first carriage of the vehicle, 
       * given the current direction of travel. 
       * The number of occurrences of the multi_carriage_details 
       * field represents the number of carriages of the vehicle.
       * It also includes non boardable carriages, 
       * like engines, maintenance carriages, etc… as they provide valuable 
       * information to passengers about where to stand on a platform.
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
       */
      public Builder setMultiCarriageDetails(
          int index, com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails value) {
        if (multiCarriageDetailsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMultiCarriageDetailsIsMutable();
          multiCarriageDetails_.set(index, value);
          onChanged();
        } else {
          multiCarriageDetailsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Details of the multiple carriages of this given vehicle.
       * The first occurrence represents the first carriage of the vehicle, 
       * given the current direction of travel. 
       * The number of occurrences of the multi_carriage_details 
       * field represents the number of carriages of the vehicle.
       * It also includes non boardable carriages, 
       * like engines, maintenance carriages, etc… as they provide valuable 
       * information to passengers about where to stand on a platform.
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
       */
      public Builder setMultiCarriageDetails(
          int index, com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails.Builder builderForValue) {
        if (multiCarriageDetailsBuilder_ == null) {
          ensureMultiCarriageDetailsIsMutable();
          multiCarriageDetails_.set(index, builderForValue.build());
          onChanged();
        } else {
          multiCarriageDetailsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Details of the multiple carriages of this given vehicle.
       * The first occurrence represents the first carriage of the vehicle, 
       * given the current direction of travel. 
       * The number of occurrences of the multi_carriage_details 
       * field represents the number of carriages of the vehicle.
       * It also includes non boardable carriages, 
       * like engines, maintenance carriages, etc… as they provide valuable 
       * information to passengers about where to stand on a platform.
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
       */
      public Builder addMultiCarriageDetails(com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails value) {
        if (multiCarriageDetailsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMultiCarriageDetailsIsMutable();
          multiCarriageDetails_.add(value);
          onChanged();
        } else {
          multiCarriageDetailsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Details of the multiple carriages of this given vehicle.
       * The first occurrence represents the first carriage of the vehicle, 
       * given the current direction of travel. 
       * The number of occurrences of the multi_carriage_details 
       * field represents the number of carriages of the vehicle.
       * It also includes non boardable carriages, 
       * like engines, maintenance carriages, etc… as they provide valuable 
       * information to passengers about where to stand on a platform.
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
       */
      public Builder addMultiCarriageDetails(
          int index, com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails value) {
        if (multiCarriageDetailsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMultiCarriageDetailsIsMutable();
          multiCarriageDetails_.add(index, value);
          onChanged();
        } else {
          multiCarriageDetailsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Details of the multiple carriages of this given vehicle.
       * The first occurrence represents the first carriage of the vehicle, 
       * given the current direction of travel. 
       * The number of occurrences of the multi_carriage_details 
       * field represents the number of carriages of the vehicle.
       * It also includes non boardable carriages, 
       * like engines, maintenance carriages, etc… as they provide valuable 
       * information to passengers about where to stand on a platform.
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
       */
      public Builder addMultiCarriageDetails(
          com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails.Builder builderForValue) {
        if (multiCarriageDetailsBuilder_ == null) {
          ensureMultiCarriageDetailsIsMutable();
          multiCarriageDetails_.add(builderForValue.build());
          onChanged();
        } else {
          multiCarriageDetailsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Details of the multiple carriages of this given vehicle.
       * The first occurrence represents the first carriage of the vehicle, 
       * given the current direction of travel. 
       * The number of occurrences of the multi_carriage_details 
       * field represents the number of carriages of the vehicle.
       * It also includes non boardable carriages, 
       * like engines, maintenance carriages, etc… as they provide valuable 
       * information to passengers about where to stand on a platform.
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
       */
      public Builder addMultiCarriageDetails(
          int index, com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails.Builder builderForValue) {
        if (multiCarriageDetailsBuilder_ == null) {
          ensureMultiCarriageDetailsIsMutable();
          multiCarriageDetails_.add(index, builderForValue.build());
          onChanged();
        } else {
          multiCarriageDetailsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Details of the multiple carriages of this given vehicle.
       * The first occurrence represents the first carriage of the vehicle, 
       * given the current direction of travel. 
       * The number of occurrences of the multi_carriage_details 
       * field represents the number of carriages of the vehicle.
       * It also includes non boardable carriages, 
       * like engines, maintenance carriages, etc… as they provide valuable 
       * information to passengers about where to stand on a platform.
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
       */
      public Builder addAllMultiCarriageDetails(
          java.lang.Iterable<? extends com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails> values) {
        if (multiCarriageDetailsBuilder_ == null) {
          ensureMultiCarriageDetailsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, multiCarriageDetails_);
          onChanged();
        } else {
          multiCarriageDetailsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Details of the multiple carriages of this given vehicle.
       * The first occurrence represents the first carriage of the vehicle, 
       * given the current direction of travel. 
       * The number of occurrences of the multi_carriage_details 
       * field represents the number of carriages of the vehicle.
       * It also includes non boardable carriages, 
       * like engines, maintenance carriages, etc… as they provide valuable 
       * information to passengers about where to stand on a platform.
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
       */
      public Builder clearMultiCarriageDetails() {
        if (multiCarriageDetailsBuilder_ == null) {
          multiCarriageDetails_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000400);
          onChanged();
        } else {
          multiCarriageDetailsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Details of the multiple carriages of this given vehicle.
       * The first occurrence represents the first carriage of the vehicle, 
       * given the current direction of travel. 
       * The number of occurrences of the multi_carriage_details 
       * field represents the number of carriages of the vehicle.
       * It also includes non boardable carriages, 
       * like engines, maintenance carriages, etc… as they provide valuable 
       * information to passengers about where to stand on a platform.
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
       */
      public Builder removeMultiCarriageDetails(int index) {
        if (multiCarriageDetailsBuilder_ == null) {
          ensureMultiCarriageDetailsIsMutable();
          multiCarriageDetails_.remove(index);
          onChanged();
        } else {
          multiCarriageDetailsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Details of the multiple carriages of this given vehicle.
       * The first occurrence represents the first carriage of the vehicle, 
       * given the current direction of travel. 
       * The number of occurrences of the multi_carriage_details 
       * field represents the number of carriages of the vehicle.
       * It also includes non boardable carriages, 
       * like engines, maintenance carriages, etc… as they provide valuable 
       * information to passengers about where to stand on a platform.
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails.Builder getMultiCarriageDetailsBuilder(
          int index) {
        return getMultiCarriageDetailsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Details of the multiple carriages of this given vehicle.
       * The first occurrence represents the first carriage of the vehicle, 
       * given the current direction of travel. 
       * The number of occurrences of the multi_carriage_details 
       * field represents the number of carriages of the vehicle.
       * It also includes non boardable carriages, 
       * like engines, maintenance carriages, etc… as they provide valuable 
       * information to passengers about where to stand on a platform.
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetailsOrBuilder getMultiCarriageDetailsOrBuilder(
          int index) {
        if (multiCarriageDetailsBuilder_ == null) {
          return multiCarriageDetails_.get(index);  } else {
          return multiCarriageDetailsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Details of the multiple carriages of this given vehicle.
       * The first occurrence represents the first carriage of the vehicle, 
       * given the current direction of travel. 
       * The number of occurrences of the multi_carriage_details 
       * field represents the number of carriages of the vehicle.
       * It also includes non boardable carriages, 
       * like engines, maintenance carriages, etc… as they provide valuable 
       * information to passengers about where to stand on a platform.
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
       */
      public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetailsOrBuilder> 
           getMultiCarriageDetailsOrBuilderList() {
        if (multiCarriageDetailsBuilder_ != null) {
          return multiCarriageDetailsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(multiCarriageDetails_);
        }
      }
      /**
       * <pre>
       * Details of the multiple carriages of this given vehicle.
       * The first occurrence represents the first carriage of the vehicle, 
       * given the current direction of travel. 
       * The number of occurrences of the multi_carriage_details 
       * field represents the number of carriages of the vehicle.
       * It also includes non boardable carriages, 
       * like engines, maintenance carriages, etc… as they provide valuable 
       * information to passengers about where to stand on a platform.
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails.Builder addMultiCarriageDetailsBuilder() {
        return getMultiCarriageDetailsFieldBuilder().addBuilder(
            com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails.getDefaultInstance());
      }
      /**
       * <pre>
       * Details of the multiple carriages of this given vehicle.
       * The first occurrence represents the first carriage of the vehicle, 
       * given the current direction of travel. 
       * The number of occurrences of the multi_carriage_details 
       * field represents the number of carriages of the vehicle.
       * It also includes non boardable carriages, 
       * like engines, maintenance carriages, etc… as they provide valuable 
       * information to passengers about where to stand on a platform.
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails.Builder addMultiCarriageDetailsBuilder(
          int index) {
        return getMultiCarriageDetailsFieldBuilder().addBuilder(
            index, com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails.getDefaultInstance());
      }
      /**
       * <pre>
       * Details of the multiple carriages of this given vehicle.
       * The first occurrence represents the first carriage of the vehicle, 
       * given the current direction of travel. 
       * The number of occurrences of the multi_carriage_details 
       * field represents the number of carriages of the vehicle.
       * It also includes non boardable carriages, 
       * like engines, maintenance carriages, etc… as they provide valuable 
       * information to passengers about where to stand on a platform.
       * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails.Builder> 
           getMultiCarriageDetailsBuilderList() {
        return getMultiCarriageDetailsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails, com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails.Builder, com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetailsOrBuilder> 
          getMultiCarriageDetailsFieldBuilder() {
        if (multiCarriageDetailsBuilder_ == null) {
          multiCarriageDetailsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails, com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetails.Builder, com.google.transit.realtime.GtfsRealtime.VehiclePosition.CarriageDetailsOrBuilder>(
                  multiCarriageDetails_,
                  ((bitField0_ & 0x00000400) != 0),
                  getParentForChildren(),
                  isClean());
          multiCarriageDetails_ = null;
        }
        return multiCarriageDetailsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.VehiclePosition)
    }

    // @@protoc_insertion_point(class_scope:transit_realtime.VehiclePosition)
    private static final com.google.transit.realtime.GtfsRealtime.VehiclePosition DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.VehiclePosition();
    }

    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<VehiclePosition>
        PARSER = new com.google.protobuf.AbstractParser<VehiclePosition>() {
      @java.lang.Override
      public VehiclePosition parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<VehiclePosition> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<VehiclePosition> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.VehiclePosition getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface AlertOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_realtime.Alert)
      com.google.protobuf.GeneratedMessage.
          ExtendableMessageOrBuilder<Alert> {

    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    java.util.List<com.google.transit.realtime.GtfsRealtime.TimeRange> 
        getActivePeriodList();
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TimeRange getActivePeriod(int index);
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    int getActivePeriodCount();
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    java.util.List<? extends com.google.transit.realtime.GtfsRealtime.TimeRangeOrBuilder> 
        getActivePeriodOrBuilderList();
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TimeRangeOrBuilder getActivePeriodOrBuilder(
        int index);

    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    java.util.List<com.google.transit.realtime.GtfsRealtime.EntitySelector> 
        getInformedEntityList();
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    com.google.transit.realtime.GtfsRealtime.EntitySelector getInformedEntity(int index);
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    int getInformedEntityCount();
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    java.util.List<? extends com.google.transit.realtime.GtfsRealtime.EntitySelectorOrBuilder> 
        getInformedEntityOrBuilderList();
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    com.google.transit.realtime.GtfsRealtime.EntitySelectorOrBuilder getInformedEntityOrBuilder(
        int index);

    /**
     * <code>optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];</code>
     * @return Whether the cause field is set.
     */
    boolean hasCause();
    /**
     * <code>optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];</code>
     * @return The cause.
     */
    com.google.transit.realtime.GtfsRealtime.Alert.Cause getCause();

    /**
     * <code>optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];</code>
     * @return Whether the effect field is set.
     */
    boolean hasEffect();
    /**
     * <code>optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];</code>
     * @return The effect.
     */
    com.google.transit.realtime.GtfsRealtime.Alert.Effect getEffect();

    /**
     * <pre>
     * The URL which provides additional information about the alert.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString url = 8;</code>
     * @return Whether the url field is set.
     */
    boolean hasUrl();
    /**
     * <pre>
     * The URL which provides additional information about the alert.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString url = 8;</code>
     * @return The url.
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedString getUrl();
    /**
     * <pre>
     * The URL which provides additional information about the alert.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString url = 8;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getUrlOrBuilder();

    /**
     * <pre>
     * Alert header. Contains a short summary of the alert text as plain-text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
     * @return Whether the headerText field is set.
     */
    boolean hasHeaderText();
    /**
     * <pre>
     * Alert header. Contains a short summary of the alert text as plain-text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
     * @return The headerText.
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedString getHeaderText();
    /**
     * <pre>
     * Alert header. Contains a short summary of the alert text as plain-text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getHeaderTextOrBuilder();

    /**
     * <pre>
     * Full description for the alert as plain-text. The information in the
     * description should add to the information of the header.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
     * @return Whether the descriptionText field is set.
     */
    boolean hasDescriptionText();
    /**
     * <pre>
     * Full description for the alert as plain-text. The information in the
     * description should add to the information of the header.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
     * @return The descriptionText.
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedString getDescriptionText();
    /**
     * <pre>
     * Full description for the alert as plain-text. The information in the
     * description should add to the information of the header.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getDescriptionTextOrBuilder();

    /**
     * <pre>
     * Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString tts_header_text = 12;</code>
     * @return Whether the ttsHeaderText field is set.
     */
    boolean hasTtsHeaderText();
    /**
     * <pre>
     * Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString tts_header_text = 12;</code>
     * @return The ttsHeaderText.
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedString getTtsHeaderText();
    /**
     * <pre>
     * Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString tts_header_text = 12;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getTtsHeaderTextOrBuilder();

    /**
     * <pre>
     * Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString tts_description_text = 13;</code>
     * @return Whether the ttsDescriptionText field is set.
     */
    boolean hasTtsDescriptionText();
    /**
     * <pre>
     * Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString tts_description_text = 13;</code>
     * @return The ttsDescriptionText.
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedString getTtsDescriptionText();
    /**
     * <pre>
     * Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString tts_description_text = 13;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getTtsDescriptionTextOrBuilder();

    /**
     * <code>optional .transit_realtime.Alert.SeverityLevel severity_level = 14 [default = UNKNOWN_SEVERITY];</code>
     * @return Whether the severityLevel field is set.
     */
    boolean hasSeverityLevel();
    /**
     * <code>optional .transit_realtime.Alert.SeverityLevel severity_level = 14 [default = UNKNOWN_SEVERITY];</code>
     * @return The severityLevel.
     */
    com.google.transit.realtime.GtfsRealtime.Alert.SeverityLevel getSeverityLevel();

    /**
     * <pre>
     * TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
     * The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. 
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedImage image = 15;</code>
     * @return Whether the image field is set.
     */
    boolean hasImage();
    /**
     * <pre>
     * TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
     * The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. 
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedImage image = 15;</code>
     * @return The image.
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedImage getImage();
    /**
     * <pre>
     * TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
     * The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. 
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedImage image = 15;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedImageOrBuilder getImageOrBuilder();

    /**
     * <pre>
     * Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
     * or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString image_alternative_text = 16;</code>
     * @return Whether the imageAlternativeText field is set.
     */
    boolean hasImageAlternativeText();
    /**
     * <pre>
     * Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
     * or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString image_alternative_text = 16;</code>
     * @return The imageAlternativeText.
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedString getImageAlternativeText();
    /**
     * <pre>
     * Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
     * or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString image_alternative_text = 16;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getImageAlternativeTextOrBuilder();

    /**
     * <pre>
     * Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString cause_detail = 17;</code>
     * @return Whether the causeDetail field is set.
     */
    boolean hasCauseDetail();
    /**
     * <pre>
     * Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString cause_detail = 17;</code>
     * @return The causeDetail.
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedString getCauseDetail();
    /**
     * <pre>
     * Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString cause_detail = 17;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getCauseDetailOrBuilder();

    /**
     * <pre>
     * Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString effect_detail = 18;</code>
     * @return Whether the effectDetail field is set.
     */
    boolean hasEffectDetail();
    /**
     * <pre>
     * Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString effect_detail = 18;</code>
     * @return The effectDetail.
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedString getEffectDetail();
    /**
     * <pre>
     * Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString effect_detail = 18;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getEffectDetailOrBuilder();
  }
  /**
   * <pre>
   * An alert, indicating some sort of incident in the public transit network.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.Alert}
   */
  public static final class Alert extends
      com.google.protobuf.GeneratedMessage.ExtendableMessage<
        Alert> implements
      // @@protoc_insertion_point(message_implements:transit_realtime.Alert)
      AlertOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 28,
        /* patch= */ 3,
        /* suffix= */ "",
        Alert.class.getName());
    }
    // Use Alert.newBuilder() to construct.
    private Alert(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.Alert, ?> builder) {
      super(builder);
    }
    private Alert() {
      activePeriod_ = java.util.Collections.emptyList();
      informedEntity_ = java.util.Collections.emptyList();
      cause_ = 1;
      effect_ = 8;
      severityLevel_ = 1;
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_Alert_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_Alert_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.transit.realtime.GtfsRealtime.Alert.class, com.google.transit.realtime.GtfsRealtime.Alert.Builder.class);
    }

    /**
     * <pre>
     * Cause of this alert. If cause_detail is included, then Cause must also be included.
     * </pre>
     *
     * Protobuf enum {@code transit_realtime.Alert.Cause}
     */
    public enum Cause
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>UNKNOWN_CAUSE = 1;</code>
       */
      UNKNOWN_CAUSE(1),
      /**
       * <pre>
       * Not machine-representable.
       * </pre>
       *
       * <code>OTHER_CAUSE = 2;</code>
       */
      OTHER_CAUSE(2),
      /**
       * <code>TECHNICAL_PROBLEM = 3;</code>
       */
      TECHNICAL_PROBLEM(3),
      /**
       * <pre>
       * Public transit agency employees stopped working.
       * </pre>
       *
       * <code>STRIKE = 4;</code>
       */
      STRIKE(4),
      /**
       * <pre>
       * People are blocking the streets.
       * </pre>
       *
       * <code>DEMONSTRATION = 5;</code>
       */
      DEMONSTRATION(5),
      /**
       * <code>ACCIDENT = 6;</code>
       */
      ACCIDENT(6),
      /**
       * <code>HOLIDAY = 7;</code>
       */
      HOLIDAY(7),
      /**
       * <code>WEATHER = 8;</code>
       */
      WEATHER(8),
      /**
       * <code>MAINTENANCE = 9;</code>
       */
      MAINTENANCE(9),
      /**
       * <code>CONSTRUCTION = 10;</code>
       */
      CONSTRUCTION(10),
      /**
       * <code>POLICE_ACTIVITY = 11;</code>
       */
      POLICE_ACTIVITY(11),
      /**
       * <code>MEDICAL_EMERGENCY = 12;</code>
       */
      MEDICAL_EMERGENCY(12),
      ;

      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 28,
          /* patch= */ 3,
          /* suffix= */ "",
          Cause.class.getName());
      }
      /**
       * <code>UNKNOWN_CAUSE = 1;</code>
       */
      public static final int UNKNOWN_CAUSE_VALUE = 1;
      /**
       * <pre>
       * Not machine-representable.
       * </pre>
       *
       * <code>OTHER_CAUSE = 2;</code>
       */
      public static final int OTHER_CAUSE_VALUE = 2;
      /**
       * <code>TECHNICAL_PROBLEM = 3;</code>
       */
      public static final int TECHNICAL_PROBLEM_VALUE = 3;
      /**
       * <pre>
       * Public transit agency employees stopped working.
       * </pre>
       *
       * <code>STRIKE = 4;</code>
       */
      public static final int STRIKE_VALUE = 4;
      /**
       * <pre>
       * People are blocking the streets.
       * </pre>
       *
       * <code>DEMONSTRATION = 5;</code>
       */
      public static final int DEMONSTRATION_VALUE = 5;
      /**
       * <code>ACCIDENT = 6;</code>
       */
      public static final int ACCIDENT_VALUE = 6;
      /**
       * <code>HOLIDAY = 7;</code>
       */
      public static final int HOLIDAY_VALUE = 7;
      /**
       * <code>WEATHER = 8;</code>
       */
      public static final int WEATHER_VALUE = 8;
      /**
       * <code>MAINTENANCE = 9;</code>
       */
      public static final int MAINTENANCE_VALUE = 9;
      /**
       * <code>CONSTRUCTION = 10;</code>
       */
      public static final int CONSTRUCTION_VALUE = 10;
      /**
       * <code>POLICE_ACTIVITY = 11;</code>
       */
      public static final int POLICE_ACTIVITY_VALUE = 11;
      /**
       * <code>MEDICAL_EMERGENCY = 12;</code>
       */
      public static final int MEDICAL_EMERGENCY_VALUE = 12;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Cause valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static Cause forNumber(int value) {
        switch (value) {
          case 1: return UNKNOWN_CAUSE;
          case 2: return OTHER_CAUSE;
          case 3: return TECHNICAL_PROBLEM;
          case 4: return STRIKE;
          case 5: return DEMONSTRATION;
          case 6: return ACCIDENT;
          case 7: return HOLIDAY;
          case 8: return WEATHER;
          case 9: return MAINTENANCE;
          case 10: return CONSTRUCTION;
          case 11: return POLICE_ACTIVITY;
          case 12: return MEDICAL_EMERGENCY;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Cause>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Cause> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Cause>() {
              public Cause findValueByNumber(int number) {
                return Cause.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.Alert.getDescriptor().getEnumTypes().get(0);
      }

      private static final Cause[] VALUES = values();

      public static Cause valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private Cause(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_realtime.Alert.Cause)
    }

    /**
     * <pre>
     * What is the effect of this problem on the affected entity. If effect_detail is included, then Effect must also be included.
     * </pre>
     *
     * Protobuf enum {@code transit_realtime.Alert.Effect}
     */
    public enum Effect
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>NO_SERVICE = 1;</code>
       */
      NO_SERVICE(1),
      /**
       * <code>REDUCED_SERVICE = 2;</code>
       */
      REDUCED_SERVICE(2),
      /**
       * <pre>
       * We don't care about INsignificant delays: they are hard to detect, have
       * little impact on the user, and would clutter the results as they are too
       * frequent.
       * </pre>
       *
       * <code>SIGNIFICANT_DELAYS = 3;</code>
       */
      SIGNIFICANT_DELAYS(3),
      /**
       * <code>DETOUR = 4;</code>
       */
      DETOUR(4),
      /**
       * <code>ADDITIONAL_SERVICE = 5;</code>
       */
      ADDITIONAL_SERVICE(5),
      /**
       * <code>MODIFIED_SERVICE = 6;</code>
       */
      MODIFIED_SERVICE(6),
      /**
       * <code>OTHER_EFFECT = 7;</code>
       */
      OTHER_EFFECT(7),
      /**
       * <code>UNKNOWN_EFFECT = 8;</code>
       */
      UNKNOWN_EFFECT(8),
      /**
       * <code>STOP_MOVED = 9;</code>
       */
      STOP_MOVED(9),
      /**
       * <code>NO_EFFECT = 10;</code>
       */
      NO_EFFECT(10),
      /**
       * <code>ACCESSIBILITY_ISSUE = 11;</code>
       */
      ACCESSIBILITY_ISSUE(11),
      ;

      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 28,
          /* patch= */ 3,
          /* suffix= */ "",
          Effect.class.getName());
      }
      /**
       * <code>NO_SERVICE = 1;</code>
       */
      public static final int NO_SERVICE_VALUE = 1;
      /**
       * <code>REDUCED_SERVICE = 2;</code>
       */
      public static final int REDUCED_SERVICE_VALUE = 2;
      /**
       * <pre>
       * We don't care about INsignificant delays: they are hard to detect, have
       * little impact on the user, and would clutter the results as they are too
       * frequent.
       * </pre>
       *
       * <code>SIGNIFICANT_DELAYS = 3;</code>
       */
      public static final int SIGNIFICANT_DELAYS_VALUE = 3;
      /**
       * <code>DETOUR = 4;</code>
       */
      public static final int DETOUR_VALUE = 4;
      /**
       * <code>ADDITIONAL_SERVICE = 5;</code>
       */
      public static final int ADDITIONAL_SERVICE_VALUE = 5;
      /**
       * <code>MODIFIED_SERVICE = 6;</code>
       */
      public static final int MODIFIED_SERVICE_VALUE = 6;
      /**
       * <code>OTHER_EFFECT = 7;</code>
       */
      public static final int OTHER_EFFECT_VALUE = 7;
      /**
       * <code>UNKNOWN_EFFECT = 8;</code>
       */
      public static final int UNKNOWN_EFFECT_VALUE = 8;
      /**
       * <code>STOP_MOVED = 9;</code>
       */
      public static final int STOP_MOVED_VALUE = 9;
      /**
       * <code>NO_EFFECT = 10;</code>
       */
      public static final int NO_EFFECT_VALUE = 10;
      /**
       * <code>ACCESSIBILITY_ISSUE = 11;</code>
       */
      public static final int ACCESSIBILITY_ISSUE_VALUE = 11;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Effect valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static Effect forNumber(int value) {
        switch (value) {
          case 1: return NO_SERVICE;
          case 2: return REDUCED_SERVICE;
          case 3: return SIGNIFICANT_DELAYS;
          case 4: return DETOUR;
          case 5: return ADDITIONAL_SERVICE;
          case 6: return MODIFIED_SERVICE;
          case 7: return OTHER_EFFECT;
          case 8: return UNKNOWN_EFFECT;
          case 9: return STOP_MOVED;
          case 10: return NO_EFFECT;
          case 11: return ACCESSIBILITY_ISSUE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Effect>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Effect> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Effect>() {
              public Effect findValueByNumber(int number) {
                return Effect.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.Alert.getDescriptor().getEnumTypes().get(1);
      }

      private static final Effect[] VALUES = values();

      public static Effect valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private Effect(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_realtime.Alert.Effect)
    }

    /**
     * <pre>
     * Severity of this alert.
     * </pre>
     *
     * Protobuf enum {@code transit_realtime.Alert.SeverityLevel}
     */
    public enum SeverityLevel
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>UNKNOWN_SEVERITY = 1;</code>
       */
      UNKNOWN_SEVERITY(1),
      /**
       * <code>INFO = 2;</code>
       */
      INFO(2),
      /**
       * <code>WARNING = 3;</code>
       */
      WARNING(3),
      /**
       * <code>SEVERE = 4;</code>
       */
      SEVERE(4),
      ;

      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 28,
          /* patch= */ 3,
          /* suffix= */ "",
          SeverityLevel.class.getName());
      }
      /**
       * <code>UNKNOWN_SEVERITY = 1;</code>
       */
      public static final int UNKNOWN_SEVERITY_VALUE = 1;
      /**
       * <code>INFO = 2;</code>
       */
      public static final int INFO_VALUE = 2;
      /**
       * <code>WARNING = 3;</code>
       */
      public static final int WARNING_VALUE = 3;
      /**
       * <code>SEVERE = 4;</code>
       */
      public static final int SEVERE_VALUE = 4;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static SeverityLevel valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static SeverityLevel forNumber(int value) {
        switch (value) {
          case 1: return UNKNOWN_SEVERITY;
          case 2: return INFO;
          case 3: return WARNING;
          case 4: return SEVERE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<SeverityLevel>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          SeverityLevel> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SeverityLevel>() {
              public SeverityLevel findValueByNumber(int number) {
                return SeverityLevel.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.Alert.getDescriptor().getEnumTypes().get(2);
      }

      private static final SeverityLevel[] VALUES = values();

      public static SeverityLevel valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private SeverityLevel(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_realtime.Alert.SeverityLevel)
    }

    private int bitField0_;
    public static final int ACTIVE_PERIOD_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<com.google.transit.realtime.GtfsRealtime.TimeRange> activePeriod_;
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.transit.realtime.GtfsRealtime.TimeRange> getActivePeriodList() {
      return activePeriod_;
    }
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.TimeRangeOrBuilder> 
        getActivePeriodOrBuilderList() {
      return activePeriod_;
    }
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    @java.lang.Override
    public int getActivePeriodCount() {
      return activePeriod_.size();
    }
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TimeRange getActivePeriod(int index) {
      return activePeriod_.get(index);
    }
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TimeRangeOrBuilder getActivePeriodOrBuilder(
        int index) {
      return activePeriod_.get(index);
    }

    public static final int INFORMED_ENTITY_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private java.util.List<com.google.transit.realtime.GtfsRealtime.EntitySelector> informedEntity_;
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.transit.realtime.GtfsRealtime.EntitySelector> getInformedEntityList() {
      return informedEntity_;
    }
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    @java.lang.Override
    public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.EntitySelectorOrBuilder> 
        getInformedEntityOrBuilderList() {
      return informedEntity_;
    }
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    @java.lang.Override
    public int getInformedEntityCount() {
      return informedEntity_.size();
    }
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.EntitySelector getInformedEntity(int index) {
      return informedEntity_.get(index);
    }
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.EntitySelectorOrBuilder getInformedEntityOrBuilder(
        int index) {
      return informedEntity_.get(index);
    }

    public static final int CAUSE_FIELD_NUMBER = 6;
    private int cause_ = 1;
    /**
     * <code>optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];</code>
     * @return Whether the cause field is set.
     */
    @java.lang.Override public boolean hasCause() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];</code>
     * @return The cause.
     */
    @java.lang.Override public com.google.transit.realtime.GtfsRealtime.Alert.Cause getCause() {
      com.google.transit.realtime.GtfsRealtime.Alert.Cause result = com.google.transit.realtime.GtfsRealtime.Alert.Cause.forNumber(cause_);
      return result == null ? com.google.transit.realtime.GtfsRealtime.Alert.Cause.UNKNOWN_CAUSE : result;
    }

    public static final int EFFECT_FIELD_NUMBER = 7;
    private int effect_ = 8;
    /**
     * <code>optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];</code>
     * @return Whether the effect field is set.
     */
    @java.lang.Override public boolean hasEffect() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];</code>
     * @return The effect.
     */
    @java.lang.Override public com.google.transit.realtime.GtfsRealtime.Alert.Effect getEffect() {
      com.google.transit.realtime.GtfsRealtime.Alert.Effect result = com.google.transit.realtime.GtfsRealtime.Alert.Effect.forNumber(effect_);
      return result == null ? com.google.transit.realtime.GtfsRealtime.Alert.Effect.UNKNOWN_EFFECT : result;
    }

    public static final int URL_FIELD_NUMBER = 8;
    private com.google.transit.realtime.GtfsRealtime.TranslatedString url_;
    /**
     * <pre>
     * The URL which provides additional information about the alert.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString url = 8;</code>
     * @return Whether the url field is set.
     */
    @java.lang.Override
    public boolean hasUrl() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The URL which provides additional information about the alert.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString url = 8;</code>
     * @return The url.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedString getUrl() {
      return url_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : url_;
    }
    /**
     * <pre>
     * The URL which provides additional information about the alert.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString url = 8;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getUrlOrBuilder() {
      return url_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : url_;
    }

    public static final int HEADER_TEXT_FIELD_NUMBER = 10;
    private com.google.transit.realtime.GtfsRealtime.TranslatedString headerText_;
    /**
     * <pre>
     * Alert header. Contains a short summary of the alert text as plain-text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
     * @return Whether the headerText field is set.
     */
    @java.lang.Override
    public boolean hasHeaderText() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Alert header. Contains a short summary of the alert text as plain-text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
     * @return The headerText.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedString getHeaderText() {
      return headerText_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : headerText_;
    }
    /**
     * <pre>
     * Alert header. Contains a short summary of the alert text as plain-text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getHeaderTextOrBuilder() {
      return headerText_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : headerText_;
    }

    public static final int DESCRIPTION_TEXT_FIELD_NUMBER = 11;
    private com.google.transit.realtime.GtfsRealtime.TranslatedString descriptionText_;
    /**
     * <pre>
     * Full description for the alert as plain-text. The information in the
     * description should add to the information of the header.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
     * @return Whether the descriptionText field is set.
     */
    @java.lang.Override
    public boolean hasDescriptionText() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Full description for the alert as plain-text. The information in the
     * description should add to the information of the header.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
     * @return The descriptionText.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedString getDescriptionText() {
      return descriptionText_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : descriptionText_;
    }
    /**
     * <pre>
     * Full description for the alert as plain-text. The information in the
     * description should add to the information of the header.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getDescriptionTextOrBuilder() {
      return descriptionText_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : descriptionText_;
    }

    public static final int TTS_HEADER_TEXT_FIELD_NUMBER = 12;
    private com.google.transit.realtime.GtfsRealtime.TranslatedString ttsHeaderText_;
    /**
     * <pre>
     * Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString tts_header_text = 12;</code>
     * @return Whether the ttsHeaderText field is set.
     */
    @java.lang.Override
    public boolean hasTtsHeaderText() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString tts_header_text = 12;</code>
     * @return The ttsHeaderText.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedString getTtsHeaderText() {
      return ttsHeaderText_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : ttsHeaderText_;
    }
    /**
     * <pre>
     * Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString tts_header_text = 12;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getTtsHeaderTextOrBuilder() {
      return ttsHeaderText_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : ttsHeaderText_;
    }

    public static final int TTS_DESCRIPTION_TEXT_FIELD_NUMBER = 13;
    private com.google.transit.realtime.GtfsRealtime.TranslatedString ttsDescriptionText_;
    /**
     * <pre>
     * Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString tts_description_text = 13;</code>
     * @return Whether the ttsDescriptionText field is set.
     */
    @java.lang.Override
    public boolean hasTtsDescriptionText() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString tts_description_text = 13;</code>
     * @return The ttsDescriptionText.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedString getTtsDescriptionText() {
      return ttsDescriptionText_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : ttsDescriptionText_;
    }
    /**
     * <pre>
     * Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString tts_description_text = 13;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getTtsDescriptionTextOrBuilder() {
      return ttsDescriptionText_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : ttsDescriptionText_;
    }

    public static final int SEVERITY_LEVEL_FIELD_NUMBER = 14;
    private int severityLevel_ = 1;
    /**
     * <code>optional .transit_realtime.Alert.SeverityLevel severity_level = 14 [default = UNKNOWN_SEVERITY];</code>
     * @return Whether the severityLevel field is set.
     */
    @java.lang.Override public boolean hasSeverityLevel() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <code>optional .transit_realtime.Alert.SeverityLevel severity_level = 14 [default = UNKNOWN_SEVERITY];</code>
     * @return The severityLevel.
     */
    @java.lang.Override public com.google.transit.realtime.GtfsRealtime.Alert.SeverityLevel getSeverityLevel() {
      com.google.transit.realtime.GtfsRealtime.Alert.SeverityLevel result = com.google.transit.realtime.GtfsRealtime.Alert.SeverityLevel.forNumber(severityLevel_);
      return result == null ? com.google.transit.realtime.GtfsRealtime.Alert.SeverityLevel.UNKNOWN_SEVERITY : result;
    }

    public static final int IMAGE_FIELD_NUMBER = 15;
    private com.google.transit.realtime.GtfsRealtime.TranslatedImage image_;
    /**
     * <pre>
     * TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
     * The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. 
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedImage image = 15;</code>
     * @return Whether the image field is set.
     */
    @java.lang.Override
    public boolean hasImage() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
     * The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. 
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedImage image = 15;</code>
     * @return The image.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedImage getImage() {
      return image_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedImage.getDefaultInstance() : image_;
    }
    /**
     * <pre>
     * TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
     * The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. 
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedImage image = 15;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedImageOrBuilder getImageOrBuilder() {
      return image_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedImage.getDefaultInstance() : image_;
    }

    public static final int IMAGE_ALTERNATIVE_TEXT_FIELD_NUMBER = 16;
    private com.google.transit.realtime.GtfsRealtime.TranslatedString imageAlternativeText_;
    /**
     * <pre>
     * Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
     * or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString image_alternative_text = 16;</code>
     * @return Whether the imageAlternativeText field is set.
     */
    @java.lang.Override
    public boolean hasImageAlternativeText() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
     * or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString image_alternative_text = 16;</code>
     * @return The imageAlternativeText.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedString getImageAlternativeText() {
      return imageAlternativeText_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : imageAlternativeText_;
    }
    /**
     * <pre>
     * Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
     * or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString image_alternative_text = 16;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getImageAlternativeTextOrBuilder() {
      return imageAlternativeText_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : imageAlternativeText_;
    }

    public static final int CAUSE_DETAIL_FIELD_NUMBER = 17;
    private com.google.transit.realtime.GtfsRealtime.TranslatedString causeDetail_;
    /**
     * <pre>
     * Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString cause_detail = 17;</code>
     * @return Whether the causeDetail field is set.
     */
    @java.lang.Override
    public boolean hasCauseDetail() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString cause_detail = 17;</code>
     * @return The causeDetail.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedString getCauseDetail() {
      return causeDetail_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : causeDetail_;
    }
    /**
     * <pre>
     * Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString cause_detail = 17;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getCauseDetailOrBuilder() {
      return causeDetail_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : causeDetail_;
    }

    public static final int EFFECT_DETAIL_FIELD_NUMBER = 18;
    private com.google.transit.realtime.GtfsRealtime.TranslatedString effectDetail_;
    /**
     * <pre>
     * Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString effect_detail = 18;</code>
     * @return Whether the effectDetail field is set.
     */
    @java.lang.Override
    public boolean hasEffectDetail() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString effect_detail = 18;</code>
     * @return The effectDetail.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedString getEffectDetail() {
      return effectDetail_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : effectDetail_;
    }
    /**
     * <pre>
     * Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString effect_detail = 18;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getEffectDetailOrBuilder() {
      return effectDetail_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : effectDetail_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      for (int i = 0; i < getActivePeriodCount(); i++) {
        if (!getActivePeriod(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      for (int i = 0; i < getInformedEntityCount(); i++) {
        if (!getInformedEntity(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasUrl()) {
        if (!getUrl().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasHeaderText()) {
        if (!getHeaderText().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasDescriptionText()) {
        if (!getDescriptionText().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasTtsHeaderText()) {
        if (!getTtsHeaderText().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasTtsDescriptionText()) {
        if (!getTtsDescriptionText().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasImage()) {
        if (!getImage().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasImageAlternativeText()) {
        if (!getImageAlternativeText().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasCauseDetail()) {
        if (!getCauseDetail().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasEffectDetail()) {
        if (!getEffectDetail().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (!extensionsAreInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessage
        .ExtendableMessage.ExtensionSerializer
          extensionWriter = newExtensionSerializer();
      for (int i = 0; i < activePeriod_.size(); i++) {
        output.writeMessage(1, activePeriod_.get(i));
      }
      for (int i = 0; i < informedEntity_.size(); i++) {
        output.writeMessage(5, informedEntity_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeEnum(6, cause_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeEnum(7, effect_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(8, getUrl());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(10, getHeaderText());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeMessage(11, getDescriptionText());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeMessage(12, getTtsHeaderText());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeMessage(13, getTtsDescriptionText());
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeEnum(14, severityLevel_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeMessage(15, getImage());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeMessage(16, getImageAlternativeText());
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeMessage(17, getCauseDetail());
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeMessage(18, getEffectDetail());
      }
      extensionWriter.writeUntil(10000, output);
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < activePeriod_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, activePeriod_.get(i));
      }
      for (int i = 0; i < informedEntity_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, informedEntity_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(6, cause_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(7, effect_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getUrl());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, getHeaderText());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, getDescriptionText());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(12, getTtsHeaderText());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(13, getTtsDescriptionText());
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(14, severityLevel_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(15, getImage());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(16, getImageAlternativeText());
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(17, getCauseDetail());
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(18, getEffectDetail());
      }
      size += extensionsSerializedSize();
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.Alert)) {
        return super.equals(obj);
      }
      com.google.transit.realtime.GtfsRealtime.Alert other = (com.google.transit.realtime.GtfsRealtime.Alert) obj;

      if (!getActivePeriodList()
          .equals(other.getActivePeriodList())) return false;
      if (!getInformedEntityList()
          .equals(other.getInformedEntityList())) return false;
      if (hasCause() != other.hasCause()) return false;
      if (hasCause()) {
        if (cause_ != other.cause_) return false;
      }
      if (hasEffect() != other.hasEffect()) return false;
      if (hasEffect()) {
        if (effect_ != other.effect_) return false;
      }
      if (hasUrl() != other.hasUrl()) return false;
      if (hasUrl()) {
        if (!getUrl()
            .equals(other.getUrl())) return false;
      }
      if (hasHeaderText() != other.hasHeaderText()) return false;
      if (hasHeaderText()) {
        if (!getHeaderText()
            .equals(other.getHeaderText())) return false;
      }
      if (hasDescriptionText() != other.hasDescriptionText()) return false;
      if (hasDescriptionText()) {
        if (!getDescriptionText()
            .equals(other.getDescriptionText())) return false;
      }
      if (hasTtsHeaderText() != other.hasTtsHeaderText()) return false;
      if (hasTtsHeaderText()) {
        if (!getTtsHeaderText()
            .equals(other.getTtsHeaderText())) return false;
      }
      if (hasTtsDescriptionText() != other.hasTtsDescriptionText()) return false;
      if (hasTtsDescriptionText()) {
        if (!getTtsDescriptionText()
            .equals(other.getTtsDescriptionText())) return false;
      }
      if (hasSeverityLevel() != other.hasSeverityLevel()) return false;
      if (hasSeverityLevel()) {
        if (severityLevel_ != other.severityLevel_) return false;
      }
      if (hasImage() != other.hasImage()) return false;
      if (hasImage()) {
        if (!getImage()
            .equals(other.getImage())) return false;
      }
      if (hasImageAlternativeText() != other.hasImageAlternativeText()) return false;
      if (hasImageAlternativeText()) {
        if (!getImageAlternativeText()
            .equals(other.getImageAlternativeText())) return false;
      }
      if (hasCauseDetail() != other.hasCauseDetail()) return false;
      if (hasCauseDetail()) {
        if (!getCauseDetail()
            .equals(other.getCauseDetail())) return false;
      }
      if (hasEffectDetail() != other.hasEffectDetail()) return false;
      if (hasEffectDetail()) {
        if (!getEffectDetail()
            .equals(other.getEffectDetail())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      if (!getExtensionFields().equals(other.getExtensionFields()))
        return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getActivePeriodCount() > 0) {
        hash = (37 * hash) + ACTIVE_PERIOD_FIELD_NUMBER;
        hash = (53 * hash) + getActivePeriodList().hashCode();
      }
      if (getInformedEntityCount() > 0) {
        hash = (37 * hash) + INFORMED_ENTITY_FIELD_NUMBER;
        hash = (53 * hash) + getInformedEntityList().hashCode();
      }
      if (hasCause()) {
        hash = (37 * hash) + CAUSE_FIELD_NUMBER;
        hash = (53 * hash) + cause_;
      }
      if (hasEffect()) {
        hash = (37 * hash) + EFFECT_FIELD_NUMBER;
        hash = (53 * hash) + effect_;
      }
      if (hasUrl()) {
        hash = (37 * hash) + URL_FIELD_NUMBER;
        hash = (53 * hash) + getUrl().hashCode();
      }
      if (hasHeaderText()) {
        hash = (37 * hash) + HEADER_TEXT_FIELD_NUMBER;
        hash = (53 * hash) + getHeaderText().hashCode();
      }
      if (hasDescriptionText()) {
        hash = (37 * hash) + DESCRIPTION_TEXT_FIELD_NUMBER;
        hash = (53 * hash) + getDescriptionText().hashCode();
      }
      if (hasTtsHeaderText()) {
        hash = (37 * hash) + TTS_HEADER_TEXT_FIELD_NUMBER;
        hash = (53 * hash) + getTtsHeaderText().hashCode();
      }
      if (hasTtsDescriptionText()) {
        hash = (37 * hash) + TTS_DESCRIPTION_TEXT_FIELD_NUMBER;
        hash = (53 * hash) + getTtsDescriptionText().hashCode();
      }
      if (hasSeverityLevel()) {
        hash = (37 * hash) + SEVERITY_LEVEL_FIELD_NUMBER;
        hash = (53 * hash) + severityLevel_;
      }
      if (hasImage()) {
        hash = (37 * hash) + IMAGE_FIELD_NUMBER;
        hash = (53 * hash) + getImage().hashCode();
      }
      if (hasImageAlternativeText()) {
        hash = (37 * hash) + IMAGE_ALTERNATIVE_TEXT_FIELD_NUMBER;
        hash = (53 * hash) + getImageAlternativeText().hashCode();
      }
      if (hasCauseDetail()) {
        hash = (37 * hash) + CAUSE_DETAIL_FIELD_NUMBER;
        hash = (53 * hash) + getCauseDetail().hashCode();
      }
      if (hasEffectDetail()) {
        hash = (37 * hash) + EFFECT_DETAIL_FIELD_NUMBER;
        hash = (53 * hash) + getEffectDetail().hashCode();
      }
      hash = hashFields(hash, getExtensionFields());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.transit.realtime.GtfsRealtime.Alert parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.Alert parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Alert parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.Alert parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Alert parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.Alert parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Alert parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.Alert parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.transit.realtime.GtfsRealtime.Alert parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.transit.realtime.GtfsRealtime.Alert parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Alert parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.Alert parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.Alert prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * An alert, indicating some sort of incident in the public transit network.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.Alert}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
          com.google.transit.realtime.GtfsRealtime.Alert, Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_realtime.Alert)
        com.google.transit.realtime.GtfsRealtime.AlertOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_Alert_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_Alert_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.Alert.class, com.google.transit.realtime.GtfsRealtime.Alert.Builder.class);
      }

      // Construct using com.google.transit.realtime.GtfsRealtime.Alert.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getActivePeriodFieldBuilder();
          getInformedEntityFieldBuilder();
          getUrlFieldBuilder();
          getHeaderTextFieldBuilder();
          getDescriptionTextFieldBuilder();
          getTtsHeaderTextFieldBuilder();
          getTtsDescriptionTextFieldBuilder();
          getImageFieldBuilder();
          getImageAlternativeTextFieldBuilder();
          getCauseDetailFieldBuilder();
          getEffectDetailFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (activePeriodBuilder_ == null) {
          activePeriod_ = java.util.Collections.emptyList();
        } else {
          activePeriod_ = null;
          activePeriodBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (informedEntityBuilder_ == null) {
          informedEntity_ = java.util.Collections.emptyList();
        } else {
          informedEntity_ = null;
          informedEntityBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        cause_ = 1;
        effect_ = 8;
        url_ = null;
        if (urlBuilder_ != null) {
          urlBuilder_.dispose();
          urlBuilder_ = null;
        }
        headerText_ = null;
        if (headerTextBuilder_ != null) {
          headerTextBuilder_.dispose();
          headerTextBuilder_ = null;
        }
        descriptionText_ = null;
        if (descriptionTextBuilder_ != null) {
          descriptionTextBuilder_.dispose();
          descriptionTextBuilder_ = null;
        }
        ttsHeaderText_ = null;
        if (ttsHeaderTextBuilder_ != null) {
          ttsHeaderTextBuilder_.dispose();
          ttsHeaderTextBuilder_ = null;
        }
        ttsDescriptionText_ = null;
        if (ttsDescriptionTextBuilder_ != null) {
          ttsDescriptionTextBuilder_.dispose();
          ttsDescriptionTextBuilder_ = null;
        }
        severityLevel_ = 1;
        image_ = null;
        if (imageBuilder_ != null) {
          imageBuilder_.dispose();
          imageBuilder_ = null;
        }
        imageAlternativeText_ = null;
        if (imageAlternativeTextBuilder_ != null) {
          imageAlternativeTextBuilder_.dispose();
          imageAlternativeTextBuilder_ = null;
        }
        causeDetail_ = null;
        if (causeDetailBuilder_ != null) {
          causeDetailBuilder_.dispose();
          causeDetailBuilder_ = null;
        }
        effectDetail_ = null;
        if (effectDetailBuilder_ != null) {
          effectDetailBuilder_.dispose();
          effectDetailBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_Alert_descriptor;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.Alert getDefaultInstanceForType() {
        return com.google.transit.realtime.GtfsRealtime.Alert.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.Alert build() {
        com.google.transit.realtime.GtfsRealtime.Alert result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.Alert buildPartial() {
        com.google.transit.realtime.GtfsRealtime.Alert result = new com.google.transit.realtime.GtfsRealtime.Alert(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(com.google.transit.realtime.GtfsRealtime.Alert result) {
        if (activePeriodBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            activePeriod_ = java.util.Collections.unmodifiableList(activePeriod_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.activePeriod_ = activePeriod_;
        } else {
          result.activePeriod_ = activePeriodBuilder_.build();
        }
        if (informedEntityBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            informedEntity_ = java.util.Collections.unmodifiableList(informedEntity_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.informedEntity_ = informedEntity_;
        } else {
          result.informedEntity_ = informedEntityBuilder_.build();
        }
      }

      private void buildPartial0(com.google.transit.realtime.GtfsRealtime.Alert result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.cause_ = cause_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.effect_ = effect_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.url_ = urlBuilder_ == null
              ? url_
              : urlBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.headerText_ = headerTextBuilder_ == null
              ? headerText_
              : headerTextBuilder_.build();
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.descriptionText_ = descriptionTextBuilder_ == null
              ? descriptionText_
              : descriptionTextBuilder_.build();
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.ttsHeaderText_ = ttsHeaderTextBuilder_ == null
              ? ttsHeaderText_
              : ttsHeaderTextBuilder_.build();
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.ttsDescriptionText_ = ttsDescriptionTextBuilder_ == null
              ? ttsDescriptionText_
              : ttsDescriptionTextBuilder_.build();
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.severityLevel_ = severityLevel_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.image_ = imageBuilder_ == null
              ? image_
              : imageBuilder_.build();
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.imageAlternativeText_ = imageAlternativeTextBuilder_ == null
              ? imageAlternativeText_
              : imageAlternativeTextBuilder_.build();
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.causeDetail_ = causeDetailBuilder_ == null
              ? causeDetail_
              : causeDetailBuilder_.build();
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.effectDetail_ = effectDetailBuilder_ == null
              ? effectDetail_
              : effectDetailBuilder_.build();
          to_bitField0_ |= 0x00000800;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.transit.realtime.GtfsRealtime.Alert) {
          return mergeFrom((com.google.transit.realtime.GtfsRealtime.Alert)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.Alert other) {
        if (other == com.google.transit.realtime.GtfsRealtime.Alert.getDefaultInstance()) return this;
        if (activePeriodBuilder_ == null) {
          if (!other.activePeriod_.isEmpty()) {
            if (activePeriod_.isEmpty()) {
              activePeriod_ = other.activePeriod_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureActivePeriodIsMutable();
              activePeriod_.addAll(other.activePeriod_);
            }
            onChanged();
          }
        } else {
          if (!other.activePeriod_.isEmpty()) {
            if (activePeriodBuilder_.isEmpty()) {
              activePeriodBuilder_.dispose();
              activePeriodBuilder_ = null;
              activePeriod_ = other.activePeriod_;
              bitField0_ = (bitField0_ & ~0x00000001);
              activePeriodBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getActivePeriodFieldBuilder() : null;
            } else {
              activePeriodBuilder_.addAllMessages(other.activePeriod_);
            }
          }
        }
        if (informedEntityBuilder_ == null) {
          if (!other.informedEntity_.isEmpty()) {
            if (informedEntity_.isEmpty()) {
              informedEntity_ = other.informedEntity_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureInformedEntityIsMutable();
              informedEntity_.addAll(other.informedEntity_);
            }
            onChanged();
          }
        } else {
          if (!other.informedEntity_.isEmpty()) {
            if (informedEntityBuilder_.isEmpty()) {
              informedEntityBuilder_.dispose();
              informedEntityBuilder_ = null;
              informedEntity_ = other.informedEntity_;
              bitField0_ = (bitField0_ & ~0x00000002);
              informedEntityBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getInformedEntityFieldBuilder() : null;
            } else {
              informedEntityBuilder_.addAllMessages(other.informedEntity_);
            }
          }
        }
        if (other.hasCause()) {
          setCause(other.getCause());
        }
        if (other.hasEffect()) {
          setEffect(other.getEffect());
        }
        if (other.hasUrl()) {
          mergeUrl(other.getUrl());
        }
        if (other.hasHeaderText()) {
          mergeHeaderText(other.getHeaderText());
        }
        if (other.hasDescriptionText()) {
          mergeDescriptionText(other.getDescriptionText());
        }
        if (other.hasTtsHeaderText()) {
          mergeTtsHeaderText(other.getTtsHeaderText());
        }
        if (other.hasTtsDescriptionText()) {
          mergeTtsDescriptionText(other.getTtsDescriptionText());
        }
        if (other.hasSeverityLevel()) {
          setSeverityLevel(other.getSeverityLevel());
        }
        if (other.hasImage()) {
          mergeImage(other.getImage());
        }
        if (other.hasImageAlternativeText()) {
          mergeImageAlternativeText(other.getImageAlternativeText());
        }
        if (other.hasCauseDetail()) {
          mergeCauseDetail(other.getCauseDetail());
        }
        if (other.hasEffectDetail()) {
          mergeEffectDetail(other.getEffectDetail());
        }
        this.mergeExtensionFields(other);
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        for (int i = 0; i < getActivePeriodCount(); i++) {
          if (!getActivePeriod(i).isInitialized()) {
            return false;
          }
        }
        for (int i = 0; i < getInformedEntityCount(); i++) {
          if (!getInformedEntity(i).isInitialized()) {
            return false;
          }
        }
        if (hasUrl()) {
          if (!getUrl().isInitialized()) {
            return false;
          }
        }
        if (hasHeaderText()) {
          if (!getHeaderText().isInitialized()) {
            return false;
          }
        }
        if (hasDescriptionText()) {
          if (!getDescriptionText().isInitialized()) {
            return false;
          }
        }
        if (hasTtsHeaderText()) {
          if (!getTtsHeaderText().isInitialized()) {
            return false;
          }
        }
        if (hasTtsDescriptionText()) {
          if (!getTtsDescriptionText().isInitialized()) {
            return false;
          }
        }
        if (hasImage()) {
          if (!getImage().isInitialized()) {
            return false;
          }
        }
        if (hasImageAlternativeText()) {
          if (!getImageAlternativeText().isInitialized()) {
            return false;
          }
        }
        if (hasCauseDetail()) {
          if (!getCauseDetail().isInitialized()) {
            return false;
          }
        }
        if (hasEffectDetail()) {
          if (!getEffectDetail().isInitialized()) {
            return false;
          }
        }
        if (!extensionsAreInitialized()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.google.transit.realtime.GtfsRealtime.TimeRange m =
                    input.readMessage(
                        com.google.transit.realtime.GtfsRealtime.TimeRange.parser(),
                        extensionRegistry);
                if (activePeriodBuilder_ == null) {
                  ensureActivePeriodIsMutable();
                  activePeriod_.add(m);
                } else {
                  activePeriodBuilder_.addMessage(m);
                }
                break;
              } // case 10
              case 42: {
                com.google.transit.realtime.GtfsRealtime.EntitySelector m =
                    input.readMessage(
                        com.google.transit.realtime.GtfsRealtime.EntitySelector.parser(),
                        extensionRegistry);
                if (informedEntityBuilder_ == null) {
                  ensureInformedEntityIsMutable();
                  informedEntity_.add(m);
                } else {
                  informedEntityBuilder_.addMessage(m);
                }
                break;
              } // case 42
              case 48: {
                int tmpRaw = input.readEnum();
                com.google.transit.realtime.GtfsRealtime.Alert.Cause tmpValue =
                    com.google.transit.realtime.GtfsRealtime.Alert.Cause.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(6, tmpRaw);
                } else {
                  cause_ = tmpRaw;
                  bitField0_ |= 0x00000004;
                }
                break;
              } // case 48
              case 56: {
                int tmpRaw = input.readEnum();
                com.google.transit.realtime.GtfsRealtime.Alert.Effect tmpValue =
                    com.google.transit.realtime.GtfsRealtime.Alert.Effect.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(7, tmpRaw);
                } else {
                  effect_ = tmpRaw;
                  bitField0_ |= 0x00000008;
                }
                break;
              } // case 56
              case 66: {
                input.readMessage(
                    getUrlFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000010;
                break;
              } // case 66
              case 82: {
                input.readMessage(
                    getHeaderTextFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000020;
                break;
              } // case 82
              case 90: {
                input.readMessage(
                    getDescriptionTextFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000040;
                break;
              } // case 90
              case 98: {
                input.readMessage(
                    getTtsHeaderTextFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000080;
                break;
              } // case 98
              case 106: {
                input.readMessage(
                    getTtsDescriptionTextFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000100;
                break;
              } // case 106
              case 112: {
                int tmpRaw = input.readEnum();
                com.google.transit.realtime.GtfsRealtime.Alert.SeverityLevel tmpValue =
                    com.google.transit.realtime.GtfsRealtime.Alert.SeverityLevel.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(14, tmpRaw);
                } else {
                  severityLevel_ = tmpRaw;
                  bitField0_ |= 0x00000200;
                }
                break;
              } // case 112
              case 122: {
                input.readMessage(
                    getImageFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000400;
                break;
              } // case 122
              case 130: {
                input.readMessage(
                    getImageAlternativeTextFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000800;
                break;
              } // case 130
              case 138: {
                input.readMessage(
                    getCauseDetailFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00001000;
                break;
              } // case 138
              case 146: {
                input.readMessage(
                    getEffectDetailFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00002000;
                break;
              } // case 146
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<com.google.transit.realtime.GtfsRealtime.TimeRange> activePeriod_ =
        java.util.Collections.emptyList();
      private void ensureActivePeriodIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          activePeriod_ = new java.util.ArrayList<com.google.transit.realtime.GtfsRealtime.TimeRange>(activePeriod_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TimeRange, com.google.transit.realtime.GtfsRealtime.TimeRange.Builder, com.google.transit.realtime.GtfsRealtime.TimeRangeOrBuilder> activePeriodBuilder_;

      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.TimeRange> getActivePeriodList() {
        if (activePeriodBuilder_ == null) {
          return java.util.Collections.unmodifiableList(activePeriod_);
        } else {
          return activePeriodBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public int getActivePeriodCount() {
        if (activePeriodBuilder_ == null) {
          return activePeriod_.size();
        } else {
          return activePeriodBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TimeRange getActivePeriod(int index) {
        if (activePeriodBuilder_ == null) {
          return activePeriod_.get(index);
        } else {
          return activePeriodBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public Builder setActivePeriod(
          int index, com.google.transit.realtime.GtfsRealtime.TimeRange value) {
        if (activePeriodBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureActivePeriodIsMutable();
          activePeriod_.set(index, value);
          onChanged();
        } else {
          activePeriodBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public Builder setActivePeriod(
          int index, com.google.transit.realtime.GtfsRealtime.TimeRange.Builder builderForValue) {
        if (activePeriodBuilder_ == null) {
          ensureActivePeriodIsMutable();
          activePeriod_.set(index, builderForValue.build());
          onChanged();
        } else {
          activePeriodBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public Builder addActivePeriod(com.google.transit.realtime.GtfsRealtime.TimeRange value) {
        if (activePeriodBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureActivePeriodIsMutable();
          activePeriod_.add(value);
          onChanged();
        } else {
          activePeriodBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public Builder addActivePeriod(
          int index, com.google.transit.realtime.GtfsRealtime.TimeRange value) {
        if (activePeriodBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureActivePeriodIsMutable();
          activePeriod_.add(index, value);
          onChanged();
        } else {
          activePeriodBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public Builder addActivePeriod(
          com.google.transit.realtime.GtfsRealtime.TimeRange.Builder builderForValue) {
        if (activePeriodBuilder_ == null) {
          ensureActivePeriodIsMutable();
          activePeriod_.add(builderForValue.build());
          onChanged();
        } else {
          activePeriodBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public Builder addActivePeriod(
          int index, com.google.transit.realtime.GtfsRealtime.TimeRange.Builder builderForValue) {
        if (activePeriodBuilder_ == null) {
          ensureActivePeriodIsMutable();
          activePeriod_.add(index, builderForValue.build());
          onChanged();
        } else {
          activePeriodBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public Builder addAllActivePeriod(
          java.lang.Iterable<? extends com.google.transit.realtime.GtfsRealtime.TimeRange> values) {
        if (activePeriodBuilder_ == null) {
          ensureActivePeriodIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, activePeriod_);
          onChanged();
        } else {
          activePeriodBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public Builder clearActivePeriod() {
        if (activePeriodBuilder_ == null) {
          activePeriod_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          activePeriodBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public Builder removeActivePeriod(int index) {
        if (activePeriodBuilder_ == null) {
          ensureActivePeriodIsMutable();
          activePeriod_.remove(index);
          onChanged();
        } else {
          activePeriodBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TimeRange.Builder getActivePeriodBuilder(
          int index) {
        return getActivePeriodFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TimeRangeOrBuilder getActivePeriodOrBuilder(
          int index) {
        if (activePeriodBuilder_ == null) {
          return activePeriod_.get(index);  } else {
          return activePeriodBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.TimeRangeOrBuilder> 
           getActivePeriodOrBuilderList() {
        if (activePeriodBuilder_ != null) {
          return activePeriodBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(activePeriod_);
        }
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TimeRange.Builder addActivePeriodBuilder() {
        return getActivePeriodFieldBuilder().addBuilder(
            com.google.transit.realtime.GtfsRealtime.TimeRange.getDefaultInstance());
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TimeRange.Builder addActivePeriodBuilder(
          int index) {
        return getActivePeriodFieldBuilder().addBuilder(
            index, com.google.transit.realtime.GtfsRealtime.TimeRange.getDefaultInstance());
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.TimeRange.Builder> 
           getActivePeriodBuilderList() {
        return getActivePeriodFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TimeRange, com.google.transit.realtime.GtfsRealtime.TimeRange.Builder, com.google.transit.realtime.GtfsRealtime.TimeRangeOrBuilder> 
          getActivePeriodFieldBuilder() {
        if (activePeriodBuilder_ == null) {
          activePeriodBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TimeRange, com.google.transit.realtime.GtfsRealtime.TimeRange.Builder, com.google.transit.realtime.GtfsRealtime.TimeRangeOrBuilder>(
                  activePeriod_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          activePeriod_ = null;
        }
        return activePeriodBuilder_;
      }

      private java.util.List<com.google.transit.realtime.GtfsRealtime.EntitySelector> informedEntity_ =
        java.util.Collections.emptyList();
      private void ensureInformedEntityIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          informedEntity_ = new java.util.ArrayList<com.google.transit.realtime.GtfsRealtime.EntitySelector>(informedEntity_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.EntitySelector, com.google.transit.realtime.GtfsRealtime.EntitySelector.Builder, com.google.transit.realtime.GtfsRealtime.EntitySelectorOrBuilder> informedEntityBuilder_;

      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.EntitySelector> getInformedEntityList() {
        if (informedEntityBuilder_ == null) {
          return java.util.Collections.unmodifiableList(informedEntity_);
        } else {
          return informedEntityBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public int getInformedEntityCount() {
        if (informedEntityBuilder_ == null) {
          return informedEntity_.size();
        } else {
          return informedEntityBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.EntitySelector getInformedEntity(int index) {
        if (informedEntityBuilder_ == null) {
          return informedEntity_.get(index);
        } else {
          return informedEntityBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public Builder setInformedEntity(
          int index, com.google.transit.realtime.GtfsRealtime.EntitySelector value) {
        if (informedEntityBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInformedEntityIsMutable();
          informedEntity_.set(index, value);
          onChanged();
        } else {
          informedEntityBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public Builder setInformedEntity(
          int index, com.google.transit.realtime.GtfsRealtime.EntitySelector.Builder builderForValue) {
        if (informedEntityBuilder_ == null) {
          ensureInformedEntityIsMutable();
          informedEntity_.set(index, builderForValue.build());
          onChanged();
        } else {
          informedEntityBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public Builder addInformedEntity(com.google.transit.realtime.GtfsRealtime.EntitySelector value) {
        if (informedEntityBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInformedEntityIsMutable();
          informedEntity_.add(value);
          onChanged();
        } else {
          informedEntityBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public Builder addInformedEntity(
          int index, com.google.transit.realtime.GtfsRealtime.EntitySelector value) {
        if (informedEntityBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInformedEntityIsMutable();
          informedEntity_.add(index, value);
          onChanged();
        } else {
          informedEntityBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public Builder addInformedEntity(
          com.google.transit.realtime.GtfsRealtime.EntitySelector.Builder builderForValue) {
        if (informedEntityBuilder_ == null) {
          ensureInformedEntityIsMutable();
          informedEntity_.add(builderForValue.build());
          onChanged();
        } else {
          informedEntityBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public Builder addInformedEntity(
          int index, com.google.transit.realtime.GtfsRealtime.EntitySelector.Builder builderForValue) {
        if (informedEntityBuilder_ == null) {
          ensureInformedEntityIsMutable();
          informedEntity_.add(index, builderForValue.build());
          onChanged();
        } else {
          informedEntityBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public Builder addAllInformedEntity(
          java.lang.Iterable<? extends com.google.transit.realtime.GtfsRealtime.EntitySelector> values) {
        if (informedEntityBuilder_ == null) {
          ensureInformedEntityIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, informedEntity_);
          onChanged();
        } else {
          informedEntityBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public Builder clearInformedEntity() {
        if (informedEntityBuilder_ == null) {
          informedEntity_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          informedEntityBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public Builder removeInformedEntity(int index) {
        if (informedEntityBuilder_ == null) {
          ensureInformedEntityIsMutable();
          informedEntity_.remove(index);
          onChanged();
        } else {
          informedEntityBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.EntitySelector.Builder getInformedEntityBuilder(
          int index) {
        return getInformedEntityFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.EntitySelectorOrBuilder getInformedEntityOrBuilder(
          int index) {
        if (informedEntityBuilder_ == null) {
          return informedEntity_.get(index);  } else {
          return informedEntityBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.EntitySelectorOrBuilder> 
           getInformedEntityOrBuilderList() {
        if (informedEntityBuilder_ != null) {
          return informedEntityBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(informedEntity_);
        }
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.EntitySelector.Builder addInformedEntityBuilder() {
        return getInformedEntityFieldBuilder().addBuilder(
            com.google.transit.realtime.GtfsRealtime.EntitySelector.getDefaultInstance());
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.EntitySelector.Builder addInformedEntityBuilder(
          int index) {
        return getInformedEntityFieldBuilder().addBuilder(
            index, com.google.transit.realtime.GtfsRealtime.EntitySelector.getDefaultInstance());
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.EntitySelector.Builder> 
           getInformedEntityBuilderList() {
        return getInformedEntityFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.EntitySelector, com.google.transit.realtime.GtfsRealtime.EntitySelector.Builder, com.google.transit.realtime.GtfsRealtime.EntitySelectorOrBuilder> 
          getInformedEntityFieldBuilder() {
        if (informedEntityBuilder_ == null) {
          informedEntityBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.EntitySelector, com.google.transit.realtime.GtfsRealtime.EntitySelector.Builder, com.google.transit.realtime.GtfsRealtime.EntitySelectorOrBuilder>(
                  informedEntity_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          informedEntity_ = null;
        }
        return informedEntityBuilder_;
      }

      private int cause_ = 1;
      /**
       * <code>optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];</code>
       * @return Whether the cause field is set.
       */
      @java.lang.Override public boolean hasCause() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];</code>
       * @return The cause.
       */
      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.Alert.Cause getCause() {
        com.google.transit.realtime.GtfsRealtime.Alert.Cause result = com.google.transit.realtime.GtfsRealtime.Alert.Cause.forNumber(cause_);
        return result == null ? com.google.transit.realtime.GtfsRealtime.Alert.Cause.UNKNOWN_CAUSE : result;
      }
      /**
       * <code>optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];</code>
       * @param value The cause to set.
       * @return This builder for chaining.
       */
      public Builder setCause(com.google.transit.realtime.GtfsRealtime.Alert.Cause value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000004;
        cause_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];</code>
       * @return This builder for chaining.
       */
      public Builder clearCause() {
        bitField0_ = (bitField0_ & ~0x00000004);
        cause_ = 1;
        onChanged();
        return this;
      }

      private int effect_ = 8;
      /**
       * <code>optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];</code>
       * @return Whether the effect field is set.
       */
      @java.lang.Override public boolean hasEffect() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <code>optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];</code>
       * @return The effect.
       */
      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.Alert.Effect getEffect() {
        com.google.transit.realtime.GtfsRealtime.Alert.Effect result = com.google.transit.realtime.GtfsRealtime.Alert.Effect.forNumber(effect_);
        return result == null ? com.google.transit.realtime.GtfsRealtime.Alert.Effect.UNKNOWN_EFFECT : result;
      }
      /**
       * <code>optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];</code>
       * @param value The effect to set.
       * @return This builder for chaining.
       */
      public Builder setEffect(com.google.transit.realtime.GtfsRealtime.Alert.Effect value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000008;
        effect_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];</code>
       * @return This builder for chaining.
       */
      public Builder clearEffect() {
        bitField0_ = (bitField0_ & ~0x00000008);
        effect_ = 8;
        onChanged();
        return this;
      }

      private com.google.transit.realtime.GtfsRealtime.TranslatedString url_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> urlBuilder_;
      /**
       * <pre>
       * The URL which provides additional information about the alert.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString url = 8;</code>
       * @return Whether the url field is set.
       */
      public boolean hasUrl() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * The URL which provides additional information about the alert.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString url = 8;</code>
       * @return The url.
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString getUrl() {
        if (urlBuilder_ == null) {
          return url_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : url_;
        } else {
          return urlBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The URL which provides additional information about the alert.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString url = 8;</code>
       */
      public Builder setUrl(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (urlBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          url_ = value;
        } else {
          urlBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The URL which provides additional information about the alert.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString url = 8;</code>
       */
      public Builder setUrl(
          com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder builderForValue) {
        if (urlBuilder_ == null) {
          url_ = builderForValue.build();
        } else {
          urlBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The URL which provides additional information about the alert.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString url = 8;</code>
       */
      public Builder mergeUrl(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (urlBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0) &&
            url_ != null &&
            url_ != com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance()) {
            getUrlBuilder().mergeFrom(value);
          } else {
            url_ = value;
          }
        } else {
          urlBuilder_.mergeFrom(value);
        }
        if (url_ != null) {
          bitField0_ |= 0x00000010;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * The URL which provides additional information about the alert.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString url = 8;</code>
       */
      public Builder clearUrl() {
        bitField0_ = (bitField0_ & ~0x00000010);
        url_ = null;
        if (urlBuilder_ != null) {
          urlBuilder_.dispose();
          urlBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The URL which provides additional information about the alert.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString url = 8;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder getUrlBuilder() {
        bitField0_ |= 0x00000010;
        onChanged();
        return getUrlFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The URL which provides additional information about the alert.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString url = 8;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getUrlOrBuilder() {
        if (urlBuilder_ != null) {
          return urlBuilder_.getMessageOrBuilder();
        } else {
          return url_ == null ?
              com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : url_;
        }
      }
      /**
       * <pre>
       * The URL which provides additional information about the alert.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString url = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> 
          getUrlFieldBuilder() {
        if (urlBuilder_ == null) {
          urlBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder>(
                  getUrl(),
                  getParentForChildren(),
                  isClean());
          url_ = null;
        }
        return urlBuilder_;
      }

      private com.google.transit.realtime.GtfsRealtime.TranslatedString headerText_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> headerTextBuilder_;
      /**
       * <pre>
       * Alert header. Contains a short summary of the alert text as plain-text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
       * @return Whether the headerText field is set.
       */
      public boolean hasHeaderText() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Alert header. Contains a short summary of the alert text as plain-text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
       * @return The headerText.
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString getHeaderText() {
        if (headerTextBuilder_ == null) {
          return headerText_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : headerText_;
        } else {
          return headerTextBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Alert header. Contains a short summary of the alert text as plain-text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
       */
      public Builder setHeaderText(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (headerTextBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          headerText_ = value;
        } else {
          headerTextBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Alert header. Contains a short summary of the alert text as plain-text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
       */
      public Builder setHeaderText(
          com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder builderForValue) {
        if (headerTextBuilder_ == null) {
          headerText_ = builderForValue.build();
        } else {
          headerTextBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Alert header. Contains a short summary of the alert text as plain-text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
       */
      public Builder mergeHeaderText(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (headerTextBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0) &&
            headerText_ != null &&
            headerText_ != com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance()) {
            getHeaderTextBuilder().mergeFrom(value);
          } else {
            headerText_ = value;
          }
        } else {
          headerTextBuilder_.mergeFrom(value);
        }
        if (headerText_ != null) {
          bitField0_ |= 0x00000020;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Alert header. Contains a short summary of the alert text as plain-text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
       */
      public Builder clearHeaderText() {
        bitField0_ = (bitField0_ & ~0x00000020);
        headerText_ = null;
        if (headerTextBuilder_ != null) {
          headerTextBuilder_.dispose();
          headerTextBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Alert header. Contains a short summary of the alert text as plain-text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder getHeaderTextBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getHeaderTextFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Alert header. Contains a short summary of the alert text as plain-text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getHeaderTextOrBuilder() {
        if (headerTextBuilder_ != null) {
          return headerTextBuilder_.getMessageOrBuilder();
        } else {
          return headerText_ == null ?
              com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : headerText_;
        }
      }
      /**
       * <pre>
       * Alert header. Contains a short summary of the alert text as plain-text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> 
          getHeaderTextFieldBuilder() {
        if (headerTextBuilder_ == null) {
          headerTextBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder>(
                  getHeaderText(),
                  getParentForChildren(),
                  isClean());
          headerText_ = null;
        }
        return headerTextBuilder_;
      }

      private com.google.transit.realtime.GtfsRealtime.TranslatedString descriptionText_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> descriptionTextBuilder_;
      /**
       * <pre>
       * Full description for the alert as plain-text. The information in the
       * description should add to the information of the header.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
       * @return Whether the descriptionText field is set.
       */
      public boolean hasDescriptionText() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Full description for the alert as plain-text. The information in the
       * description should add to the information of the header.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
       * @return The descriptionText.
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString getDescriptionText() {
        if (descriptionTextBuilder_ == null) {
          return descriptionText_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : descriptionText_;
        } else {
          return descriptionTextBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Full description for the alert as plain-text. The information in the
       * description should add to the information of the header.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
       */
      public Builder setDescriptionText(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (descriptionTextBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          descriptionText_ = value;
        } else {
          descriptionTextBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Full description for the alert as plain-text. The information in the
       * description should add to the information of the header.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
       */
      public Builder setDescriptionText(
          com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder builderForValue) {
        if (descriptionTextBuilder_ == null) {
          descriptionText_ = builderForValue.build();
        } else {
          descriptionTextBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Full description for the alert as plain-text. The information in the
       * description should add to the information of the header.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
       */
      public Builder mergeDescriptionText(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (descriptionTextBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
            descriptionText_ != null &&
            descriptionText_ != com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance()) {
            getDescriptionTextBuilder().mergeFrom(value);
          } else {
            descriptionText_ = value;
          }
        } else {
          descriptionTextBuilder_.mergeFrom(value);
        }
        if (descriptionText_ != null) {
          bitField0_ |= 0x00000040;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Full description for the alert as plain-text. The information in the
       * description should add to the information of the header.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
       */
      public Builder clearDescriptionText() {
        bitField0_ = (bitField0_ & ~0x00000040);
        descriptionText_ = null;
        if (descriptionTextBuilder_ != null) {
          descriptionTextBuilder_.dispose();
          descriptionTextBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Full description for the alert as plain-text. The information in the
       * description should add to the information of the header.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder getDescriptionTextBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getDescriptionTextFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Full description for the alert as plain-text. The information in the
       * description should add to the information of the header.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getDescriptionTextOrBuilder() {
        if (descriptionTextBuilder_ != null) {
          return descriptionTextBuilder_.getMessageOrBuilder();
        } else {
          return descriptionText_ == null ?
              com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : descriptionText_;
        }
      }
      /**
       * <pre>
       * Full description for the alert as plain-text. The information in the
       * description should add to the information of the header.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> 
          getDescriptionTextFieldBuilder() {
        if (descriptionTextBuilder_ == null) {
          descriptionTextBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder>(
                  getDescriptionText(),
                  getParentForChildren(),
                  isClean());
          descriptionText_ = null;
        }
        return descriptionTextBuilder_;
      }

      private com.google.transit.realtime.GtfsRealtime.TranslatedString ttsHeaderText_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> ttsHeaderTextBuilder_;
      /**
       * <pre>
       * Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString tts_header_text = 12;</code>
       * @return Whether the ttsHeaderText field is set.
       */
      public boolean hasTtsHeaderText() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString tts_header_text = 12;</code>
       * @return The ttsHeaderText.
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString getTtsHeaderText() {
        if (ttsHeaderTextBuilder_ == null) {
          return ttsHeaderText_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : ttsHeaderText_;
        } else {
          return ttsHeaderTextBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString tts_header_text = 12;</code>
       */
      public Builder setTtsHeaderText(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (ttsHeaderTextBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ttsHeaderText_ = value;
        } else {
          ttsHeaderTextBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString tts_header_text = 12;</code>
       */
      public Builder setTtsHeaderText(
          com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder builderForValue) {
        if (ttsHeaderTextBuilder_ == null) {
          ttsHeaderText_ = builderForValue.build();
        } else {
          ttsHeaderTextBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString tts_header_text = 12;</code>
       */
      public Builder mergeTtsHeaderText(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (ttsHeaderTextBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0) &&
            ttsHeaderText_ != null &&
            ttsHeaderText_ != com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance()) {
            getTtsHeaderTextBuilder().mergeFrom(value);
          } else {
            ttsHeaderText_ = value;
          }
        } else {
          ttsHeaderTextBuilder_.mergeFrom(value);
        }
        if (ttsHeaderText_ != null) {
          bitField0_ |= 0x00000080;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString tts_header_text = 12;</code>
       */
      public Builder clearTtsHeaderText() {
        bitField0_ = (bitField0_ & ~0x00000080);
        ttsHeaderText_ = null;
        if (ttsHeaderTextBuilder_ != null) {
          ttsHeaderTextBuilder_.dispose();
          ttsHeaderTextBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString tts_header_text = 12;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder getTtsHeaderTextBuilder() {
        bitField0_ |= 0x00000080;
        onChanged();
        return getTtsHeaderTextFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString tts_header_text = 12;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getTtsHeaderTextOrBuilder() {
        if (ttsHeaderTextBuilder_ != null) {
          return ttsHeaderTextBuilder_.getMessageOrBuilder();
        } else {
          return ttsHeaderText_ == null ?
              com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : ttsHeaderText_;
        }
      }
      /**
       * <pre>
       * Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString tts_header_text = 12;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> 
          getTtsHeaderTextFieldBuilder() {
        if (ttsHeaderTextBuilder_ == null) {
          ttsHeaderTextBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder>(
                  getTtsHeaderText(),
                  getParentForChildren(),
                  isClean());
          ttsHeaderText_ = null;
        }
        return ttsHeaderTextBuilder_;
      }

      private com.google.transit.realtime.GtfsRealtime.TranslatedString ttsDescriptionText_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> ttsDescriptionTextBuilder_;
      /**
       * <pre>
       * Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString tts_description_text = 13;</code>
       * @return Whether the ttsDescriptionText field is set.
       */
      public boolean hasTtsDescriptionText() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString tts_description_text = 13;</code>
       * @return The ttsDescriptionText.
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString getTtsDescriptionText() {
        if (ttsDescriptionTextBuilder_ == null) {
          return ttsDescriptionText_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : ttsDescriptionText_;
        } else {
          return ttsDescriptionTextBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString tts_description_text = 13;</code>
       */
      public Builder setTtsDescriptionText(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (ttsDescriptionTextBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ttsDescriptionText_ = value;
        } else {
          ttsDescriptionTextBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString tts_description_text = 13;</code>
       */
      public Builder setTtsDescriptionText(
          com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder builderForValue) {
        if (ttsDescriptionTextBuilder_ == null) {
          ttsDescriptionText_ = builderForValue.build();
        } else {
          ttsDescriptionTextBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString tts_description_text = 13;</code>
       */
      public Builder mergeTtsDescriptionText(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (ttsDescriptionTextBuilder_ == null) {
          if (((bitField0_ & 0x00000100) != 0) &&
            ttsDescriptionText_ != null &&
            ttsDescriptionText_ != com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance()) {
            getTtsDescriptionTextBuilder().mergeFrom(value);
          } else {
            ttsDescriptionText_ = value;
          }
        } else {
          ttsDescriptionTextBuilder_.mergeFrom(value);
        }
        if (ttsDescriptionText_ != null) {
          bitField0_ |= 0x00000100;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString tts_description_text = 13;</code>
       */
      public Builder clearTtsDescriptionText() {
        bitField0_ = (bitField0_ & ~0x00000100);
        ttsDescriptionText_ = null;
        if (ttsDescriptionTextBuilder_ != null) {
          ttsDescriptionTextBuilder_.dispose();
          ttsDescriptionTextBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString tts_description_text = 13;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder getTtsDescriptionTextBuilder() {
        bitField0_ |= 0x00000100;
        onChanged();
        return getTtsDescriptionTextFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString tts_description_text = 13;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getTtsDescriptionTextOrBuilder() {
        if (ttsDescriptionTextBuilder_ != null) {
          return ttsDescriptionTextBuilder_.getMessageOrBuilder();
        } else {
          return ttsDescriptionText_ == null ?
              com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : ttsDescriptionText_;
        }
      }
      /**
       * <pre>
       * Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString tts_description_text = 13;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> 
          getTtsDescriptionTextFieldBuilder() {
        if (ttsDescriptionTextBuilder_ == null) {
          ttsDescriptionTextBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder>(
                  getTtsDescriptionText(),
                  getParentForChildren(),
                  isClean());
          ttsDescriptionText_ = null;
        }
        return ttsDescriptionTextBuilder_;
      }

      private int severityLevel_ = 1;
      /**
       * <code>optional .transit_realtime.Alert.SeverityLevel severity_level = 14 [default = UNKNOWN_SEVERITY];</code>
       * @return Whether the severityLevel field is set.
       */
      @java.lang.Override public boolean hasSeverityLevel() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <code>optional .transit_realtime.Alert.SeverityLevel severity_level = 14 [default = UNKNOWN_SEVERITY];</code>
       * @return The severityLevel.
       */
      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.Alert.SeverityLevel getSeverityLevel() {
        com.google.transit.realtime.GtfsRealtime.Alert.SeverityLevel result = com.google.transit.realtime.GtfsRealtime.Alert.SeverityLevel.forNumber(severityLevel_);
        return result == null ? com.google.transit.realtime.GtfsRealtime.Alert.SeverityLevel.UNKNOWN_SEVERITY : result;
      }
      /**
       * <code>optional .transit_realtime.Alert.SeverityLevel severity_level = 14 [default = UNKNOWN_SEVERITY];</code>
       * @param value The severityLevel to set.
       * @return This builder for chaining.
       */
      public Builder setSeverityLevel(com.google.transit.realtime.GtfsRealtime.Alert.SeverityLevel value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000200;
        severityLevel_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.Alert.SeverityLevel severity_level = 14 [default = UNKNOWN_SEVERITY];</code>
       * @return This builder for chaining.
       */
      public Builder clearSeverityLevel() {
        bitField0_ = (bitField0_ & ~0x00000200);
        severityLevel_ = 1;
        onChanged();
        return this;
      }

      private com.google.transit.realtime.GtfsRealtime.TranslatedImage image_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedImage, com.google.transit.realtime.GtfsRealtime.TranslatedImage.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedImageOrBuilder> imageBuilder_;
      /**
       * <pre>
       * TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
       * The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. 
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedImage image = 15;</code>
       * @return Whether the image field is set.
       */
      public boolean hasImage() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
       * The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. 
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedImage image = 15;</code>
       * @return The image.
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedImage getImage() {
        if (imageBuilder_ == null) {
          return image_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedImage.getDefaultInstance() : image_;
        } else {
          return imageBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
       * The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. 
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedImage image = 15;</code>
       */
      public Builder setImage(com.google.transit.realtime.GtfsRealtime.TranslatedImage value) {
        if (imageBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          image_ = value;
        } else {
          imageBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
       * The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. 
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedImage image = 15;</code>
       */
      public Builder setImage(
          com.google.transit.realtime.GtfsRealtime.TranslatedImage.Builder builderForValue) {
        if (imageBuilder_ == null) {
          image_ = builderForValue.build();
        } else {
          imageBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
       * The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. 
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedImage image = 15;</code>
       */
      public Builder mergeImage(com.google.transit.realtime.GtfsRealtime.TranslatedImage value) {
        if (imageBuilder_ == null) {
          if (((bitField0_ & 0x00000400) != 0) &&
            image_ != null &&
            image_ != com.google.transit.realtime.GtfsRealtime.TranslatedImage.getDefaultInstance()) {
            getImageBuilder().mergeFrom(value);
          } else {
            image_ = value;
          }
        } else {
          imageBuilder_.mergeFrom(value);
        }
        if (image_ != null) {
          bitField0_ |= 0x00000400;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
       * The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. 
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedImage image = 15;</code>
       */
      public Builder clearImage() {
        bitField0_ = (bitField0_ & ~0x00000400);
        image_ = null;
        if (imageBuilder_ != null) {
          imageBuilder_.dispose();
          imageBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
       * The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. 
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedImage image = 15;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedImage.Builder getImageBuilder() {
        bitField0_ |= 0x00000400;
        onChanged();
        return getImageFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
       * The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. 
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedImage image = 15;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedImageOrBuilder getImageOrBuilder() {
        if (imageBuilder_ != null) {
          return imageBuilder_.getMessageOrBuilder();
        } else {
          return image_ == null ?
              com.google.transit.realtime.GtfsRealtime.TranslatedImage.getDefaultInstance() : image_;
        }
      }
      /**
       * <pre>
       * TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
       * The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. 
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedImage image = 15;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedImage, com.google.transit.realtime.GtfsRealtime.TranslatedImage.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedImageOrBuilder> 
          getImageFieldBuilder() {
        if (imageBuilder_ == null) {
          imageBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TranslatedImage, com.google.transit.realtime.GtfsRealtime.TranslatedImage.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedImageOrBuilder>(
                  getImage(),
                  getParentForChildren(),
                  isClean());
          image_ = null;
        }
        return imageBuilder_;
      }

      private com.google.transit.realtime.GtfsRealtime.TranslatedString imageAlternativeText_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> imageAlternativeTextBuilder_;
      /**
       * <pre>
       * Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
       * or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString image_alternative_text = 16;</code>
       * @return Whether the imageAlternativeText field is set.
       */
      public boolean hasImageAlternativeText() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
       * or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString image_alternative_text = 16;</code>
       * @return The imageAlternativeText.
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString getImageAlternativeText() {
        if (imageAlternativeTextBuilder_ == null) {
          return imageAlternativeText_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : imageAlternativeText_;
        } else {
          return imageAlternativeTextBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
       * or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString image_alternative_text = 16;</code>
       */
      public Builder setImageAlternativeText(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (imageAlternativeTextBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          imageAlternativeText_ = value;
        } else {
          imageAlternativeTextBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
       * or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString image_alternative_text = 16;</code>
       */
      public Builder setImageAlternativeText(
          com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder builderForValue) {
        if (imageAlternativeTextBuilder_ == null) {
          imageAlternativeText_ = builderForValue.build();
        } else {
          imageAlternativeTextBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
       * or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString image_alternative_text = 16;</code>
       */
      public Builder mergeImageAlternativeText(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (imageAlternativeTextBuilder_ == null) {
          if (((bitField0_ & 0x00000800) != 0) &&
            imageAlternativeText_ != null &&
            imageAlternativeText_ != com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance()) {
            getImageAlternativeTextBuilder().mergeFrom(value);
          } else {
            imageAlternativeText_ = value;
          }
        } else {
          imageAlternativeTextBuilder_.mergeFrom(value);
        }
        if (imageAlternativeText_ != null) {
          bitField0_ |= 0x00000800;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
       * or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString image_alternative_text = 16;</code>
       */
      public Builder clearImageAlternativeText() {
        bitField0_ = (bitField0_ & ~0x00000800);
        imageAlternativeText_ = null;
        if (imageAlternativeTextBuilder_ != null) {
          imageAlternativeTextBuilder_.dispose();
          imageAlternativeTextBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
       * or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString image_alternative_text = 16;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder getImageAlternativeTextBuilder() {
        bitField0_ |= 0x00000800;
        onChanged();
        return getImageAlternativeTextFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
       * or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString image_alternative_text = 16;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getImageAlternativeTextOrBuilder() {
        if (imageAlternativeTextBuilder_ != null) {
          return imageAlternativeTextBuilder_.getMessageOrBuilder();
        } else {
          return imageAlternativeText_ == null ?
              com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : imageAlternativeText_;
        }
      }
      /**
       * <pre>
       * Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
       * or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString image_alternative_text = 16;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> 
          getImageAlternativeTextFieldBuilder() {
        if (imageAlternativeTextBuilder_ == null) {
          imageAlternativeTextBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder>(
                  getImageAlternativeText(),
                  getParentForChildren(),
                  isClean());
          imageAlternativeText_ = null;
        }
        return imageAlternativeTextBuilder_;
      }

      private com.google.transit.realtime.GtfsRealtime.TranslatedString causeDetail_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> causeDetailBuilder_;
      /**
       * <pre>
       * Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString cause_detail = 17;</code>
       * @return Whether the causeDetail field is set.
       */
      public boolean hasCauseDetail() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <pre>
       * Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString cause_detail = 17;</code>
       * @return The causeDetail.
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString getCauseDetail() {
        if (causeDetailBuilder_ == null) {
          return causeDetail_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : causeDetail_;
        } else {
          return causeDetailBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString cause_detail = 17;</code>
       */
      public Builder setCauseDetail(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (causeDetailBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          causeDetail_ = value;
        } else {
          causeDetailBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString cause_detail = 17;</code>
       */
      public Builder setCauseDetail(
          com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder builderForValue) {
        if (causeDetailBuilder_ == null) {
          causeDetail_ = builderForValue.build();
        } else {
          causeDetailBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString cause_detail = 17;</code>
       */
      public Builder mergeCauseDetail(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (causeDetailBuilder_ == null) {
          if (((bitField0_ & 0x00001000) != 0) &&
            causeDetail_ != null &&
            causeDetail_ != com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance()) {
            getCauseDetailBuilder().mergeFrom(value);
          } else {
            causeDetail_ = value;
          }
        } else {
          causeDetailBuilder_.mergeFrom(value);
        }
        if (causeDetail_ != null) {
          bitField0_ |= 0x00001000;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString cause_detail = 17;</code>
       */
      public Builder clearCauseDetail() {
        bitField0_ = (bitField0_ & ~0x00001000);
        causeDetail_ = null;
        if (causeDetailBuilder_ != null) {
          causeDetailBuilder_.dispose();
          causeDetailBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString cause_detail = 17;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder getCauseDetailBuilder() {
        bitField0_ |= 0x00001000;
        onChanged();
        return getCauseDetailFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString cause_detail = 17;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getCauseDetailOrBuilder() {
        if (causeDetailBuilder_ != null) {
          return causeDetailBuilder_.getMessageOrBuilder();
        } else {
          return causeDetail_ == null ?
              com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : causeDetail_;
        }
      }
      /**
       * <pre>
       * Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString cause_detail = 17;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> 
          getCauseDetailFieldBuilder() {
        if (causeDetailBuilder_ == null) {
          causeDetailBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder>(
                  getCauseDetail(),
                  getParentForChildren(),
                  isClean());
          causeDetail_ = null;
        }
        return causeDetailBuilder_;
      }

      private com.google.transit.realtime.GtfsRealtime.TranslatedString effectDetail_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> effectDetailBuilder_;
      /**
       * <pre>
       * Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString effect_detail = 18;</code>
       * @return Whether the effectDetail field is set.
       */
      public boolean hasEffectDetail() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString effect_detail = 18;</code>
       * @return The effectDetail.
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString getEffectDetail() {
        if (effectDetailBuilder_ == null) {
          return effectDetail_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : effectDetail_;
        } else {
          return effectDetailBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString effect_detail = 18;</code>
       */
      public Builder setEffectDetail(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (effectDetailBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          effectDetail_ = value;
        } else {
          effectDetailBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString effect_detail = 18;</code>
       */
      public Builder setEffectDetail(
          com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder builderForValue) {
        if (effectDetailBuilder_ == null) {
          effectDetail_ = builderForValue.build();
        } else {
          effectDetailBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString effect_detail = 18;</code>
       */
      public Builder mergeEffectDetail(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (effectDetailBuilder_ == null) {
          if (((bitField0_ & 0x00002000) != 0) &&
            effectDetail_ != null &&
            effectDetail_ != com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance()) {
            getEffectDetailBuilder().mergeFrom(value);
          } else {
            effectDetail_ = value;
          }
        } else {
          effectDetailBuilder_.mergeFrom(value);
        }
        if (effectDetail_ != null) {
          bitField0_ |= 0x00002000;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString effect_detail = 18;</code>
       */
      public Builder clearEffectDetail() {
        bitField0_ = (bitField0_ & ~0x00002000);
        effectDetail_ = null;
        if (effectDetailBuilder_ != null) {
          effectDetailBuilder_.dispose();
          effectDetailBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString effect_detail = 18;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder getEffectDetailBuilder() {
        bitField0_ |= 0x00002000;
        onChanged();
        return getEffectDetailFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString effect_detail = 18;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getEffectDetailOrBuilder() {
        if (effectDetailBuilder_ != null) {
          return effectDetailBuilder_.getMessageOrBuilder();
        } else {
          return effectDetail_ == null ?
              com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : effectDetail_;
        }
      }
      /**
       * <pre>
       * Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString effect_detail = 18;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> 
          getEffectDetailFieldBuilder() {
        if (effectDetailBuilder_ == null) {
          effectDetailBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder>(
                  getEffectDetail(),
                  getParentForChildren(),
                  isClean());
          effectDetail_ = null;
        }
        return effectDetailBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.Alert)
    }

    // @@protoc_insertion_point(class_scope:transit_realtime.Alert)
    private static final com.google.transit.realtime.GtfsRealtime.Alert DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.Alert();
    }

    public static com.google.transit.realtime.GtfsRealtime.Alert getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Alert>
        PARSER = new com.google.protobuf.AbstractParser<Alert>() {
      @java.lang.Override
      public Alert parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Alert> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Alert> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.Alert getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TimeRangeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_realtime.TimeRange)
      com.google.protobuf.GeneratedMessage.
          ExtendableMessageOrBuilder<TimeRange> {

    /**
     * <pre>
     * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval starts at minus infinity.
     * </pre>
     *
     * <code>optional uint64 start = 1;</code>
     * @return Whether the start field is set.
     */
    boolean hasStart();
    /**
     * <pre>
     * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval starts at minus infinity.
     * </pre>
     *
     * <code>optional uint64 start = 1;</code>
     * @return The start.
     */
    long getStart();

    /**
     * <pre>
     * End time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval ends at plus infinity.
     * </pre>
     *
     * <code>optional uint64 end = 2;</code>
     * @return Whether the end field is set.
     */
    boolean hasEnd();
    /**
     * <pre>
     * End time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval ends at plus infinity.
     * </pre>
     *
     * <code>optional uint64 end = 2;</code>
     * @return The end.
     */
    long getEnd();
  }
  /**
   * <pre>
   * A time interval. The interval is considered active at time 't' if 't' is
   * greater than or equal to the start time and less than the end time.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.TimeRange}
   */
  public static final class TimeRange extends
      com.google.protobuf.GeneratedMessage.ExtendableMessage<
        TimeRange> implements
      // @@protoc_insertion_point(message_implements:transit_realtime.TimeRange)
      TimeRangeOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 28,
        /* patch= */ 3,
        /* suffix= */ "",
        TimeRange.class.getName());
    }
    // Use TimeRange.newBuilder() to construct.
    private TimeRange(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.TimeRange, ?> builder) {
      super(builder);
    }
    private TimeRange() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TimeRange_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TimeRange_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.transit.realtime.GtfsRealtime.TimeRange.class, com.google.transit.realtime.GtfsRealtime.TimeRange.Builder.class);
    }

    private int bitField0_;
    public static final int START_FIELD_NUMBER = 1;
    private long start_ = 0L;
    /**
     * <pre>
     * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval starts at minus infinity.
     * </pre>
     *
     * <code>optional uint64 start = 1;</code>
     * @return Whether the start field is set.
     */
    @java.lang.Override
    public boolean hasStart() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval starts at minus infinity.
     * </pre>
     *
     * <code>optional uint64 start = 1;</code>
     * @return The start.
     */
    @java.lang.Override
    public long getStart() {
      return start_;
    }

    public static final int END_FIELD_NUMBER = 2;
    private long end_ = 0L;
    /**
     * <pre>
     * End time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval ends at plus infinity.
     * </pre>
     *
     * <code>optional uint64 end = 2;</code>
     * @return Whether the end field is set.
     */
    @java.lang.Override
    public boolean hasEnd() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * End time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval ends at plus infinity.
     * </pre>
     *
     * <code>optional uint64 end = 2;</code>
     * @return The end.
     */
    @java.lang.Override
    public long getEnd() {
      return end_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!extensionsAreInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessage
        .ExtendableMessage.ExtensionSerializer
          extensionWriter = newExtensionSerializer();
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt64(1, start_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt64(2, end_);
      }
      extensionWriter.writeUntil(10000, output);
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(1, start_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(2, end_);
      }
      size += extensionsSerializedSize();
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.TimeRange)) {
        return super.equals(obj);
      }
      com.google.transit.realtime.GtfsRealtime.TimeRange other = (com.google.transit.realtime.GtfsRealtime.TimeRange) obj;

      if (hasStart() != other.hasStart()) return false;
      if (hasStart()) {
        if (getStart()
            != other.getStart()) return false;
      }
      if (hasEnd() != other.hasEnd()) return false;
      if (hasEnd()) {
        if (getEnd()
            != other.getEnd()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      if (!getExtensionFields().equals(other.getExtensionFields()))
        return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasStart()) {
        hash = (37 * hash) + START_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getStart());
      }
      if (hasEnd()) {
        hash = (37 * hash) + END_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getEnd());
      }
      hash = hashFields(hash, getExtensionFields());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.transit.realtime.GtfsRealtime.TimeRange parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TimeRange parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TimeRange parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TimeRange parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TimeRange parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TimeRange parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TimeRange parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TimeRange parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.transit.realtime.GtfsRealtime.TimeRange parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.transit.realtime.GtfsRealtime.TimeRange parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TimeRange parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TimeRange parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.TimeRange prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * A time interval. The interval is considered active at time 't' if 't' is
     * greater than or equal to the start time and less than the end time.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.TimeRange}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
          com.google.transit.realtime.GtfsRealtime.TimeRange, Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_realtime.TimeRange)
        com.google.transit.realtime.GtfsRealtime.TimeRangeOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TimeRange_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TimeRange_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.TimeRange.class, com.google.transit.realtime.GtfsRealtime.TimeRange.Builder.class);
      }

      // Construct using com.google.transit.realtime.GtfsRealtime.TimeRange.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        start_ = 0L;
        end_ = 0L;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TimeRange_descriptor;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TimeRange getDefaultInstanceForType() {
        return com.google.transit.realtime.GtfsRealtime.TimeRange.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TimeRange build() {
        com.google.transit.realtime.GtfsRealtime.TimeRange result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TimeRange buildPartial() {
        com.google.transit.realtime.GtfsRealtime.TimeRange result = new com.google.transit.realtime.GtfsRealtime.TimeRange(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.transit.realtime.GtfsRealtime.TimeRange result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.start_ = start_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.end_ = end_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.transit.realtime.GtfsRealtime.TimeRange) {
          return mergeFrom((com.google.transit.realtime.GtfsRealtime.TimeRange)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.TimeRange other) {
        if (other == com.google.transit.realtime.GtfsRealtime.TimeRange.getDefaultInstance()) return this;
        if (other.hasStart()) {
          setStart(other.getStart());
        }
        if (other.hasEnd()) {
          setEnd(other.getEnd());
        }
        this.mergeExtensionFields(other);
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!extensionsAreInitialized()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                start_ = input.readUInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                end_ = input.readUInt64();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long start_ ;
      /**
       * <pre>
       * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
       * 00:00:00 UTC).
       * If missing, the interval starts at minus infinity.
       * </pre>
       *
       * <code>optional uint64 start = 1;</code>
       * @return Whether the start field is set.
       */
      @java.lang.Override
      public boolean hasStart() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
       * 00:00:00 UTC).
       * If missing, the interval starts at minus infinity.
       * </pre>
       *
       * <code>optional uint64 start = 1;</code>
       * @return The start.
       */
      @java.lang.Override
      public long getStart() {
        return start_;
      }
      /**
       * <pre>
       * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
       * 00:00:00 UTC).
       * If missing, the interval starts at minus infinity.
       * </pre>
       *
       * <code>optional uint64 start = 1;</code>
       * @param value The start to set.
       * @return This builder for chaining.
       */
      public Builder setStart(long value) {

        start_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
       * 00:00:00 UTC).
       * If missing, the interval starts at minus infinity.
       * </pre>
       *
       * <code>optional uint64 start = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearStart() {
        bitField0_ = (bitField0_ & ~0x00000001);
        start_ = 0L;
        onChanged();
        return this;
      }

      private long end_ ;
      /**
       * <pre>
       * End time, in POSIX time (i.e., number of seconds since January 1st 1970
       * 00:00:00 UTC).
       * If missing, the interval ends at plus infinity.
       * </pre>
       *
       * <code>optional uint64 end = 2;</code>
       * @return Whether the end field is set.
       */
      @java.lang.Override
      public boolean hasEnd() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * End time, in POSIX time (i.e., number of seconds since January 1st 1970
       * 00:00:00 UTC).
       * If missing, the interval ends at plus infinity.
       * </pre>
       *
       * <code>optional uint64 end = 2;</code>
       * @return The end.
       */
      @java.lang.Override
      public long getEnd() {
        return end_;
      }
      /**
       * <pre>
       * End time, in POSIX time (i.e., number of seconds since January 1st 1970
       * 00:00:00 UTC).
       * If missing, the interval ends at plus infinity.
       * </pre>
       *
       * <code>optional uint64 end = 2;</code>
       * @param value The end to set.
       * @return This builder for chaining.
       */
      public Builder setEnd(long value) {

        end_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * End time, in POSIX time (i.e., number of seconds since January 1st 1970
       * 00:00:00 UTC).
       * If missing, the interval ends at plus infinity.
       * </pre>
       *
       * <code>optional uint64 end = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearEnd() {
        bitField0_ = (bitField0_ & ~0x00000002);
        end_ = 0L;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.TimeRange)
    }

    // @@protoc_insertion_point(class_scope:transit_realtime.TimeRange)
    private static final com.google.transit.realtime.GtfsRealtime.TimeRange DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.TimeRange();
    }

    public static com.google.transit.realtime.GtfsRealtime.TimeRange getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TimeRange>
        PARSER = new com.google.protobuf.AbstractParser<TimeRange>() {
      @java.lang.Override
      public TimeRange parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TimeRange> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TimeRange> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TimeRange getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PositionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_realtime.Position)
      com.google.protobuf.GeneratedMessage.
          ExtendableMessageOrBuilder<Position> {

    /**
     * <pre>
     * Degrees North, in the WGS-84 coordinate system.
     * </pre>
     *
     * <code>required float latitude = 1;</code>
     * @return Whether the latitude field is set.
     */
    boolean hasLatitude();
    /**
     * <pre>
     * Degrees North, in the WGS-84 coordinate system.
     * </pre>
     *
     * <code>required float latitude = 1;</code>
     * @return The latitude.
     */
    float getLatitude();

    /**
     * <pre>
     * Degrees East, in the WGS-84 coordinate system.
     * </pre>
     *
     * <code>required float longitude = 2;</code>
     * @return Whether the longitude field is set.
     */
    boolean hasLongitude();
    /**
     * <pre>
     * Degrees East, in the WGS-84 coordinate system.
     * </pre>
     *
     * <code>required float longitude = 2;</code>
     * @return The longitude.
     */
    float getLongitude();

    /**
     * <pre>
     * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
     * This can be the compass bearing, or the direction towards the next stop
     * or intermediate location.
     * This should not be direction deduced from the sequence of previous
     * positions, which can be computed from previous data.
     * </pre>
     *
     * <code>optional float bearing = 3;</code>
     * @return Whether the bearing field is set.
     */
    boolean hasBearing();
    /**
     * <pre>
     * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
     * This can be the compass bearing, or the direction towards the next stop
     * or intermediate location.
     * This should not be direction deduced from the sequence of previous
     * positions, which can be computed from previous data.
     * </pre>
     *
     * <code>optional float bearing = 3;</code>
     * @return The bearing.
     */
    float getBearing();

    /**
     * <pre>
     * Odometer value, in meters.
     * </pre>
     *
     * <code>optional double odometer = 4;</code>
     * @return Whether the odometer field is set.
     */
    boolean hasOdometer();
    /**
     * <pre>
     * Odometer value, in meters.
     * </pre>
     *
     * <code>optional double odometer = 4;</code>
     * @return The odometer.
     */
    double getOdometer();

    /**
     * <pre>
     * Momentary speed measured by the vehicle, in meters per second.
     * </pre>
     *
     * <code>optional float speed = 5;</code>
     * @return Whether the speed field is set.
     */
    boolean hasSpeed();
    /**
     * <pre>
     * Momentary speed measured by the vehicle, in meters per second.
     * </pre>
     *
     * <code>optional float speed = 5;</code>
     * @return The speed.
     */
    float getSpeed();
  }
  /**
   * <pre>
   * A position.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.Position}
   */
  public static final class Position extends
      com.google.protobuf.GeneratedMessage.ExtendableMessage<
        Position> implements
      // @@protoc_insertion_point(message_implements:transit_realtime.Position)
      PositionOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 28,
        /* patch= */ 3,
        /* suffix= */ "",
        Position.class.getName());
    }
    // Use Position.newBuilder() to construct.
    private Position(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.Position, ?> builder) {
      super(builder);
    }
    private Position() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_Position_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_Position_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.transit.realtime.GtfsRealtime.Position.class, com.google.transit.realtime.GtfsRealtime.Position.Builder.class);
    }

    private int bitField0_;
    public static final int LATITUDE_FIELD_NUMBER = 1;
    private float latitude_ = 0F;
    /**
     * <pre>
     * Degrees North, in the WGS-84 coordinate system.
     * </pre>
     *
     * <code>required float latitude = 1;</code>
     * @return Whether the latitude field is set.
     */
    @java.lang.Override
    public boolean hasLatitude() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Degrees North, in the WGS-84 coordinate system.
     * </pre>
     *
     * <code>required float latitude = 1;</code>
     * @return The latitude.
     */
    @java.lang.Override
    public float getLatitude() {
      return latitude_;
    }

    public static final int LONGITUDE_FIELD_NUMBER = 2;
    private float longitude_ = 0F;
    /**
     * <pre>
     * Degrees East, in the WGS-84 coordinate system.
     * </pre>
     *
     * <code>required float longitude = 2;</code>
     * @return Whether the longitude field is set.
     */
    @java.lang.Override
    public boolean hasLongitude() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Degrees East, in the WGS-84 coordinate system.
     * </pre>
     *
     * <code>required float longitude = 2;</code>
     * @return The longitude.
     */
    @java.lang.Override
    public float getLongitude() {
      return longitude_;
    }

    public static final int BEARING_FIELD_NUMBER = 3;
    private float bearing_ = 0F;
    /**
     * <pre>
     * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
     * This can be the compass bearing, or the direction towards the next stop
     * or intermediate location.
     * This should not be direction deduced from the sequence of previous
     * positions, which can be computed from previous data.
     * </pre>
     *
     * <code>optional float bearing = 3;</code>
     * @return Whether the bearing field is set.
     */
    @java.lang.Override
    public boolean hasBearing() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
     * This can be the compass bearing, or the direction towards the next stop
     * or intermediate location.
     * This should not be direction deduced from the sequence of previous
     * positions, which can be computed from previous data.
     * </pre>
     *
     * <code>optional float bearing = 3;</code>
     * @return The bearing.
     */
    @java.lang.Override
    public float getBearing() {
      return bearing_;
    }

    public static final int ODOMETER_FIELD_NUMBER = 4;
    private double odometer_ = 0D;
    /**
     * <pre>
     * Odometer value, in meters.
     * </pre>
     *
     * <code>optional double odometer = 4;</code>
     * @return Whether the odometer field is set.
     */
    @java.lang.Override
    public boolean hasOdometer() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Odometer value, in meters.
     * </pre>
     *
     * <code>optional double odometer = 4;</code>
     * @return The odometer.
     */
    @java.lang.Override
    public double getOdometer() {
      return odometer_;
    }

    public static final int SPEED_FIELD_NUMBER = 5;
    private float speed_ = 0F;
    /**
     * <pre>
     * Momentary speed measured by the vehicle, in meters per second.
     * </pre>
     *
     * <code>optional float speed = 5;</code>
     * @return Whether the speed field is set.
     */
    @java.lang.Override
    public boolean hasSpeed() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Momentary speed measured by the vehicle, in meters per second.
     * </pre>
     *
     * <code>optional float speed = 5;</code>
     * @return The speed.
     */
    @java.lang.Override
    public float getSpeed() {
      return speed_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasLatitude()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!hasLongitude()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!extensionsAreInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessage
        .ExtendableMessage.ExtensionSerializer
          extensionWriter = newExtensionSerializer();
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeFloat(1, latitude_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeFloat(2, longitude_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeFloat(3, bearing_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeDouble(4, odometer_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeFloat(5, speed_);
      }
      extensionWriter.writeUntil(10000, output);
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(1, latitude_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(2, longitude_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(3, bearing_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(4, odometer_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(5, speed_);
      }
      size += extensionsSerializedSize();
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.Position)) {
        return super.equals(obj);
      }
      com.google.transit.realtime.GtfsRealtime.Position other = (com.google.transit.realtime.GtfsRealtime.Position) obj;

      if (hasLatitude() != other.hasLatitude()) return false;
      if (hasLatitude()) {
        if (java.lang.Float.floatToIntBits(getLatitude())
            != java.lang.Float.floatToIntBits(
                other.getLatitude())) return false;
      }
      if (hasLongitude() != other.hasLongitude()) return false;
      if (hasLongitude()) {
        if (java.lang.Float.floatToIntBits(getLongitude())
            != java.lang.Float.floatToIntBits(
                other.getLongitude())) return false;
      }
      if (hasBearing() != other.hasBearing()) return false;
      if (hasBearing()) {
        if (java.lang.Float.floatToIntBits(getBearing())
            != java.lang.Float.floatToIntBits(
                other.getBearing())) return false;
      }
      if (hasOdometer() != other.hasOdometer()) return false;
      if (hasOdometer()) {
        if (java.lang.Double.doubleToLongBits(getOdometer())
            != java.lang.Double.doubleToLongBits(
                other.getOdometer())) return false;
      }
      if (hasSpeed() != other.hasSpeed()) return false;
      if (hasSpeed()) {
        if (java.lang.Float.floatToIntBits(getSpeed())
            != java.lang.Float.floatToIntBits(
                other.getSpeed())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      if (!getExtensionFields().equals(other.getExtensionFields()))
        return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasLatitude()) {
        hash = (37 * hash) + LATITUDE_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getLatitude());
      }
      if (hasLongitude()) {
        hash = (37 * hash) + LONGITUDE_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getLongitude());
      }
      if (hasBearing()) {
        hash = (37 * hash) + BEARING_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getBearing());
      }
      if (hasOdometer()) {
        hash = (37 * hash) + ODOMETER_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            java.lang.Double.doubleToLongBits(getOdometer()));
      }
      if (hasSpeed()) {
        hash = (37 * hash) + SPEED_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getSpeed());
      }
      hash = hashFields(hash, getExtensionFields());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.transit.realtime.GtfsRealtime.Position parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.Position parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Position parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.Position parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Position parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.Position parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Position parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.Position parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.transit.realtime.GtfsRealtime.Position parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.transit.realtime.GtfsRealtime.Position parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Position parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.Position parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.Position prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * A position.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.Position}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
          com.google.transit.realtime.GtfsRealtime.Position, Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_realtime.Position)
        com.google.transit.realtime.GtfsRealtime.PositionOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_Position_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_Position_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.Position.class, com.google.transit.realtime.GtfsRealtime.Position.Builder.class);
      }

      // Construct using com.google.transit.realtime.GtfsRealtime.Position.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        latitude_ = 0F;
        longitude_ = 0F;
        bearing_ = 0F;
        odometer_ = 0D;
        speed_ = 0F;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_Position_descriptor;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.Position getDefaultInstanceForType() {
        return com.google.transit.realtime.GtfsRealtime.Position.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.Position build() {
        com.google.transit.realtime.GtfsRealtime.Position result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.Position buildPartial() {
        com.google.transit.realtime.GtfsRealtime.Position result = new com.google.transit.realtime.GtfsRealtime.Position(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.transit.realtime.GtfsRealtime.Position result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.latitude_ = latitude_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.longitude_ = longitude_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.bearing_ = bearing_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.odometer_ = odometer_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.speed_ = speed_;
          to_bitField0_ |= 0x00000010;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.transit.realtime.GtfsRealtime.Position) {
          return mergeFrom((com.google.transit.realtime.GtfsRealtime.Position)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.Position other) {
        if (other == com.google.transit.realtime.GtfsRealtime.Position.getDefaultInstance()) return this;
        if (other.hasLatitude()) {
          setLatitude(other.getLatitude());
        }
        if (other.hasLongitude()) {
          setLongitude(other.getLongitude());
        }
        if (other.hasBearing()) {
          setBearing(other.getBearing());
        }
        if (other.hasOdometer()) {
          setOdometer(other.getOdometer());
        }
        if (other.hasSpeed()) {
          setSpeed(other.getSpeed());
        }
        this.mergeExtensionFields(other);
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasLatitude()) {
          return false;
        }
        if (!hasLongitude()) {
          return false;
        }
        if (!extensionsAreInitialized()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 13: {
                latitude_ = input.readFloat();
                bitField0_ |= 0x00000001;
                break;
              } // case 13
              case 21: {
                longitude_ = input.readFloat();
                bitField0_ |= 0x00000002;
                break;
              } // case 21
              case 29: {
                bearing_ = input.readFloat();
                bitField0_ |= 0x00000004;
                break;
              } // case 29
              case 33: {
                odometer_ = input.readDouble();
                bitField0_ |= 0x00000008;
                break;
              } // case 33
              case 45: {
                speed_ = input.readFloat();
                bitField0_ |= 0x00000010;
                break;
              } // case 45
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private float latitude_ ;
      /**
       * <pre>
       * Degrees North, in the WGS-84 coordinate system.
       * </pre>
       *
       * <code>required float latitude = 1;</code>
       * @return Whether the latitude field is set.
       */
      @java.lang.Override
      public boolean hasLatitude() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Degrees North, in the WGS-84 coordinate system.
       * </pre>
       *
       * <code>required float latitude = 1;</code>
       * @return The latitude.
       */
      @java.lang.Override
      public float getLatitude() {
        return latitude_;
      }
      /**
       * <pre>
       * Degrees North, in the WGS-84 coordinate system.
       * </pre>
       *
       * <code>required float latitude = 1;</code>
       * @param value The latitude to set.
       * @return This builder for chaining.
       */
      public Builder setLatitude(float value) {

        latitude_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Degrees North, in the WGS-84 coordinate system.
       * </pre>
       *
       * <code>required float latitude = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearLatitude() {
        bitField0_ = (bitField0_ & ~0x00000001);
        latitude_ = 0F;
        onChanged();
        return this;
      }

      private float longitude_ ;
      /**
       * <pre>
       * Degrees East, in the WGS-84 coordinate system.
       * </pre>
       *
       * <code>required float longitude = 2;</code>
       * @return Whether the longitude field is set.
       */
      @java.lang.Override
      public boolean hasLongitude() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Degrees East, in the WGS-84 coordinate system.
       * </pre>
       *
       * <code>required float longitude = 2;</code>
       * @return The longitude.
       */
      @java.lang.Override
      public float getLongitude() {
        return longitude_;
      }
      /**
       * <pre>
       * Degrees East, in the WGS-84 coordinate system.
       * </pre>
       *
       * <code>required float longitude = 2;</code>
       * @param value The longitude to set.
       * @return This builder for chaining.
       */
      public Builder setLongitude(float value) {

        longitude_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Degrees East, in the WGS-84 coordinate system.
       * </pre>
       *
       * <code>required float longitude = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearLongitude() {
        bitField0_ = (bitField0_ & ~0x00000002);
        longitude_ = 0F;
        onChanged();
        return this;
      }

      private float bearing_ ;
      /**
       * <pre>
       * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
       * This can be the compass bearing, or the direction towards the next stop
       * or intermediate location.
       * This should not be direction deduced from the sequence of previous
       * positions, which can be computed from previous data.
       * </pre>
       *
       * <code>optional float bearing = 3;</code>
       * @return Whether the bearing field is set.
       */
      @java.lang.Override
      public boolean hasBearing() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
       * This can be the compass bearing, or the direction towards the next stop
       * or intermediate location.
       * This should not be direction deduced from the sequence of previous
       * positions, which can be computed from previous data.
       * </pre>
       *
       * <code>optional float bearing = 3;</code>
       * @return The bearing.
       */
      @java.lang.Override
      public float getBearing() {
        return bearing_;
      }
      /**
       * <pre>
       * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
       * This can be the compass bearing, or the direction towards the next stop
       * or intermediate location.
       * This should not be direction deduced from the sequence of previous
       * positions, which can be computed from previous data.
       * </pre>
       *
       * <code>optional float bearing = 3;</code>
       * @param value The bearing to set.
       * @return This builder for chaining.
       */
      public Builder setBearing(float value) {

        bearing_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
       * This can be the compass bearing, or the direction towards the next stop
       * or intermediate location.
       * This should not be direction deduced from the sequence of previous
       * positions, which can be computed from previous data.
       * </pre>
       *
       * <code>optional float bearing = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearBearing() {
        bitField0_ = (bitField0_ & ~0x00000004);
        bearing_ = 0F;
        onChanged();
        return this;
      }

      private double odometer_ ;
      /**
       * <pre>
       * Odometer value, in meters.
       * </pre>
       *
       * <code>optional double odometer = 4;</code>
       * @return Whether the odometer field is set.
       */
      @java.lang.Override
      public boolean hasOdometer() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Odometer value, in meters.
       * </pre>
       *
       * <code>optional double odometer = 4;</code>
       * @return The odometer.
       */
      @java.lang.Override
      public double getOdometer() {
        return odometer_;
      }
      /**
       * <pre>
       * Odometer value, in meters.
       * </pre>
       *
       * <code>optional double odometer = 4;</code>
       * @param value The odometer to set.
       * @return This builder for chaining.
       */
      public Builder setOdometer(double value) {

        odometer_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Odometer value, in meters.
       * </pre>
       *
       * <code>optional double odometer = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearOdometer() {
        bitField0_ = (bitField0_ & ~0x00000008);
        odometer_ = 0D;
        onChanged();
        return this;
      }

      private float speed_ ;
      /**
       * <pre>
       * Momentary speed measured by the vehicle, in meters per second.
       * </pre>
       *
       * <code>optional float speed = 5;</code>
       * @return Whether the speed field is set.
       */
      @java.lang.Override
      public boolean hasSpeed() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Momentary speed measured by the vehicle, in meters per second.
       * </pre>
       *
       * <code>optional float speed = 5;</code>
       * @return The speed.
       */
      @java.lang.Override
      public float getSpeed() {
        return speed_;
      }
      /**
       * <pre>
       * Momentary speed measured by the vehicle, in meters per second.
       * </pre>
       *
       * <code>optional float speed = 5;</code>
       * @param value The speed to set.
       * @return This builder for chaining.
       */
      public Builder setSpeed(float value) {

        speed_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Momentary speed measured by the vehicle, in meters per second.
       * </pre>
       *
       * <code>optional float speed = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearSpeed() {
        bitField0_ = (bitField0_ & ~0x00000010);
        speed_ = 0F;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.Position)
    }

    // @@protoc_insertion_point(class_scope:transit_realtime.Position)
    private static final com.google.transit.realtime.GtfsRealtime.Position DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.Position();
    }

    public static com.google.transit.realtime.GtfsRealtime.Position getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Position>
        PARSER = new com.google.protobuf.AbstractParser<Position>() {
      @java.lang.Override
      public Position parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Position> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Position> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.Position getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TripDescriptorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_realtime.TripDescriptor)
      com.google.protobuf.GeneratedMessage.
          ExtendableMessageOrBuilder<TripDescriptor> {

    /**
     * <pre>
     * The trip_id from the GTFS feed that this selector refers to.
     * For non frequency-based trips, this field is enough to uniquely identify
     * the trip. For frequency-based trip, start_time and start_date might also be
     * necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from
     * static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id
     * identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id.
     * </pre>
     *
     * <code>optional string trip_id = 1;</code>
     * @return Whether the tripId field is set.
     */
    boolean hasTripId();
    /**
     * <pre>
     * The trip_id from the GTFS feed that this selector refers to.
     * For non frequency-based trips, this field is enough to uniquely identify
     * the trip. For frequency-based trip, start_time and start_date might also be
     * necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from
     * static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id
     * identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id.
     * </pre>
     *
     * <code>optional string trip_id = 1;</code>
     * @return The tripId.
     */
    java.lang.String getTripId();
    /**
     * <pre>
     * The trip_id from the GTFS feed that this selector refers to.
     * For non frequency-based trips, this field is enough to uniquely identify
     * the trip. For frequency-based trip, start_time and start_date might also be
     * necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from
     * static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id
     * identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id.
     * </pre>
     *
     * <code>optional string trip_id = 1;</code>
     * @return The bytes for tripId.
     */
    com.google.protobuf.ByteString
        getTripIdBytes();

    /**
     * <pre>
     * The route_id from the GTFS that this selector refers to.
     * </pre>
     *
     * <code>optional string route_id = 5;</code>
     * @return Whether the routeId field is set.
     */
    boolean hasRouteId();
    /**
     * <pre>
     * The route_id from the GTFS that this selector refers to.
     * </pre>
     *
     * <code>optional string route_id = 5;</code>
     * @return The routeId.
     */
    java.lang.String getRouteId();
    /**
     * <pre>
     * The route_id from the GTFS that this selector refers to.
     * </pre>
     *
     * <code>optional string route_id = 5;</code>
     * @return The bytes for routeId.
     */
    com.google.protobuf.ByteString
        getRouteIdBytes();

    /**
     * <pre>
     * The direction_id from the GTFS feed trips.txt file, indicating the
     * direction of travel for trips this selector refers to.
     * </pre>
     *
     * <code>optional uint32 direction_id = 6;</code>
     * @return Whether the directionId field is set.
     */
    boolean hasDirectionId();
    /**
     * <pre>
     * The direction_id from the GTFS feed trips.txt file, indicating the
     * direction of travel for trips this selector refers to.
     * </pre>
     *
     * <code>optional uint32 direction_id = 6;</code>
     * @return The directionId.
     */
    int getDirectionId();

    /**
     * <pre>
     * The initially scheduled start time of this trip instance.
     * When the trip_id corresponds to a non-frequency-based trip, this field
     * should either be omitted or be equal to the value in the GTFS feed. When
     * the trip_id correponds to a frequency-based trip, the start_time must be
     * specified for trip updates and vehicle positions. If the trip corresponds
     * to exact_times=1 GTFS record, then start_time must be some multiple
     * (including zero) of headway_secs later than frequencies.txt start_time for
     * the corresponding time period. If the trip corresponds to exact_times=0,
     * then its start_time may be arbitrary, and is initially expected to be the
     * first departure of the trip. Once established, the start_time of this
     * frequency-based trip should be considered immutable, even if the first
     * departure time changes -- that time change may instead be reflected in a
     * StopTimeUpdate.
     * Format and semantics of the field is same as that of
     * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
     * </pre>
     *
     * <code>optional string start_time = 2;</code>
     * @return Whether the startTime field is set.
     */
    boolean hasStartTime();
    /**
     * <pre>
     * The initially scheduled start time of this trip instance.
     * When the trip_id corresponds to a non-frequency-based trip, this field
     * should either be omitted or be equal to the value in the GTFS feed. When
     * the trip_id correponds to a frequency-based trip, the start_time must be
     * specified for trip updates and vehicle positions. If the trip corresponds
     * to exact_times=1 GTFS record, then start_time must be some multiple
     * (including zero) of headway_secs later than frequencies.txt start_time for
     * the corresponding time period. If the trip corresponds to exact_times=0,
     * then its start_time may be arbitrary, and is initially expected to be the
     * first departure of the trip. Once established, the start_time of this
     * frequency-based trip should be considered immutable, even if the first
     * departure time changes -- that time change may instead be reflected in a
     * StopTimeUpdate.
     * Format and semantics of the field is same as that of
     * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
     * </pre>
     *
     * <code>optional string start_time = 2;</code>
     * @return The startTime.
     */
    java.lang.String getStartTime();
    /**
     * <pre>
     * The initially scheduled start time of this trip instance.
     * When the trip_id corresponds to a non-frequency-based trip, this field
     * should either be omitted or be equal to the value in the GTFS feed. When
     * the trip_id correponds to a frequency-based trip, the start_time must be
     * specified for trip updates and vehicle positions. If the trip corresponds
     * to exact_times=1 GTFS record, then start_time must be some multiple
     * (including zero) of headway_secs later than frequencies.txt start_time for
     * the corresponding time period. If the trip corresponds to exact_times=0,
     * then its start_time may be arbitrary, and is initially expected to be the
     * first departure of the trip. Once established, the start_time of this
     * frequency-based trip should be considered immutable, even if the first
     * departure time changes -- that time change may instead be reflected in a
     * StopTimeUpdate.
     * Format and semantics of the field is same as that of
     * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
     * </pre>
     *
     * <code>optional string start_time = 2;</code>
     * @return The bytes for startTime.
     */
    com.google.protobuf.ByteString
        getStartTimeBytes();

    /**
     * <pre>
     * The scheduled start date of this trip instance.
     * Must be provided to disambiguate trips that are so late as to collide with
     * a scheduled trip on a next day. For example, for a train that departs 8:00
     * and 20:00 every day, and is 12 hours late, there would be two distinct
     * trips on the same time.
     * This field can be provided but is not mandatory for schedules in which such
     * collisions are impossible - for example, a service running on hourly
     * schedule where a vehicle that is one hour late is not considered to be
     * related to schedule anymore.
     * In YYYYMMDD format.
     * </pre>
     *
     * <code>optional string start_date = 3;</code>
     * @return Whether the startDate field is set.
     */
    boolean hasStartDate();
    /**
     * <pre>
     * The scheduled start date of this trip instance.
     * Must be provided to disambiguate trips that are so late as to collide with
     * a scheduled trip on a next day. For example, for a train that departs 8:00
     * and 20:00 every day, and is 12 hours late, there would be two distinct
     * trips on the same time.
     * This field can be provided but is not mandatory for schedules in which such
     * collisions are impossible - for example, a service running on hourly
     * schedule where a vehicle that is one hour late is not considered to be
     * related to schedule anymore.
     * In YYYYMMDD format.
     * </pre>
     *
     * <code>optional string start_date = 3;</code>
     * @return The startDate.
     */
    java.lang.String getStartDate();
    /**
     * <pre>
     * The scheduled start date of this trip instance.
     * Must be provided to disambiguate trips that are so late as to collide with
     * a scheduled trip on a next day. For example, for a train that departs 8:00
     * and 20:00 every day, and is 12 hours late, there would be two distinct
     * trips on the same time.
     * This field can be provided but is not mandatory for schedules in which such
     * collisions are impossible - for example, a service running on hourly
     * schedule where a vehicle that is one hour late is not considered to be
     * related to schedule anymore.
     * In YYYYMMDD format.
     * </pre>
     *
     * <code>optional string start_date = 3;</code>
     * @return The bytes for startDate.
     */
    com.google.protobuf.ByteString
        getStartDateBytes();

    /**
     * <code>optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;</code>
     * @return Whether the scheduleRelationship field is set.
     */
    boolean hasScheduleRelationship();
    /**
     * <code>optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;</code>
     * @return The scheduleRelationship.
     */
    com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship getScheduleRelationship();

    /**
     * <pre>
     * Linkage to any modifications done to this trip (shape changes, removal or addition of stops). 
     * If this field is provided, the `trip_id`, `route_id`, `direction_id`, `start_time`, `start_date` fields of the `TripDescriptor` MUST be left empty, to avoid confusion by consumers that aren't looking for the `ModifiedTripSelector` value. 
     * </pre>
     *
     * <code>optional .transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7;</code>
     * @return Whether the modifiedTrip field is set.
     */
    boolean hasModifiedTrip();
    /**
     * <pre>
     * Linkage to any modifications done to this trip (shape changes, removal or addition of stops). 
     * If this field is provided, the `trip_id`, `route_id`, `direction_id`, `start_time`, `start_date` fields of the `TripDescriptor` MUST be left empty, to avoid confusion by consumers that aren't looking for the `ModifiedTripSelector` value. 
     * </pre>
     *
     * <code>optional .transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7;</code>
     * @return The modifiedTrip.
     */
    com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector getModifiedTrip();
    /**
     * <pre>
     * Linkage to any modifications done to this trip (shape changes, removal or addition of stops). 
     * If this field is provided, the `trip_id`, `route_id`, `direction_id`, `start_time`, `start_date` fields of the `TripDescriptor` MUST be left empty, to avoid confusion by consumers that aren't looking for the `ModifiedTripSelector` value. 
     * </pre>
     *
     * <code>optional .transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelectorOrBuilder getModifiedTripOrBuilder();
  }
  /**
   * <pre>
   * A descriptor that identifies an instance of a GTFS trip, or all instances of
   * a trip along a route.
   * - To specify a single trip instance, the trip_id (and if necessary,
   * start_time) is set. If route_id is also set, then it should be same as one
   * that the given trip corresponds to.
   * - To specify all the trips along a given route, only the route_id should be
   * set. Note that if the trip_id is not known, then stop sequence ids in
   * TripUpdate are not sufficient, and stop_ids must be provided as well. In
   * addition, absolute arrival/departure times must be provided.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.TripDescriptor}
   */
  public static final class TripDescriptor extends
      com.google.protobuf.GeneratedMessage.ExtendableMessage<
        TripDescriptor> implements
      // @@protoc_insertion_point(message_implements:transit_realtime.TripDescriptor)
      TripDescriptorOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 28,
        /* patch= */ 3,
        /* suffix= */ "",
        TripDescriptor.class.getName());
    }
    // Use TripDescriptor.newBuilder() to construct.
    private TripDescriptor(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.TripDescriptor, ?> builder) {
      super(builder);
    }
    private TripDescriptor() {
      tripId_ = "";
      routeId_ = "";
      startTime_ = "";
      startDate_ = "";
      scheduleRelationship_ = 0;
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripDescriptor_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripDescriptor_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.transit.realtime.GtfsRealtime.TripDescriptor.class, com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder.class);
    }

    /**
     * <pre>
     * The relation between this trip and the static schedule. If a trip is done
     * in accordance with temporary schedule, not reflected in GTFS, then it
     * shouldn't be marked as SCHEDULED, but likely as ADDED.
     * </pre>
     *
     * Protobuf enum {@code transit_realtime.TripDescriptor.ScheduleRelationship}
     */
    public enum ScheduleRelationship
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * Trip that is running in accordance with its GTFS schedule, or is close
       * enough to the scheduled trip to be associated with it.
       * </pre>
       *
       * <code>SCHEDULED = 0;</code>
       */
      SCHEDULED(0),
      /**
       * <pre>
       * An extra trip that was added in addition to a running schedule, for
       * example, to replace a broken vehicle or to respond to sudden passenger
       * load.
       * NOTE: Currently, behavior is unspecified for feeds that use this mode. There are discussions on the GTFS GitHub
       * [(1)](https://github.com/google/transit/issues/106) [(2)](https://github.com/google/transit/pull/221)
       * [(3)](https://github.com/google/transit/pull/219) around fully specifying or deprecating ADDED trips and the
       * documentation will be updated when those discussions are finalized.
       * </pre>
       *
       * <code>ADDED = 1;</code>
       */
      ADDED(1),
      /**
       * <pre>
       * A trip that is running with no schedule associated to it (GTFS frequencies.txt exact_times=0).
       * Trips with ScheduleRelationship=UNSCHEDULED must also set all StopTimeUpdates.ScheduleRelationship=UNSCHEDULED.
       * </pre>
       *
       * <code>UNSCHEDULED = 2;</code>
       */
      UNSCHEDULED(2),
      /**
       * <pre>
       * A trip that existed in the schedule but was removed.
       * </pre>
       *
       * <code>CANCELED = 3;</code>
       */
      CANCELED(3),
      /**
       * <pre>
       * Should not be used - for backwards-compatibility only.
       * </pre>
       *
       * <code>REPLACEMENT = 5 [deprecated = true];</code>
       */
      @java.lang.Deprecated
      REPLACEMENT(5),
      /**
       * <pre>
       * An extra trip that was added in addition to a running schedule, for example, to replace a broken vehicle or to
       * respond to sudden passenger load. Used with TripUpdate.TripProperties.trip_id, TripUpdate.TripProperties.start_date,
       * and TripUpdate.TripProperties.start_time to copy an existing trip from static GTFS but start at a different service
       * date and/or time. Duplicating a trip is allowed if the service related to the original trip in (CSV) GTFS
       * (in calendar.txt or calendar_dates.txt) is operating within the next 30 days. The trip to be duplicated is
       * identified via TripUpdate.TripDescriptor.trip_id. This enumeration does not modify the existing trip referenced by
       * TripUpdate.TripDescriptor.trip_id - if a producer wants to cancel the original trip, it must publish a separate
       * TripUpdate with the value of CANCELED or DELETED. Trips defined in GTFS frequencies.txt with exact_times that is
       * empty or equal to 0 cannot be duplicated. The VehiclePosition.TripDescriptor.trip_id for the new trip must contain
       * the matching value from TripUpdate.TripProperties.trip_id and VehiclePosition.TripDescriptor.ScheduleRelationship
       * must also be set to DUPLICATED.
       * Existing producers and consumers that were using the ADDED enumeration to represent duplicated trips must follow
       * the migration guide (https://github.com/google/transit/tree/master/gtfs-realtime/spec/en/examples/migration-duplicated.md)
       * to transition to the DUPLICATED enumeration.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>DUPLICATED = 6;</code>
       */
      DUPLICATED(6),
      /**
       * <pre>
       * A trip that existed in the schedule but was removed and must not be shown to users.
       * DELETED should be used instead of CANCELED to indicate that a transit provider would like to entirely remove
       * information about the corresponding trip from consuming applications, so the trip is not shown as cancelled to
       * riders, e.g. a trip that is entirely being replaced by another trip.
       * This designation becomes particularly important if several trips are cancelled and replaced with substitute service.
       * If consumers were to show explicit information about the cancellations it would distract from the more important
       * real-time predictions.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>DELETED = 7;</code>
       */
      DELETED(7),
      ;

      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 28,
          /* patch= */ 3,
          /* suffix= */ "",
          ScheduleRelationship.class.getName());
      }
      /**
       * <pre>
       * Trip that is running in accordance with its GTFS schedule, or is close
       * enough to the scheduled trip to be associated with it.
       * </pre>
       *
       * <code>SCHEDULED = 0;</code>
       */
      public static final int SCHEDULED_VALUE = 0;
      /**
       * <pre>
       * An extra trip that was added in addition to a running schedule, for
       * example, to replace a broken vehicle or to respond to sudden passenger
       * load.
       * NOTE: Currently, behavior is unspecified for feeds that use this mode. There are discussions on the GTFS GitHub
       * [(1)](https://github.com/google/transit/issues/106) [(2)](https://github.com/google/transit/pull/221)
       * [(3)](https://github.com/google/transit/pull/219) around fully specifying or deprecating ADDED trips and the
       * documentation will be updated when those discussions are finalized.
       * </pre>
       *
       * <code>ADDED = 1;</code>
       */
      public static final int ADDED_VALUE = 1;
      /**
       * <pre>
       * A trip that is running with no schedule associated to it (GTFS frequencies.txt exact_times=0).
       * Trips with ScheduleRelationship=UNSCHEDULED must also set all StopTimeUpdates.ScheduleRelationship=UNSCHEDULED.
       * </pre>
       *
       * <code>UNSCHEDULED = 2;</code>
       */
      public static final int UNSCHEDULED_VALUE = 2;
      /**
       * <pre>
       * A trip that existed in the schedule but was removed.
       * </pre>
       *
       * <code>CANCELED = 3;</code>
       */
      public static final int CANCELED_VALUE = 3;
      /**
       * <pre>
       * Should not be used - for backwards-compatibility only.
       * </pre>
       *
       * <code>REPLACEMENT = 5 [deprecated = true];</code>
       */
      @java.lang.Deprecated public static final int REPLACEMENT_VALUE = 5;
      /**
       * <pre>
       * An extra trip that was added in addition to a running schedule, for example, to replace a broken vehicle or to
       * respond to sudden passenger load. Used with TripUpdate.TripProperties.trip_id, TripUpdate.TripProperties.start_date,
       * and TripUpdate.TripProperties.start_time to copy an existing trip from static GTFS but start at a different service
       * date and/or time. Duplicating a trip is allowed if the service related to the original trip in (CSV) GTFS
       * (in calendar.txt or calendar_dates.txt) is operating within the next 30 days. The trip to be duplicated is
       * identified via TripUpdate.TripDescriptor.trip_id. This enumeration does not modify the existing trip referenced by
       * TripUpdate.TripDescriptor.trip_id - if a producer wants to cancel the original trip, it must publish a separate
       * TripUpdate with the value of CANCELED or DELETED. Trips defined in GTFS frequencies.txt with exact_times that is
       * empty or equal to 0 cannot be duplicated. The VehiclePosition.TripDescriptor.trip_id for the new trip must contain
       * the matching value from TripUpdate.TripProperties.trip_id and VehiclePosition.TripDescriptor.ScheduleRelationship
       * must also be set to DUPLICATED.
       * Existing producers and consumers that were using the ADDED enumeration to represent duplicated trips must follow
       * the migration guide (https://github.com/google/transit/tree/master/gtfs-realtime/spec/en/examples/migration-duplicated.md)
       * to transition to the DUPLICATED enumeration.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>DUPLICATED = 6;</code>
       */
      public static final int DUPLICATED_VALUE = 6;
      /**
       * <pre>
       * A trip that existed in the schedule but was removed and must not be shown to users.
       * DELETED should be used instead of CANCELED to indicate that a transit provider would like to entirely remove
       * information about the corresponding trip from consuming applications, so the trip is not shown as cancelled to
       * riders, e.g. a trip that is entirely being replaced by another trip.
       * This designation becomes particularly important if several trips are cancelled and replaced with substitute service.
       * If consumers were to show explicit information about the cancellations it would distract from the more important
       * real-time predictions.
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>DELETED = 7;</code>
       */
      public static final int DELETED_VALUE = 7;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ScheduleRelationship valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static ScheduleRelationship forNumber(int value) {
        switch (value) {
          case 0: return SCHEDULED;
          case 1: return ADDED;
          case 2: return UNSCHEDULED;
          case 3: return CANCELED;
          case 5: return REPLACEMENT;
          case 6: return DUPLICATED;
          case 7: return DELETED;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ScheduleRelationship>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ScheduleRelationship> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ScheduleRelationship>() {
              public ScheduleRelationship findValueByNumber(int number) {
                return ScheduleRelationship.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDescriptor().getEnumTypes().get(0);
      }

      private static final ScheduleRelationship[] VALUES = values();

      public static ScheduleRelationship valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private ScheduleRelationship(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_realtime.TripDescriptor.ScheduleRelationship)
    }

    public interface ModifiedTripSelectorOrBuilder extends
        // @@protoc_insertion_point(interface_extends:transit_realtime.TripDescriptor.ModifiedTripSelector)
        com.google.protobuf.GeneratedMessage.
            ExtendableMessageOrBuilder<ModifiedTripSelector> {

      /**
       * <pre>
       * The 'id' from the FeedEntity in which the contained TripModifications object affects this trip.
       * </pre>
       *
       * <code>optional string modifications_id = 1;</code>
       * @return Whether the modificationsId field is set.
       */
      boolean hasModificationsId();
      /**
       * <pre>
       * The 'id' from the FeedEntity in which the contained TripModifications object affects this trip.
       * </pre>
       *
       * <code>optional string modifications_id = 1;</code>
       * @return The modificationsId.
       */
      java.lang.String getModificationsId();
      /**
       * <pre>
       * The 'id' from the FeedEntity in which the contained TripModifications object affects this trip.
       * </pre>
       *
       * <code>optional string modifications_id = 1;</code>
       * @return The bytes for modificationsId.
       */
      com.google.protobuf.ByteString
          getModificationsIdBytes();

      /**
       * <pre>
       * The trip_id from the GTFS feed that is modified by the modifications_id
       * </pre>
       *
       * <code>optional string affected_trip_id = 2;</code>
       * @return Whether the affectedTripId field is set.
       */
      boolean hasAffectedTripId();
      /**
       * <pre>
       * The trip_id from the GTFS feed that is modified by the modifications_id
       * </pre>
       *
       * <code>optional string affected_trip_id = 2;</code>
       * @return The affectedTripId.
       */
      java.lang.String getAffectedTripId();
      /**
       * <pre>
       * The trip_id from the GTFS feed that is modified by the modifications_id
       * </pre>
       *
       * <code>optional string affected_trip_id = 2;</code>
       * @return The bytes for affectedTripId.
       */
      com.google.protobuf.ByteString
          getAffectedTripIdBytes();

      /**
       * <pre>
       * The initially scheduled start time of this trip instance, applied to the frequency based modified trip. Same definition as start_time in TripDescriptor.
       * </pre>
       *
       * <code>optional string start_time = 3;</code>
       * @return Whether the startTime field is set.
       */
      boolean hasStartTime();
      /**
       * <pre>
       * The initially scheduled start time of this trip instance, applied to the frequency based modified trip. Same definition as start_time in TripDescriptor.
       * </pre>
       *
       * <code>optional string start_time = 3;</code>
       * @return The startTime.
       */
      java.lang.String getStartTime();
      /**
       * <pre>
       * The initially scheduled start time of this trip instance, applied to the frequency based modified trip. Same definition as start_time in TripDescriptor.
       * </pre>
       *
       * <code>optional string start_time = 3;</code>
       * @return The bytes for startTime.
       */
      com.google.protobuf.ByteString
          getStartTimeBytes();

      /**
       * <pre>
       * The start date of this trip instance in YYYYMMDD format, applied to the modified trip. Same definition as start_date in TripDescriptor.
       * </pre>
       *
       * <code>optional string start_date = 4;</code>
       * @return Whether the startDate field is set.
       */
      boolean hasStartDate();
      /**
       * <pre>
       * The start date of this trip instance in YYYYMMDD format, applied to the modified trip. Same definition as start_date in TripDescriptor.
       * </pre>
       *
       * <code>optional string start_date = 4;</code>
       * @return The startDate.
       */
      java.lang.String getStartDate();
      /**
       * <pre>
       * The start date of this trip instance in YYYYMMDD format, applied to the modified trip. Same definition as start_date in TripDescriptor.
       * </pre>
       *
       * <code>optional string start_date = 4;</code>
       * @return The bytes for startDate.
       */
      com.google.protobuf.ByteString
          getStartDateBytes();
    }
    /**
     * Protobuf type {@code transit_realtime.TripDescriptor.ModifiedTripSelector}
     */
    public static final class ModifiedTripSelector extends
        com.google.protobuf.GeneratedMessage.ExtendableMessage<
          ModifiedTripSelector> implements
        // @@protoc_insertion_point(message_implements:transit_realtime.TripDescriptor.ModifiedTripSelector)
        ModifiedTripSelectorOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 28,
          /* patch= */ 3,
          /* suffix= */ "",
          ModifiedTripSelector.class.getName());
      }
      // Use ModifiedTripSelector.newBuilder() to construct.
      private ModifiedTripSelector(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector, ?> builder) {
        super(builder);
      }
      private ModifiedTripSelector() {
        modificationsId_ = "";
        affectedTripId_ = "";
        startTime_ = "";
        startDate_ = "";
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripDescriptor_ModifiedTripSelector_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripDescriptor_ModifiedTripSelector_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector.class, com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector.Builder.class);
      }

      private int bitField0_;
      public static final int MODIFICATIONS_ID_FIELD_NUMBER = 1;
      @SuppressWarnings("serial")
      private volatile java.lang.Object modificationsId_ = "";
      /**
       * <pre>
       * The 'id' from the FeedEntity in which the contained TripModifications object affects this trip.
       * </pre>
       *
       * <code>optional string modifications_id = 1;</code>
       * @return Whether the modificationsId field is set.
       */
      @java.lang.Override
      public boolean hasModificationsId() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The 'id' from the FeedEntity in which the contained TripModifications object affects this trip.
       * </pre>
       *
       * <code>optional string modifications_id = 1;</code>
       * @return The modificationsId.
       */
      @java.lang.Override
      public java.lang.String getModificationsId() {
        java.lang.Object ref = modificationsId_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            modificationsId_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * The 'id' from the FeedEntity in which the contained TripModifications object affects this trip.
       * </pre>
       *
       * <code>optional string modifications_id = 1;</code>
       * @return The bytes for modificationsId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getModificationsIdBytes() {
        java.lang.Object ref = modificationsId_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          modificationsId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int AFFECTED_TRIP_ID_FIELD_NUMBER = 2;
      @SuppressWarnings("serial")
      private volatile java.lang.Object affectedTripId_ = "";
      /**
       * <pre>
       * The trip_id from the GTFS feed that is modified by the modifications_id
       * </pre>
       *
       * <code>optional string affected_trip_id = 2;</code>
       * @return Whether the affectedTripId field is set.
       */
      @java.lang.Override
      public boolean hasAffectedTripId() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The trip_id from the GTFS feed that is modified by the modifications_id
       * </pre>
       *
       * <code>optional string affected_trip_id = 2;</code>
       * @return The affectedTripId.
       */
      @java.lang.Override
      public java.lang.String getAffectedTripId() {
        java.lang.Object ref = affectedTripId_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            affectedTripId_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * The trip_id from the GTFS feed that is modified by the modifications_id
       * </pre>
       *
       * <code>optional string affected_trip_id = 2;</code>
       * @return The bytes for affectedTripId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getAffectedTripIdBytes() {
        java.lang.Object ref = affectedTripId_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          affectedTripId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int START_TIME_FIELD_NUMBER = 3;
      @SuppressWarnings("serial")
      private volatile java.lang.Object startTime_ = "";
      /**
       * <pre>
       * The initially scheduled start time of this trip instance, applied to the frequency based modified trip. Same definition as start_time in TripDescriptor.
       * </pre>
       *
       * <code>optional string start_time = 3;</code>
       * @return Whether the startTime field is set.
       */
      @java.lang.Override
      public boolean hasStartTime() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The initially scheduled start time of this trip instance, applied to the frequency based modified trip. Same definition as start_time in TripDescriptor.
       * </pre>
       *
       * <code>optional string start_time = 3;</code>
       * @return The startTime.
       */
      @java.lang.Override
      public java.lang.String getStartTime() {
        java.lang.Object ref = startTime_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            startTime_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * The initially scheduled start time of this trip instance, applied to the frequency based modified trip. Same definition as start_time in TripDescriptor.
       * </pre>
       *
       * <code>optional string start_time = 3;</code>
       * @return The bytes for startTime.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getStartTimeBytes() {
        java.lang.Object ref = startTime_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          startTime_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int START_DATE_FIELD_NUMBER = 4;
      @SuppressWarnings("serial")
      private volatile java.lang.Object startDate_ = "";
      /**
       * <pre>
       * The start date of this trip instance in YYYYMMDD format, applied to the modified trip. Same definition as start_date in TripDescriptor.
       * </pre>
       *
       * <code>optional string start_date = 4;</code>
       * @return Whether the startDate field is set.
       */
      @java.lang.Override
      public boolean hasStartDate() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The start date of this trip instance in YYYYMMDD format, applied to the modified trip. Same definition as start_date in TripDescriptor.
       * </pre>
       *
       * <code>optional string start_date = 4;</code>
       * @return The startDate.
       */
      @java.lang.Override
      public java.lang.String getStartDate() {
        java.lang.Object ref = startDate_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            startDate_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * The start date of this trip instance in YYYYMMDD format, applied to the modified trip. Same definition as start_date in TripDescriptor.
       * </pre>
       *
       * <code>optional string start_date = 4;</code>
       * @return The bytes for startDate.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getStartDateBytes() {
        java.lang.Object ref = startDate_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          startDate_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        if (!extensionsAreInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        com.google.protobuf.GeneratedMessage
          .ExtendableMessage.ExtensionSerializer
            extensionWriter = newExtensionSerializer();
        if (((bitField0_ & 0x00000001) != 0)) {
          com.google.protobuf.GeneratedMessage.writeString(output, 1, modificationsId_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          com.google.protobuf.GeneratedMessage.writeString(output, 2, affectedTripId_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          com.google.protobuf.GeneratedMessage.writeString(output, 3, startTime_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          com.google.protobuf.GeneratedMessage.writeString(output, 4, startDate_);
        }
        extensionWriter.writeUntil(10000, output);
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.GeneratedMessage.computeStringSize(1, modificationsId_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.GeneratedMessage.computeStringSize(2, affectedTripId_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.GeneratedMessage.computeStringSize(3, startTime_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          size += com.google.protobuf.GeneratedMessage.computeStringSize(4, startDate_);
        }
        size += extensionsSerializedSize();
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector)) {
          return super.equals(obj);
        }
        com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector other = (com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector) obj;

        if (hasModificationsId() != other.hasModificationsId()) return false;
        if (hasModificationsId()) {
          if (!getModificationsId()
              .equals(other.getModificationsId())) return false;
        }
        if (hasAffectedTripId() != other.hasAffectedTripId()) return false;
        if (hasAffectedTripId()) {
          if (!getAffectedTripId()
              .equals(other.getAffectedTripId())) return false;
        }
        if (hasStartTime() != other.hasStartTime()) return false;
        if (hasStartTime()) {
          if (!getStartTime()
              .equals(other.getStartTime())) return false;
        }
        if (hasStartDate() != other.hasStartDate()) return false;
        if (hasStartDate()) {
          if (!getStartDate()
              .equals(other.getStartDate())) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        if (!getExtensionFields().equals(other.getExtensionFields()))
          return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasModificationsId()) {
          hash = (37 * hash) + MODIFICATIONS_ID_FIELD_NUMBER;
          hash = (53 * hash) + getModificationsId().hashCode();
        }
        if (hasAffectedTripId()) {
          hash = (37 * hash) + AFFECTED_TRIP_ID_FIELD_NUMBER;
          hash = (53 * hash) + getAffectedTripId().hashCode();
        }
        if (hasStartTime()) {
          hash = (37 * hash) + START_TIME_FIELD_NUMBER;
          hash = (53 * hash) + getStartTime().hashCode();
        }
        if (hasStartDate()) {
          hash = (37 * hash) + START_DATE_FIELD_NUMBER;
          hash = (53 * hash) + getStartDate().hashCode();
        }
        hash = hashFields(hash, getExtensionFields());
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code transit_realtime.TripDescriptor.ModifiedTripSelector}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.ExtendableBuilder<
            com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector, Builder> implements
          // @@protoc_insertion_point(builder_implements:transit_realtime.TripDescriptor.ModifiedTripSelector)
          com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelectorOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripDescriptor_ModifiedTripSelector_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripDescriptor_ModifiedTripSelector_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector.class, com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector.Builder.class);
        }

        // Construct using com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          modificationsId_ = "";
          affectedTripId_ = "";
          startTime_ = "";
          startDate_ = "";
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripDescriptor_ModifiedTripSelector_descriptor;
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector getDefaultInstanceForType() {
          return com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector.getDefaultInstance();
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector build() {
          com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector buildPartial() {
          com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector result = new com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.modificationsId_ = modificationsId_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.affectedTripId_ = affectedTripId_;
            to_bitField0_ |= 0x00000002;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.startTime_ = startTime_;
            to_bitField0_ |= 0x00000004;
          }
          if (((from_bitField0_ & 0x00000008) != 0)) {
            result.startDate_ = startDate_;
            to_bitField0_ |= 0x00000008;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector) {
            return mergeFrom((com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector other) {
          if (other == com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector.getDefaultInstance()) return this;
          if (other.hasModificationsId()) {
            modificationsId_ = other.modificationsId_;
            bitField0_ |= 0x00000001;
            onChanged();
          }
          if (other.hasAffectedTripId()) {
            affectedTripId_ = other.affectedTripId_;
            bitField0_ |= 0x00000002;
            onChanged();
          }
          if (other.hasStartTime()) {
            startTime_ = other.startTime_;
            bitField0_ |= 0x00000004;
            onChanged();
          }
          if (other.hasStartDate()) {
            startDate_ = other.startDate_;
            bitField0_ |= 0x00000008;
            onChanged();
          }
          this.mergeExtensionFields(other);
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          if (!extensionsAreInitialized()) {
            return false;
          }
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 10: {
                  modificationsId_ = input.readBytes();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
                case 18: {
                  affectedTripId_ = input.readBytes();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
                case 26: {
                  startTime_ = input.readBytes();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 26
                case 34: {
                  startDate_ = input.readBytes();
                  bitField0_ |= 0x00000008;
                  break;
                } // case 34
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private java.lang.Object modificationsId_ = "";
        /**
         * <pre>
         * The 'id' from the FeedEntity in which the contained TripModifications object affects this trip.
         * </pre>
         *
         * <code>optional string modifications_id = 1;</code>
         * @return Whether the modificationsId field is set.
         */
        public boolean hasModificationsId() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * The 'id' from the FeedEntity in which the contained TripModifications object affects this trip.
         * </pre>
         *
         * <code>optional string modifications_id = 1;</code>
         * @return The modificationsId.
         */
        public java.lang.String getModificationsId() {
          java.lang.Object ref = modificationsId_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              modificationsId_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * The 'id' from the FeedEntity in which the contained TripModifications object affects this trip.
         * </pre>
         *
         * <code>optional string modifications_id = 1;</code>
         * @return The bytes for modificationsId.
         */
        public com.google.protobuf.ByteString
            getModificationsIdBytes() {
          java.lang.Object ref = modificationsId_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            modificationsId_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * The 'id' from the FeedEntity in which the contained TripModifications object affects this trip.
         * </pre>
         *
         * <code>optional string modifications_id = 1;</code>
         * @param value The modificationsId to set.
         * @return This builder for chaining.
         */
        public Builder setModificationsId(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          modificationsId_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The 'id' from the FeedEntity in which the contained TripModifications object affects this trip.
         * </pre>
         *
         * <code>optional string modifications_id = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearModificationsId() {
          modificationsId_ = getDefaultInstance().getModificationsId();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The 'id' from the FeedEntity in which the contained TripModifications object affects this trip.
         * </pre>
         *
         * <code>optional string modifications_id = 1;</code>
         * @param value The bytes for modificationsId to set.
         * @return This builder for chaining.
         */
        public Builder setModificationsIdBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          modificationsId_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }

        private java.lang.Object affectedTripId_ = "";
        /**
         * <pre>
         * The trip_id from the GTFS feed that is modified by the modifications_id
         * </pre>
         *
         * <code>optional string affected_trip_id = 2;</code>
         * @return Whether the affectedTripId field is set.
         */
        public boolean hasAffectedTripId() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * The trip_id from the GTFS feed that is modified by the modifications_id
         * </pre>
         *
         * <code>optional string affected_trip_id = 2;</code>
         * @return The affectedTripId.
         */
        public java.lang.String getAffectedTripId() {
          java.lang.Object ref = affectedTripId_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              affectedTripId_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * The trip_id from the GTFS feed that is modified by the modifications_id
         * </pre>
         *
         * <code>optional string affected_trip_id = 2;</code>
         * @return The bytes for affectedTripId.
         */
        public com.google.protobuf.ByteString
            getAffectedTripIdBytes() {
          java.lang.Object ref = affectedTripId_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            affectedTripId_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * The trip_id from the GTFS feed that is modified by the modifications_id
         * </pre>
         *
         * <code>optional string affected_trip_id = 2;</code>
         * @param value The affectedTripId to set.
         * @return This builder for chaining.
         */
        public Builder setAffectedTripId(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          affectedTripId_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The trip_id from the GTFS feed that is modified by the modifications_id
         * </pre>
         *
         * <code>optional string affected_trip_id = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearAffectedTripId() {
          affectedTripId_ = getDefaultInstance().getAffectedTripId();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The trip_id from the GTFS feed that is modified by the modifications_id
         * </pre>
         *
         * <code>optional string affected_trip_id = 2;</code>
         * @param value The bytes for affectedTripId to set.
         * @return This builder for chaining.
         */
        public Builder setAffectedTripIdBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          affectedTripId_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }

        private java.lang.Object startTime_ = "";
        /**
         * <pre>
         * The initially scheduled start time of this trip instance, applied to the frequency based modified trip. Same definition as start_time in TripDescriptor.
         * </pre>
         *
         * <code>optional string start_time = 3;</code>
         * @return Whether the startTime field is set.
         */
        public boolean hasStartTime() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * The initially scheduled start time of this trip instance, applied to the frequency based modified trip. Same definition as start_time in TripDescriptor.
         * </pre>
         *
         * <code>optional string start_time = 3;</code>
         * @return The startTime.
         */
        public java.lang.String getStartTime() {
          java.lang.Object ref = startTime_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              startTime_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * The initially scheduled start time of this trip instance, applied to the frequency based modified trip. Same definition as start_time in TripDescriptor.
         * </pre>
         *
         * <code>optional string start_time = 3;</code>
         * @return The bytes for startTime.
         */
        public com.google.protobuf.ByteString
            getStartTimeBytes() {
          java.lang.Object ref = startTime_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            startTime_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * The initially scheduled start time of this trip instance, applied to the frequency based modified trip. Same definition as start_time in TripDescriptor.
         * </pre>
         *
         * <code>optional string start_time = 3;</code>
         * @param value The startTime to set.
         * @return This builder for chaining.
         */
        public Builder setStartTime(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          startTime_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The initially scheduled start time of this trip instance, applied to the frequency based modified trip. Same definition as start_time in TripDescriptor.
         * </pre>
         *
         * <code>optional string start_time = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearStartTime() {
          startTime_ = getDefaultInstance().getStartTime();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The initially scheduled start time of this trip instance, applied to the frequency based modified trip. Same definition as start_time in TripDescriptor.
         * </pre>
         *
         * <code>optional string start_time = 3;</code>
         * @param value The bytes for startTime to set.
         * @return This builder for chaining.
         */
        public Builder setStartTimeBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          startTime_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }

        private java.lang.Object startDate_ = "";
        /**
         * <pre>
         * The start date of this trip instance in YYYYMMDD format, applied to the modified trip. Same definition as start_date in TripDescriptor.
         * </pre>
         *
         * <code>optional string start_date = 4;</code>
         * @return Whether the startDate field is set.
         */
        public boolean hasStartDate() {
          return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <pre>
         * The start date of this trip instance in YYYYMMDD format, applied to the modified trip. Same definition as start_date in TripDescriptor.
         * </pre>
         *
         * <code>optional string start_date = 4;</code>
         * @return The startDate.
         */
        public java.lang.String getStartDate() {
          java.lang.Object ref = startDate_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              startDate_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * The start date of this trip instance in YYYYMMDD format, applied to the modified trip. Same definition as start_date in TripDescriptor.
         * </pre>
         *
         * <code>optional string start_date = 4;</code>
         * @return The bytes for startDate.
         */
        public com.google.protobuf.ByteString
            getStartDateBytes() {
          java.lang.Object ref = startDate_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            startDate_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * The start date of this trip instance in YYYYMMDD format, applied to the modified trip. Same definition as start_date in TripDescriptor.
         * </pre>
         *
         * <code>optional string start_date = 4;</code>
         * @param value The startDate to set.
         * @return This builder for chaining.
         */
        public Builder setStartDate(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          startDate_ = value;
          bitField0_ |= 0x00000008;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The start date of this trip instance in YYYYMMDD format, applied to the modified trip. Same definition as start_date in TripDescriptor.
         * </pre>
         *
         * <code>optional string start_date = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearStartDate() {
          startDate_ = getDefaultInstance().getStartDate();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The start date of this trip instance in YYYYMMDD format, applied to the modified trip. Same definition as start_date in TripDescriptor.
         * </pre>
         *
         * <code>optional string start_date = 4;</code>
         * @param value The bytes for startDate to set.
         * @return This builder for chaining.
         */
        public Builder setStartDateBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          startDate_ = value;
          bitField0_ |= 0x00000008;
          onChanged();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:transit_realtime.TripDescriptor.ModifiedTripSelector)
      }

      // @@protoc_insertion_point(class_scope:transit_realtime.TripDescriptor.ModifiedTripSelector)
      private static final com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector();
      }

      public static com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<ModifiedTripSelector>
          PARSER = new com.google.protobuf.AbstractParser<ModifiedTripSelector>() {
        @java.lang.Override
        public ModifiedTripSelector parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<ModifiedTripSelector> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<ModifiedTripSelector> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    public static final int TRIP_ID_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object tripId_ = "";
    /**
     * <pre>
     * The trip_id from the GTFS feed that this selector refers to.
     * For non frequency-based trips, this field is enough to uniquely identify
     * the trip. For frequency-based trip, start_time and start_date might also be
     * necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from
     * static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id
     * identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id.
     * </pre>
     *
     * <code>optional string trip_id = 1;</code>
     * @return Whether the tripId field is set.
     */
    @java.lang.Override
    public boolean hasTripId() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The trip_id from the GTFS feed that this selector refers to.
     * For non frequency-based trips, this field is enough to uniquely identify
     * the trip. For frequency-based trip, start_time and start_date might also be
     * necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from
     * static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id
     * identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id.
     * </pre>
     *
     * <code>optional string trip_id = 1;</code>
     * @return The tripId.
     */
    @java.lang.Override
    public java.lang.String getTripId() {
      java.lang.Object ref = tripId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          tripId_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The trip_id from the GTFS feed that this selector refers to.
     * For non frequency-based trips, this field is enough to uniquely identify
     * the trip. For frequency-based trip, start_time and start_date might also be
     * necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from
     * static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id
     * identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id.
     * </pre>
     *
     * <code>optional string trip_id = 1;</code>
     * @return The bytes for tripId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTripIdBytes() {
      java.lang.Object ref = tripId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        tripId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ROUTE_ID_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private volatile java.lang.Object routeId_ = "";
    /**
     * <pre>
     * The route_id from the GTFS that this selector refers to.
     * </pre>
     *
     * <code>optional string route_id = 5;</code>
     * @return Whether the routeId field is set.
     */
    @java.lang.Override
    public boolean hasRouteId() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The route_id from the GTFS that this selector refers to.
     * </pre>
     *
     * <code>optional string route_id = 5;</code>
     * @return The routeId.
     */
    @java.lang.Override
    public java.lang.String getRouteId() {
      java.lang.Object ref = routeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          routeId_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The route_id from the GTFS that this selector refers to.
     * </pre>
     *
     * <code>optional string route_id = 5;</code>
     * @return The bytes for routeId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRouteIdBytes() {
      java.lang.Object ref = routeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        routeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DIRECTION_ID_FIELD_NUMBER = 6;
    private int directionId_ = 0;
    /**
     * <pre>
     * The direction_id from the GTFS feed trips.txt file, indicating the
     * direction of travel for trips this selector refers to.
     * </pre>
     *
     * <code>optional uint32 direction_id = 6;</code>
     * @return Whether the directionId field is set.
     */
    @java.lang.Override
    public boolean hasDirectionId() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The direction_id from the GTFS feed trips.txt file, indicating the
     * direction of travel for trips this selector refers to.
     * </pre>
     *
     * <code>optional uint32 direction_id = 6;</code>
     * @return The directionId.
     */
    @java.lang.Override
    public int getDirectionId() {
      return directionId_;
    }

    public static final int START_TIME_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object startTime_ = "";
    /**
     * <pre>
     * The initially scheduled start time of this trip instance.
     * When the trip_id corresponds to a non-frequency-based trip, this field
     * should either be omitted or be equal to the value in the GTFS feed. When
     * the trip_id correponds to a frequency-based trip, the start_time must be
     * specified for trip updates and vehicle positions. If the trip corresponds
     * to exact_times=1 GTFS record, then start_time must be some multiple
     * (including zero) of headway_secs later than frequencies.txt start_time for
     * the corresponding time period. If the trip corresponds to exact_times=0,
     * then its start_time may be arbitrary, and is initially expected to be the
     * first departure of the trip. Once established, the start_time of this
     * frequency-based trip should be considered immutable, even if the first
     * departure time changes -- that time change may instead be reflected in a
     * StopTimeUpdate.
     * Format and semantics of the field is same as that of
     * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
     * </pre>
     *
     * <code>optional string start_time = 2;</code>
     * @return Whether the startTime field is set.
     */
    @java.lang.Override
    public boolean hasStartTime() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The initially scheduled start time of this trip instance.
     * When the trip_id corresponds to a non-frequency-based trip, this field
     * should either be omitted or be equal to the value in the GTFS feed. When
     * the trip_id correponds to a frequency-based trip, the start_time must be
     * specified for trip updates and vehicle positions. If the trip corresponds
     * to exact_times=1 GTFS record, then start_time must be some multiple
     * (including zero) of headway_secs later than frequencies.txt start_time for
     * the corresponding time period. If the trip corresponds to exact_times=0,
     * then its start_time may be arbitrary, and is initially expected to be the
     * first departure of the trip. Once established, the start_time of this
     * frequency-based trip should be considered immutable, even if the first
     * departure time changes -- that time change may instead be reflected in a
     * StopTimeUpdate.
     * Format and semantics of the field is same as that of
     * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
     * </pre>
     *
     * <code>optional string start_time = 2;</code>
     * @return The startTime.
     */
    @java.lang.Override
    public java.lang.String getStartTime() {
      java.lang.Object ref = startTime_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          startTime_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The initially scheduled start time of this trip instance.
     * When the trip_id corresponds to a non-frequency-based trip, this field
     * should either be omitted or be equal to the value in the GTFS feed. When
     * the trip_id correponds to a frequency-based trip, the start_time must be
     * specified for trip updates and vehicle positions. If the trip corresponds
     * to exact_times=1 GTFS record, then start_time must be some multiple
     * (including zero) of headway_secs later than frequencies.txt start_time for
     * the corresponding time period. If the trip corresponds to exact_times=0,
     * then its start_time may be arbitrary, and is initially expected to be the
     * first departure of the trip. Once established, the start_time of this
     * frequency-based trip should be considered immutable, even if the first
     * departure time changes -- that time change may instead be reflected in a
     * StopTimeUpdate.
     * Format and semantics of the field is same as that of
     * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
     * </pre>
     *
     * <code>optional string start_time = 2;</code>
     * @return The bytes for startTime.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStartTimeBytes() {
      java.lang.Object ref = startTime_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        startTime_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int START_DATE_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object startDate_ = "";
    /**
     * <pre>
     * The scheduled start date of this trip instance.
     * Must be provided to disambiguate trips that are so late as to collide with
     * a scheduled trip on a next day. For example, for a train that departs 8:00
     * and 20:00 every day, and is 12 hours late, there would be two distinct
     * trips on the same time.
     * This field can be provided but is not mandatory for schedules in which such
     * collisions are impossible - for example, a service running on hourly
     * schedule where a vehicle that is one hour late is not considered to be
     * related to schedule anymore.
     * In YYYYMMDD format.
     * </pre>
     *
     * <code>optional string start_date = 3;</code>
     * @return Whether the startDate field is set.
     */
    @java.lang.Override
    public boolean hasStartDate() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * The scheduled start date of this trip instance.
     * Must be provided to disambiguate trips that are so late as to collide with
     * a scheduled trip on a next day. For example, for a train that departs 8:00
     * and 20:00 every day, and is 12 hours late, there would be two distinct
     * trips on the same time.
     * This field can be provided but is not mandatory for schedules in which such
     * collisions are impossible - for example, a service running on hourly
     * schedule where a vehicle that is one hour late is not considered to be
     * related to schedule anymore.
     * In YYYYMMDD format.
     * </pre>
     *
     * <code>optional string start_date = 3;</code>
     * @return The startDate.
     */
    @java.lang.Override
    public java.lang.String getStartDate() {
      java.lang.Object ref = startDate_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          startDate_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The scheduled start date of this trip instance.
     * Must be provided to disambiguate trips that are so late as to collide with
     * a scheduled trip on a next day. For example, for a train that departs 8:00
     * and 20:00 every day, and is 12 hours late, there would be two distinct
     * trips on the same time.
     * This field can be provided but is not mandatory for schedules in which such
     * collisions are impossible - for example, a service running on hourly
     * schedule where a vehicle that is one hour late is not considered to be
     * related to schedule anymore.
     * In YYYYMMDD format.
     * </pre>
     *
     * <code>optional string start_date = 3;</code>
     * @return The bytes for startDate.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStartDateBytes() {
      java.lang.Object ref = startDate_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        startDate_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SCHEDULE_RELATIONSHIP_FIELD_NUMBER = 4;
    private int scheduleRelationship_ = 0;
    /**
     * <code>optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;</code>
     * @return Whether the scheduleRelationship field is set.
     */
    @java.lang.Override public boolean hasScheduleRelationship() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <code>optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;</code>
     * @return The scheduleRelationship.
     */
    @java.lang.Override public com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship getScheduleRelationship() {
      com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship result = com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship.forNumber(scheduleRelationship_);
      return result == null ? com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship.SCHEDULED : result;
    }

    public static final int MODIFIED_TRIP_FIELD_NUMBER = 7;
    private com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector modifiedTrip_;
    /**
     * <pre>
     * Linkage to any modifications done to this trip (shape changes, removal or addition of stops). 
     * If this field is provided, the `trip_id`, `route_id`, `direction_id`, `start_time`, `start_date` fields of the `TripDescriptor` MUST be left empty, to avoid confusion by consumers that aren't looking for the `ModifiedTripSelector` value. 
     * </pre>
     *
     * <code>optional .transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7;</code>
     * @return Whether the modifiedTrip field is set.
     */
    @java.lang.Override
    public boolean hasModifiedTrip() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Linkage to any modifications done to this trip (shape changes, removal or addition of stops). 
     * If this field is provided, the `trip_id`, `route_id`, `direction_id`, `start_time`, `start_date` fields of the `TripDescriptor` MUST be left empty, to avoid confusion by consumers that aren't looking for the `ModifiedTripSelector` value. 
     * </pre>
     *
     * <code>optional .transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7;</code>
     * @return The modifiedTrip.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector getModifiedTrip() {
      return modifiedTrip_ == null ? com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector.getDefaultInstance() : modifiedTrip_;
    }
    /**
     * <pre>
     * Linkage to any modifications done to this trip (shape changes, removal or addition of stops). 
     * If this field is provided, the `trip_id`, `route_id`, `direction_id`, `start_time`, `start_date` fields of the `TripDescriptor` MUST be left empty, to avoid confusion by consumers that aren't looking for the `ModifiedTripSelector` value. 
     * </pre>
     *
     * <code>optional .transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelectorOrBuilder getModifiedTripOrBuilder() {
      return modifiedTrip_ == null ? com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector.getDefaultInstance() : modifiedTrip_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (hasModifiedTrip()) {
        if (!getModifiedTrip().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (!extensionsAreInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessage
        .ExtendableMessage.ExtensionSerializer
          extensionWriter = newExtensionSerializer();
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, tripId_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, startTime_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, startDate_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeEnum(4, scheduleRelationship_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 5, routeId_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeUInt32(6, directionId_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeMessage(7, getModifiedTrip());
      }
      extensionWriter.writeUntil(10000, output);
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, tripId_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, startTime_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, startDate_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(4, scheduleRelationship_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(5, routeId_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(6, directionId_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getModifiedTrip());
      }
      size += extensionsSerializedSize();
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.TripDescriptor)) {
        return super.equals(obj);
      }
      com.google.transit.realtime.GtfsRealtime.TripDescriptor other = (com.google.transit.realtime.GtfsRealtime.TripDescriptor) obj;

      if (hasTripId() != other.hasTripId()) return false;
      if (hasTripId()) {
        if (!getTripId()
            .equals(other.getTripId())) return false;
      }
      if (hasRouteId() != other.hasRouteId()) return false;
      if (hasRouteId()) {
        if (!getRouteId()
            .equals(other.getRouteId())) return false;
      }
      if (hasDirectionId() != other.hasDirectionId()) return false;
      if (hasDirectionId()) {
        if (getDirectionId()
            != other.getDirectionId()) return false;
      }
      if (hasStartTime() != other.hasStartTime()) return false;
      if (hasStartTime()) {
        if (!getStartTime()
            .equals(other.getStartTime())) return false;
      }
      if (hasStartDate() != other.hasStartDate()) return false;
      if (hasStartDate()) {
        if (!getStartDate()
            .equals(other.getStartDate())) return false;
      }
      if (hasScheduleRelationship() != other.hasScheduleRelationship()) return false;
      if (hasScheduleRelationship()) {
        if (scheduleRelationship_ != other.scheduleRelationship_) return false;
      }
      if (hasModifiedTrip() != other.hasModifiedTrip()) return false;
      if (hasModifiedTrip()) {
        if (!getModifiedTrip()
            .equals(other.getModifiedTrip())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      if (!getExtensionFields().equals(other.getExtensionFields()))
        return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasTripId()) {
        hash = (37 * hash) + TRIP_ID_FIELD_NUMBER;
        hash = (53 * hash) + getTripId().hashCode();
      }
      if (hasRouteId()) {
        hash = (37 * hash) + ROUTE_ID_FIELD_NUMBER;
        hash = (53 * hash) + getRouteId().hashCode();
      }
      if (hasDirectionId()) {
        hash = (37 * hash) + DIRECTION_ID_FIELD_NUMBER;
        hash = (53 * hash) + getDirectionId();
      }
      if (hasStartTime()) {
        hash = (37 * hash) + START_TIME_FIELD_NUMBER;
        hash = (53 * hash) + getStartTime().hashCode();
      }
      if (hasStartDate()) {
        hash = (37 * hash) + START_DATE_FIELD_NUMBER;
        hash = (53 * hash) + getStartDate().hashCode();
      }
      if (hasScheduleRelationship()) {
        hash = (37 * hash) + SCHEDULE_RELATIONSHIP_FIELD_NUMBER;
        hash = (53 * hash) + scheduleRelationship_;
      }
      if (hasModifiedTrip()) {
        hash = (37 * hash) + MODIFIED_TRIP_FIELD_NUMBER;
        hash = (53 * hash) + getModifiedTrip().hashCode();
      }
      hash = hashFields(hash, getExtensionFields());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.TripDescriptor prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * A descriptor that identifies an instance of a GTFS trip, or all instances of
     * a trip along a route.
     * - To specify a single trip instance, the trip_id (and if necessary,
     * start_time) is set. If route_id is also set, then it should be same as one
     * that the given trip corresponds to.
     * - To specify all the trips along a given route, only the route_id should be
     * set. Note that if the trip_id is not known, then stop sequence ids in
     * TripUpdate are not sufficient, and stop_ids must be provided as well. In
     * addition, absolute arrival/departure times must be provided.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.TripDescriptor}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
          com.google.transit.realtime.GtfsRealtime.TripDescriptor, Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_realtime.TripDescriptor)
        com.google.transit.realtime.GtfsRealtime.TripDescriptorOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripDescriptor_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripDescriptor_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.TripDescriptor.class, com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder.class);
      }

      // Construct using com.google.transit.realtime.GtfsRealtime.TripDescriptor.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getModifiedTripFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        tripId_ = "";
        routeId_ = "";
        directionId_ = 0;
        startTime_ = "";
        startDate_ = "";
        scheduleRelationship_ = 0;
        modifiedTrip_ = null;
        if (modifiedTripBuilder_ != null) {
          modifiedTripBuilder_.dispose();
          modifiedTripBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripDescriptor_descriptor;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TripDescriptor getDefaultInstanceForType() {
        return com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TripDescriptor build() {
        com.google.transit.realtime.GtfsRealtime.TripDescriptor result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TripDescriptor buildPartial() {
        com.google.transit.realtime.GtfsRealtime.TripDescriptor result = new com.google.transit.realtime.GtfsRealtime.TripDescriptor(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.transit.realtime.GtfsRealtime.TripDescriptor result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.tripId_ = tripId_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.routeId_ = routeId_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.directionId_ = directionId_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.startTime_ = startTime_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.startDate_ = startDate_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.scheduleRelationship_ = scheduleRelationship_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.modifiedTrip_ = modifiedTripBuilder_ == null
              ? modifiedTrip_
              : modifiedTripBuilder_.build();
          to_bitField0_ |= 0x00000040;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.transit.realtime.GtfsRealtime.TripDescriptor) {
          return mergeFrom((com.google.transit.realtime.GtfsRealtime.TripDescriptor)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.TripDescriptor other) {
        if (other == com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance()) return this;
        if (other.hasTripId()) {
          tripId_ = other.tripId_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasRouteId()) {
          routeId_ = other.routeId_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasDirectionId()) {
          setDirectionId(other.getDirectionId());
        }
        if (other.hasStartTime()) {
          startTime_ = other.startTime_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (other.hasStartDate()) {
          startDate_ = other.startDate_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (other.hasScheduleRelationship()) {
          setScheduleRelationship(other.getScheduleRelationship());
        }
        if (other.hasModifiedTrip()) {
          mergeModifiedTrip(other.getModifiedTrip());
        }
        this.mergeExtensionFields(other);
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (hasModifiedTrip()) {
          if (!getModifiedTrip().isInitialized()) {
            return false;
          }
        }
        if (!extensionsAreInitialized()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                tripId_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                startTime_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 18
              case 26: {
                startDate_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 26
              case 32: {
                int tmpRaw = input.readEnum();
                com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship tmpValue =
                    com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(4, tmpRaw);
                } else {
                  scheduleRelationship_ = tmpRaw;
                  bitField0_ |= 0x00000020;
                }
                break;
              } // case 32
              case 42: {
                routeId_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 42
              case 48: {
                directionId_ = input.readUInt32();
                bitField0_ |= 0x00000004;
                break;
              } // case 48
              case 58: {
                input.readMessage(
                    getModifiedTripFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000040;
                break;
              } // case 58
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object tripId_ = "";
      /**
       * <pre>
       * The trip_id from the GTFS feed that this selector refers to.
       * For non frequency-based trips, this field is enough to uniquely identify
       * the trip. For frequency-based trip, start_time and start_date might also be
       * necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from
       * static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id
       * identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id.
       * </pre>
       *
       * <code>optional string trip_id = 1;</code>
       * @return Whether the tripId field is set.
       */
      public boolean hasTripId() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The trip_id from the GTFS feed that this selector refers to.
       * For non frequency-based trips, this field is enough to uniquely identify
       * the trip. For frequency-based trip, start_time and start_date might also be
       * necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from
       * static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id
       * identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id.
       * </pre>
       *
       * <code>optional string trip_id = 1;</code>
       * @return The tripId.
       */
      public java.lang.String getTripId() {
        java.lang.Object ref = tripId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            tripId_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The trip_id from the GTFS feed that this selector refers to.
       * For non frequency-based trips, this field is enough to uniquely identify
       * the trip. For frequency-based trip, start_time and start_date might also be
       * necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from
       * static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id
       * identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id.
       * </pre>
       *
       * <code>optional string trip_id = 1;</code>
       * @return The bytes for tripId.
       */
      public com.google.protobuf.ByteString
          getTripIdBytes() {
        java.lang.Object ref = tripId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          tripId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The trip_id from the GTFS feed that this selector refers to.
       * For non frequency-based trips, this field is enough to uniquely identify
       * the trip. For frequency-based trip, start_time and start_date might also be
       * necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from
       * static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id
       * identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id.
       * </pre>
       *
       * <code>optional string trip_id = 1;</code>
       * @param value The tripId to set.
       * @return This builder for chaining.
       */
      public Builder setTripId(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        tripId_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The trip_id from the GTFS feed that this selector refers to.
       * For non frequency-based trips, this field is enough to uniquely identify
       * the trip. For frequency-based trip, start_time and start_date might also be
       * necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from
       * static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id
       * identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id.
       * </pre>
       *
       * <code>optional string trip_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTripId() {
        tripId_ = getDefaultInstance().getTripId();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The trip_id from the GTFS feed that this selector refers to.
       * For non frequency-based trips, this field is enough to uniquely identify
       * the trip. For frequency-based trip, start_time and start_date might also be
       * necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from
       * static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id
       * identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id.
       * </pre>
       *
       * <code>optional string trip_id = 1;</code>
       * @param value The bytes for tripId to set.
       * @return This builder for chaining.
       */
      public Builder setTripIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        tripId_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object routeId_ = "";
      /**
       * <pre>
       * The route_id from the GTFS that this selector refers to.
       * </pre>
       *
       * <code>optional string route_id = 5;</code>
       * @return Whether the routeId field is set.
       */
      public boolean hasRouteId() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The route_id from the GTFS that this selector refers to.
       * </pre>
       *
       * <code>optional string route_id = 5;</code>
       * @return The routeId.
       */
      public java.lang.String getRouteId() {
        java.lang.Object ref = routeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            routeId_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The route_id from the GTFS that this selector refers to.
       * </pre>
       *
       * <code>optional string route_id = 5;</code>
       * @return The bytes for routeId.
       */
      public com.google.protobuf.ByteString
          getRouteIdBytes() {
        java.lang.Object ref = routeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          routeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The route_id from the GTFS that this selector refers to.
       * </pre>
       *
       * <code>optional string route_id = 5;</code>
       * @param value The routeId to set.
       * @return This builder for chaining.
       */
      public Builder setRouteId(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        routeId_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The route_id from the GTFS that this selector refers to.
       * </pre>
       *
       * <code>optional string route_id = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearRouteId() {
        routeId_ = getDefaultInstance().getRouteId();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The route_id from the GTFS that this selector refers to.
       * </pre>
       *
       * <code>optional string route_id = 5;</code>
       * @param value The bytes for routeId to set.
       * @return This builder for chaining.
       */
      public Builder setRouteIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        routeId_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private int directionId_ ;
      /**
       * <pre>
       * The direction_id from the GTFS feed trips.txt file, indicating the
       * direction of travel for trips this selector refers to.
       * </pre>
       *
       * <code>optional uint32 direction_id = 6;</code>
       * @return Whether the directionId field is set.
       */
      @java.lang.Override
      public boolean hasDirectionId() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The direction_id from the GTFS feed trips.txt file, indicating the
       * direction of travel for trips this selector refers to.
       * </pre>
       *
       * <code>optional uint32 direction_id = 6;</code>
       * @return The directionId.
       */
      @java.lang.Override
      public int getDirectionId() {
        return directionId_;
      }
      /**
       * <pre>
       * The direction_id from the GTFS feed trips.txt file, indicating the
       * direction of travel for trips this selector refers to.
       * </pre>
       *
       * <code>optional uint32 direction_id = 6;</code>
       * @param value The directionId to set.
       * @return This builder for chaining.
       */
      public Builder setDirectionId(int value) {

        directionId_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The direction_id from the GTFS feed trips.txt file, indicating the
       * direction of travel for trips this selector refers to.
       * </pre>
       *
       * <code>optional uint32 direction_id = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearDirectionId() {
        bitField0_ = (bitField0_ & ~0x00000004);
        directionId_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object startTime_ = "";
      /**
       * <pre>
       * The initially scheduled start time of this trip instance.
       * When the trip_id corresponds to a non-frequency-based trip, this field
       * should either be omitted or be equal to the value in the GTFS feed. When
       * the trip_id correponds to a frequency-based trip, the start_time must be
       * specified for trip updates and vehicle positions. If the trip corresponds
       * to exact_times=1 GTFS record, then start_time must be some multiple
       * (including zero) of headway_secs later than frequencies.txt start_time for
       * the corresponding time period. If the trip corresponds to exact_times=0,
       * then its start_time may be arbitrary, and is initially expected to be the
       * first departure of the trip. Once established, the start_time of this
       * frequency-based trip should be considered immutable, even if the first
       * departure time changes -- that time change may instead be reflected in a
       * StopTimeUpdate.
       * Format and semantics of the field is same as that of
       * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
       * </pre>
       *
       * <code>optional string start_time = 2;</code>
       * @return Whether the startTime field is set.
       */
      public boolean hasStartTime() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The initially scheduled start time of this trip instance.
       * When the trip_id corresponds to a non-frequency-based trip, this field
       * should either be omitted or be equal to the value in the GTFS feed. When
       * the trip_id correponds to a frequency-based trip, the start_time must be
       * specified for trip updates and vehicle positions. If the trip corresponds
       * to exact_times=1 GTFS record, then start_time must be some multiple
       * (including zero) of headway_secs later than frequencies.txt start_time for
       * the corresponding time period. If the trip corresponds to exact_times=0,
       * then its start_time may be arbitrary, and is initially expected to be the
       * first departure of the trip. Once established, the start_time of this
       * frequency-based trip should be considered immutable, even if the first
       * departure time changes -- that time change may instead be reflected in a
       * StopTimeUpdate.
       * Format and semantics of the field is same as that of
       * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
       * </pre>
       *
       * <code>optional string start_time = 2;</code>
       * @return The startTime.
       */
      public java.lang.String getStartTime() {
        java.lang.Object ref = startTime_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            startTime_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The initially scheduled start time of this trip instance.
       * When the trip_id corresponds to a non-frequency-based trip, this field
       * should either be omitted or be equal to the value in the GTFS feed. When
       * the trip_id correponds to a frequency-based trip, the start_time must be
       * specified for trip updates and vehicle positions. If the trip corresponds
       * to exact_times=1 GTFS record, then start_time must be some multiple
       * (including zero) of headway_secs later than frequencies.txt start_time for
       * the corresponding time period. If the trip corresponds to exact_times=0,
       * then its start_time may be arbitrary, and is initially expected to be the
       * first departure of the trip. Once established, the start_time of this
       * frequency-based trip should be considered immutable, even if the first
       * departure time changes -- that time change may instead be reflected in a
       * StopTimeUpdate.
       * Format and semantics of the field is same as that of
       * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
       * </pre>
       *
       * <code>optional string start_time = 2;</code>
       * @return The bytes for startTime.
       */
      public com.google.protobuf.ByteString
          getStartTimeBytes() {
        java.lang.Object ref = startTime_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          startTime_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The initially scheduled start time of this trip instance.
       * When the trip_id corresponds to a non-frequency-based trip, this field
       * should either be omitted or be equal to the value in the GTFS feed. When
       * the trip_id correponds to a frequency-based trip, the start_time must be
       * specified for trip updates and vehicle positions. If the trip corresponds
       * to exact_times=1 GTFS record, then start_time must be some multiple
       * (including zero) of headway_secs later than frequencies.txt start_time for
       * the corresponding time period. If the trip corresponds to exact_times=0,
       * then its start_time may be arbitrary, and is initially expected to be the
       * first departure of the trip. Once established, the start_time of this
       * frequency-based trip should be considered immutable, even if the first
       * departure time changes -- that time change may instead be reflected in a
       * StopTimeUpdate.
       * Format and semantics of the field is same as that of
       * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
       * </pre>
       *
       * <code>optional string start_time = 2;</code>
       * @param value The startTime to set.
       * @return This builder for chaining.
       */
      public Builder setStartTime(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        startTime_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The initially scheduled start time of this trip instance.
       * When the trip_id corresponds to a non-frequency-based trip, this field
       * should either be omitted or be equal to the value in the GTFS feed. When
       * the trip_id correponds to a frequency-based trip, the start_time must be
       * specified for trip updates and vehicle positions. If the trip corresponds
       * to exact_times=1 GTFS record, then start_time must be some multiple
       * (including zero) of headway_secs later than frequencies.txt start_time for
       * the corresponding time period. If the trip corresponds to exact_times=0,
       * then its start_time may be arbitrary, and is initially expected to be the
       * first departure of the trip. Once established, the start_time of this
       * frequency-based trip should be considered immutable, even if the first
       * departure time changes -- that time change may instead be reflected in a
       * StopTimeUpdate.
       * Format and semantics of the field is same as that of
       * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
       * </pre>
       *
       * <code>optional string start_time = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearStartTime() {
        startTime_ = getDefaultInstance().getStartTime();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The initially scheduled start time of this trip instance.
       * When the trip_id corresponds to a non-frequency-based trip, this field
       * should either be omitted or be equal to the value in the GTFS feed. When
       * the trip_id correponds to a frequency-based trip, the start_time must be
       * specified for trip updates and vehicle positions. If the trip corresponds
       * to exact_times=1 GTFS record, then start_time must be some multiple
       * (including zero) of headway_secs later than frequencies.txt start_time for
       * the corresponding time period. If the trip corresponds to exact_times=0,
       * then its start_time may be arbitrary, and is initially expected to be the
       * first departure of the trip. Once established, the start_time of this
       * frequency-based trip should be considered immutable, even if the first
       * departure time changes -- that time change may instead be reflected in a
       * StopTimeUpdate.
       * Format and semantics of the field is same as that of
       * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
       * </pre>
       *
       * <code>optional string start_time = 2;</code>
       * @param value The bytes for startTime to set.
       * @return This builder for chaining.
       */
      public Builder setStartTimeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        startTime_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private java.lang.Object startDate_ = "";
      /**
       * <pre>
       * The scheduled start date of this trip instance.
       * Must be provided to disambiguate trips that are so late as to collide with
       * a scheduled trip on a next day. For example, for a train that departs 8:00
       * and 20:00 every day, and is 12 hours late, there would be two distinct
       * trips on the same time.
       * This field can be provided but is not mandatory for schedules in which such
       * collisions are impossible - for example, a service running on hourly
       * schedule where a vehicle that is one hour late is not considered to be
       * related to schedule anymore.
       * In YYYYMMDD format.
       * </pre>
       *
       * <code>optional string start_date = 3;</code>
       * @return Whether the startDate field is set.
       */
      public boolean hasStartDate() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * The scheduled start date of this trip instance.
       * Must be provided to disambiguate trips that are so late as to collide with
       * a scheduled trip on a next day. For example, for a train that departs 8:00
       * and 20:00 every day, and is 12 hours late, there would be two distinct
       * trips on the same time.
       * This field can be provided but is not mandatory for schedules in which such
       * collisions are impossible - for example, a service running on hourly
       * schedule where a vehicle that is one hour late is not considered to be
       * related to schedule anymore.
       * In YYYYMMDD format.
       * </pre>
       *
       * <code>optional string start_date = 3;</code>
       * @return The startDate.
       */
      public java.lang.String getStartDate() {
        java.lang.Object ref = startDate_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            startDate_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The scheduled start date of this trip instance.
       * Must be provided to disambiguate trips that are so late as to collide with
       * a scheduled trip on a next day. For example, for a train that departs 8:00
       * and 20:00 every day, and is 12 hours late, there would be two distinct
       * trips on the same time.
       * This field can be provided but is not mandatory for schedules in which such
       * collisions are impossible - for example, a service running on hourly
       * schedule where a vehicle that is one hour late is not considered to be
       * related to schedule anymore.
       * In YYYYMMDD format.
       * </pre>
       *
       * <code>optional string start_date = 3;</code>
       * @return The bytes for startDate.
       */
      public com.google.protobuf.ByteString
          getStartDateBytes() {
        java.lang.Object ref = startDate_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          startDate_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The scheduled start date of this trip instance.
       * Must be provided to disambiguate trips that are so late as to collide with
       * a scheduled trip on a next day. For example, for a train that departs 8:00
       * and 20:00 every day, and is 12 hours late, there would be two distinct
       * trips on the same time.
       * This field can be provided but is not mandatory for schedules in which such
       * collisions are impossible - for example, a service running on hourly
       * schedule where a vehicle that is one hour late is not considered to be
       * related to schedule anymore.
       * In YYYYMMDD format.
       * </pre>
       *
       * <code>optional string start_date = 3;</code>
       * @param value The startDate to set.
       * @return This builder for chaining.
       */
      public Builder setStartDate(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        startDate_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The scheduled start date of this trip instance.
       * Must be provided to disambiguate trips that are so late as to collide with
       * a scheduled trip on a next day. For example, for a train that departs 8:00
       * and 20:00 every day, and is 12 hours late, there would be two distinct
       * trips on the same time.
       * This field can be provided but is not mandatory for schedules in which such
       * collisions are impossible - for example, a service running on hourly
       * schedule where a vehicle that is one hour late is not considered to be
       * related to schedule anymore.
       * In YYYYMMDD format.
       * </pre>
       *
       * <code>optional string start_date = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearStartDate() {
        startDate_ = getDefaultInstance().getStartDate();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The scheduled start date of this trip instance.
       * Must be provided to disambiguate trips that are so late as to collide with
       * a scheduled trip on a next day. For example, for a train that departs 8:00
       * and 20:00 every day, and is 12 hours late, there would be two distinct
       * trips on the same time.
       * This field can be provided but is not mandatory for schedules in which such
       * collisions are impossible - for example, a service running on hourly
       * schedule where a vehicle that is one hour late is not considered to be
       * related to schedule anymore.
       * In YYYYMMDD format.
       * </pre>
       *
       * <code>optional string start_date = 3;</code>
       * @param value The bytes for startDate to set.
       * @return This builder for chaining.
       */
      public Builder setStartDateBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        startDate_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private int scheduleRelationship_ = 0;
      /**
       * <code>optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;</code>
       * @return Whether the scheduleRelationship field is set.
       */
      @java.lang.Override public boolean hasScheduleRelationship() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <code>optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;</code>
       * @return The scheduleRelationship.
       */
      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship getScheduleRelationship() {
        com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship result = com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship.forNumber(scheduleRelationship_);
        return result == null ? com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship.SCHEDULED : result;
      }
      /**
       * <code>optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;</code>
       * @param value The scheduleRelationship to set.
       * @return This builder for chaining.
       */
      public Builder setScheduleRelationship(com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000020;
        scheduleRelationship_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearScheduleRelationship() {
        bitField0_ = (bitField0_ & ~0x00000020);
        scheduleRelationship_ = 0;
        onChanged();
        return this;
      }

      private com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector modifiedTrip_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector, com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector.Builder, com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelectorOrBuilder> modifiedTripBuilder_;
      /**
       * <pre>
       * Linkage to any modifications done to this trip (shape changes, removal or addition of stops). 
       * If this field is provided, the `trip_id`, `route_id`, `direction_id`, `start_time`, `start_date` fields of the `TripDescriptor` MUST be left empty, to avoid confusion by consumers that aren't looking for the `ModifiedTripSelector` value. 
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7;</code>
       * @return Whether the modifiedTrip field is set.
       */
      public boolean hasModifiedTrip() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Linkage to any modifications done to this trip (shape changes, removal or addition of stops). 
       * If this field is provided, the `trip_id`, `route_id`, `direction_id`, `start_time`, `start_date` fields of the `TripDescriptor` MUST be left empty, to avoid confusion by consumers that aren't looking for the `ModifiedTripSelector` value. 
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7;</code>
       * @return The modifiedTrip.
       */
      public com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector getModifiedTrip() {
        if (modifiedTripBuilder_ == null) {
          return modifiedTrip_ == null ? com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector.getDefaultInstance() : modifiedTrip_;
        } else {
          return modifiedTripBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Linkage to any modifications done to this trip (shape changes, removal or addition of stops). 
       * If this field is provided, the `trip_id`, `route_id`, `direction_id`, `start_time`, `start_date` fields of the `TripDescriptor` MUST be left empty, to avoid confusion by consumers that aren't looking for the `ModifiedTripSelector` value. 
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7;</code>
       */
      public Builder setModifiedTrip(com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector value) {
        if (modifiedTripBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          modifiedTrip_ = value;
        } else {
          modifiedTripBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Linkage to any modifications done to this trip (shape changes, removal or addition of stops). 
       * If this field is provided, the `trip_id`, `route_id`, `direction_id`, `start_time`, `start_date` fields of the `TripDescriptor` MUST be left empty, to avoid confusion by consumers that aren't looking for the `ModifiedTripSelector` value. 
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7;</code>
       */
      public Builder setModifiedTrip(
          com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector.Builder builderForValue) {
        if (modifiedTripBuilder_ == null) {
          modifiedTrip_ = builderForValue.build();
        } else {
          modifiedTripBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Linkage to any modifications done to this trip (shape changes, removal or addition of stops). 
       * If this field is provided, the `trip_id`, `route_id`, `direction_id`, `start_time`, `start_date` fields of the `TripDescriptor` MUST be left empty, to avoid confusion by consumers that aren't looking for the `ModifiedTripSelector` value. 
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7;</code>
       */
      public Builder mergeModifiedTrip(com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector value) {
        if (modifiedTripBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
            modifiedTrip_ != null &&
            modifiedTrip_ != com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector.getDefaultInstance()) {
            getModifiedTripBuilder().mergeFrom(value);
          } else {
            modifiedTrip_ = value;
          }
        } else {
          modifiedTripBuilder_.mergeFrom(value);
        }
        if (modifiedTrip_ != null) {
          bitField0_ |= 0x00000040;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Linkage to any modifications done to this trip (shape changes, removal or addition of stops). 
       * If this field is provided, the `trip_id`, `route_id`, `direction_id`, `start_time`, `start_date` fields of the `TripDescriptor` MUST be left empty, to avoid confusion by consumers that aren't looking for the `ModifiedTripSelector` value. 
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7;</code>
       */
      public Builder clearModifiedTrip() {
        bitField0_ = (bitField0_ & ~0x00000040);
        modifiedTrip_ = null;
        if (modifiedTripBuilder_ != null) {
          modifiedTripBuilder_.dispose();
          modifiedTripBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Linkage to any modifications done to this trip (shape changes, removal or addition of stops). 
       * If this field is provided, the `trip_id`, `route_id`, `direction_id`, `start_time`, `start_date` fields of the `TripDescriptor` MUST be left empty, to avoid confusion by consumers that aren't looking for the `ModifiedTripSelector` value. 
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector.Builder getModifiedTripBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getModifiedTripFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Linkage to any modifications done to this trip (shape changes, removal or addition of stops). 
       * If this field is provided, the `trip_id`, `route_id`, `direction_id`, `start_time`, `start_date` fields of the `TripDescriptor` MUST be left empty, to avoid confusion by consumers that aren't looking for the `ModifiedTripSelector` value. 
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelectorOrBuilder getModifiedTripOrBuilder() {
        if (modifiedTripBuilder_ != null) {
          return modifiedTripBuilder_.getMessageOrBuilder();
        } else {
          return modifiedTrip_ == null ?
              com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector.getDefaultInstance() : modifiedTrip_;
        }
      }
      /**
       * <pre>
       * Linkage to any modifications done to this trip (shape changes, removal or addition of stops). 
       * If this field is provided, the `trip_id`, `route_id`, `direction_id`, `start_time`, `start_date` fields of the `TripDescriptor` MUST be left empty, to avoid confusion by consumers that aren't looking for the `ModifiedTripSelector` value. 
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector, com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector.Builder, com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelectorOrBuilder> 
          getModifiedTripFieldBuilder() {
        if (modifiedTripBuilder_ == null) {
          modifiedTripBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector, com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelector.Builder, com.google.transit.realtime.GtfsRealtime.TripDescriptor.ModifiedTripSelectorOrBuilder>(
                  getModifiedTrip(),
                  getParentForChildren(),
                  isClean());
          modifiedTrip_ = null;
        }
        return modifiedTripBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.TripDescriptor)
    }

    // @@protoc_insertion_point(class_scope:transit_realtime.TripDescriptor)
    private static final com.google.transit.realtime.GtfsRealtime.TripDescriptor DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.TripDescriptor();
    }

    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TripDescriptor>
        PARSER = new com.google.protobuf.AbstractParser<TripDescriptor>() {
      @java.lang.Override
      public TripDescriptor parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TripDescriptor> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TripDescriptor> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripDescriptor getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VehicleDescriptorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_realtime.VehicleDescriptor)
      com.google.protobuf.GeneratedMessage.
          ExtendableMessageOrBuilder<VehicleDescriptor> {

    /**
     * <pre>
     * Internal system identification of the vehicle. Should be unique per
     * vehicle, and can be used for tracking the vehicle as it proceeds through
     * the system.
     * </pre>
     *
     * <code>optional string id = 1;</code>
     * @return Whether the id field is set.
     */
    boolean hasId();
    /**
     * <pre>
     * Internal system identification of the vehicle. Should be unique per
     * vehicle, and can be used for tracking the vehicle as it proceeds through
     * the system.
     * </pre>
     *
     * <code>optional string id = 1;</code>
     * @return The id.
     */
    java.lang.String getId();
    /**
     * <pre>
     * Internal system identification of the vehicle. Should be unique per
     * vehicle, and can be used for tracking the vehicle as it proceeds through
     * the system.
     * </pre>
     *
     * <code>optional string id = 1;</code>
     * @return The bytes for id.
     */
    com.google.protobuf.ByteString
        getIdBytes();

    /**
     * <pre>
     * User visible label, i.e., something that must be shown to the passenger to
     * help identify the correct vehicle.
     * </pre>
     *
     * <code>optional string label = 2;</code>
     * @return Whether the label field is set.
     */
    boolean hasLabel();
    /**
     * <pre>
     * User visible label, i.e., something that must be shown to the passenger to
     * help identify the correct vehicle.
     * </pre>
     *
     * <code>optional string label = 2;</code>
     * @return The label.
     */
    java.lang.String getLabel();
    /**
     * <pre>
     * User visible label, i.e., something that must be shown to the passenger to
     * help identify the correct vehicle.
     * </pre>
     *
     * <code>optional string label = 2;</code>
     * @return The bytes for label.
     */
    com.google.protobuf.ByteString
        getLabelBytes();

    /**
     * <pre>
     * The license plate of the vehicle.
     * </pre>
     *
     * <code>optional string license_plate = 3;</code>
     * @return Whether the licensePlate field is set.
     */
    boolean hasLicensePlate();
    /**
     * <pre>
     * The license plate of the vehicle.
     * </pre>
     *
     * <code>optional string license_plate = 3;</code>
     * @return The licensePlate.
     */
    java.lang.String getLicensePlate();
    /**
     * <pre>
     * The license plate of the vehicle.
     * </pre>
     *
     * <code>optional string license_plate = 3;</code>
     * @return The bytes for licensePlate.
     */
    com.google.protobuf.ByteString
        getLicensePlateBytes();

    /**
     * <code>optional .transit_realtime.VehicleDescriptor.WheelchairAccessible wheelchair_accessible = 4 [default = NO_VALUE];</code>
     * @return Whether the wheelchairAccessible field is set.
     */
    boolean hasWheelchairAccessible();
    /**
     * <code>optional .transit_realtime.VehicleDescriptor.WheelchairAccessible wheelchair_accessible = 4 [default = NO_VALUE];</code>
     * @return The wheelchairAccessible.
     */
    com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.WheelchairAccessible getWheelchairAccessible();
  }
  /**
   * <pre>
   * Identification information for the vehicle performing the trip.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.VehicleDescriptor}
   */
  public static final class VehicleDescriptor extends
      com.google.protobuf.GeneratedMessage.ExtendableMessage<
        VehicleDescriptor> implements
      // @@protoc_insertion_point(message_implements:transit_realtime.VehicleDescriptor)
      VehicleDescriptorOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 28,
        /* patch= */ 3,
        /* suffix= */ "",
        VehicleDescriptor.class.getName());
    }
    // Use VehicleDescriptor.newBuilder() to construct.
    private VehicleDescriptor(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.VehicleDescriptor, ?> builder) {
      super(builder);
    }
    private VehicleDescriptor() {
      id_ = "";
      label_ = "";
      licensePlate_ = "";
      wheelchairAccessible_ = 0;
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_VehicleDescriptor_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_VehicleDescriptor_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.class, com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.Builder.class);
    }

    /**
     * Protobuf enum {@code transit_realtime.VehicleDescriptor.WheelchairAccessible}
     */
    public enum WheelchairAccessible
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * The trip doesn't have information about wheelchair accessibility.
       * This is the **default** behavior. If the static GTFS contains a
       * _wheelchair_accessible_ value, it won't be overwritten.
       * </pre>
       *
       * <code>NO_VALUE = 0;</code>
       */
      NO_VALUE(0),
      /**
       * <pre>
       * The trip has no accessibility value present.
       * This value will overwrite the value from the GTFS.
       * </pre>
       *
       * <code>UNKNOWN = 1;</code>
       */
      UNKNOWN(1),
      /**
       * <pre>
       * The trip is wheelchair accessible.
       * This value will overwrite the value from the GTFS.
       * </pre>
       *
       * <code>WHEELCHAIR_ACCESSIBLE = 2;</code>
       */
      WHEELCHAIR_ACCESSIBLE(2),
      /**
       * <pre>
       * The trip is **not** wheelchair accessible.
       * This value will overwrite the value from the GTFS.
       * </pre>
       *
       * <code>WHEELCHAIR_INACCESSIBLE = 3;</code>
       */
      WHEELCHAIR_INACCESSIBLE(3),
      ;

      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 28,
          /* patch= */ 3,
          /* suffix= */ "",
          WheelchairAccessible.class.getName());
      }
      /**
       * <pre>
       * The trip doesn't have information about wheelchair accessibility.
       * This is the **default** behavior. If the static GTFS contains a
       * _wheelchair_accessible_ value, it won't be overwritten.
       * </pre>
       *
       * <code>NO_VALUE = 0;</code>
       */
      public static final int NO_VALUE_VALUE = 0;
      /**
       * <pre>
       * The trip has no accessibility value present.
       * This value will overwrite the value from the GTFS.
       * </pre>
       *
       * <code>UNKNOWN = 1;</code>
       */
      public static final int UNKNOWN_VALUE = 1;
      /**
       * <pre>
       * The trip is wheelchair accessible.
       * This value will overwrite the value from the GTFS.
       * </pre>
       *
       * <code>WHEELCHAIR_ACCESSIBLE = 2;</code>
       */
      public static final int WHEELCHAIR_ACCESSIBLE_VALUE = 2;
      /**
       * <pre>
       * The trip is **not** wheelchair accessible.
       * This value will overwrite the value from the GTFS.
       * </pre>
       *
       * <code>WHEELCHAIR_INACCESSIBLE = 3;</code>
       */
      public static final int WHEELCHAIR_INACCESSIBLE_VALUE = 3;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static WheelchairAccessible valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static WheelchairAccessible forNumber(int value) {
        switch (value) {
          case 0: return NO_VALUE;
          case 1: return UNKNOWN;
          case 2: return WHEELCHAIR_ACCESSIBLE;
          case 3: return WHEELCHAIR_INACCESSIBLE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<WheelchairAccessible>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          WheelchairAccessible> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<WheelchairAccessible>() {
              public WheelchairAccessible findValueByNumber(int number) {
                return WheelchairAccessible.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.getDescriptor().getEnumTypes().get(0);
      }

      private static final WheelchairAccessible[] VALUES = values();

      public static WheelchairAccessible valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private WheelchairAccessible(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_realtime.VehicleDescriptor.WheelchairAccessible)
    }

    private int bitField0_;
    public static final int ID_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object id_ = "";
    /**
     * <pre>
     * Internal system identification of the vehicle. Should be unique per
     * vehicle, and can be used for tracking the vehicle as it proceeds through
     * the system.
     * </pre>
     *
     * <code>optional string id = 1;</code>
     * @return Whether the id field is set.
     */
    @java.lang.Override
    public boolean hasId() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Internal system identification of the vehicle. Should be unique per
     * vehicle, and can be used for tracking the vehicle as it proceeds through
     * the system.
     * </pre>
     *
     * <code>optional string id = 1;</code>
     * @return The id.
     */
    @java.lang.Override
    public java.lang.String getId() {
      java.lang.Object ref = id_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          id_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Internal system identification of the vehicle. Should be unique per
     * vehicle, and can be used for tracking the vehicle as it proceeds through
     * the system.
     * </pre>
     *
     * <code>optional string id = 1;</code>
     * @return The bytes for id.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getIdBytes() {
      java.lang.Object ref = id_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        id_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int LABEL_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object label_ = "";
    /**
     * <pre>
     * User visible label, i.e., something that must be shown to the passenger to
     * help identify the correct vehicle.
     * </pre>
     *
     * <code>optional string label = 2;</code>
     * @return Whether the label field is set.
     */
    @java.lang.Override
    public boolean hasLabel() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * User visible label, i.e., something that must be shown to the passenger to
     * help identify the correct vehicle.
     * </pre>
     *
     * <code>optional string label = 2;</code>
     * @return The label.
     */
    @java.lang.Override
    public java.lang.String getLabel() {
      java.lang.Object ref = label_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          label_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * User visible label, i.e., something that must be shown to the passenger to
     * help identify the correct vehicle.
     * </pre>
     *
     * <code>optional string label = 2;</code>
     * @return The bytes for label.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLabelBytes() {
      java.lang.Object ref = label_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        label_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int LICENSE_PLATE_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object licensePlate_ = "";
    /**
     * <pre>
     * The license plate of the vehicle.
     * </pre>
     *
     * <code>optional string license_plate = 3;</code>
     * @return Whether the licensePlate field is set.
     */
    @java.lang.Override
    public boolean hasLicensePlate() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The license plate of the vehicle.
     * </pre>
     *
     * <code>optional string license_plate = 3;</code>
     * @return The licensePlate.
     */
    @java.lang.Override
    public java.lang.String getLicensePlate() {
      java.lang.Object ref = licensePlate_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          licensePlate_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The license plate of the vehicle.
     * </pre>
     *
     * <code>optional string license_plate = 3;</code>
     * @return The bytes for licensePlate.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLicensePlateBytes() {
      java.lang.Object ref = licensePlate_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        licensePlate_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int WHEELCHAIR_ACCESSIBLE_FIELD_NUMBER = 4;
    private int wheelchairAccessible_ = 0;
    /**
     * <code>optional .transit_realtime.VehicleDescriptor.WheelchairAccessible wheelchair_accessible = 4 [default = NO_VALUE];</code>
     * @return Whether the wheelchairAccessible field is set.
     */
    @java.lang.Override public boolean hasWheelchairAccessible() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional .transit_realtime.VehicleDescriptor.WheelchairAccessible wheelchair_accessible = 4 [default = NO_VALUE];</code>
     * @return The wheelchairAccessible.
     */
    @java.lang.Override public com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.WheelchairAccessible getWheelchairAccessible() {
      com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.WheelchairAccessible result = com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.WheelchairAccessible.forNumber(wheelchairAccessible_);
      return result == null ? com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.WheelchairAccessible.NO_VALUE : result;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!extensionsAreInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessage
        .ExtendableMessage.ExtensionSerializer
          extensionWriter = newExtensionSerializer();
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, id_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, label_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, licensePlate_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeEnum(4, wheelchairAccessible_);
      }
      extensionWriter.writeUntil(10000, output);
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, id_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, label_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, licensePlate_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(4, wheelchairAccessible_);
      }
      size += extensionsSerializedSize();
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.VehicleDescriptor)) {
        return super.equals(obj);
      }
      com.google.transit.realtime.GtfsRealtime.VehicleDescriptor other = (com.google.transit.realtime.GtfsRealtime.VehicleDescriptor) obj;

      if (hasId() != other.hasId()) return false;
      if (hasId()) {
        if (!getId()
            .equals(other.getId())) return false;
      }
      if (hasLabel() != other.hasLabel()) return false;
      if (hasLabel()) {
        if (!getLabel()
            .equals(other.getLabel())) return false;
      }
      if (hasLicensePlate() != other.hasLicensePlate()) return false;
      if (hasLicensePlate()) {
        if (!getLicensePlate()
            .equals(other.getLicensePlate())) return false;
      }
      if (hasWheelchairAccessible() != other.hasWheelchairAccessible()) return false;
      if (hasWheelchairAccessible()) {
        if (wheelchairAccessible_ != other.wheelchairAccessible_) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      if (!getExtensionFields().equals(other.getExtensionFields()))
        return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasId()) {
        hash = (37 * hash) + ID_FIELD_NUMBER;
        hash = (53 * hash) + getId().hashCode();
      }
      if (hasLabel()) {
        hash = (37 * hash) + LABEL_FIELD_NUMBER;
        hash = (53 * hash) + getLabel().hashCode();
      }
      if (hasLicensePlate()) {
        hash = (37 * hash) + LICENSE_PLATE_FIELD_NUMBER;
        hash = (53 * hash) + getLicensePlate().hashCode();
      }
      if (hasWheelchairAccessible()) {
        hash = (37 * hash) + WHEELCHAIR_ACCESSIBLE_FIELD_NUMBER;
        hash = (53 * hash) + wheelchairAccessible_;
      }
      hash = hashFields(hash, getExtensionFields());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.VehicleDescriptor prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Identification information for the vehicle performing the trip.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.VehicleDescriptor}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
          com.google.transit.realtime.GtfsRealtime.VehicleDescriptor, Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_realtime.VehicleDescriptor)
        com.google.transit.realtime.GtfsRealtime.VehicleDescriptorOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_VehicleDescriptor_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_VehicleDescriptor_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.class, com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.Builder.class);
      }

      // Construct using com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        id_ = "";
        label_ = "";
        licensePlate_ = "";
        wheelchairAccessible_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_VehicleDescriptor_descriptor;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.VehicleDescriptor getDefaultInstanceForType() {
        return com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.VehicleDescriptor build() {
        com.google.transit.realtime.GtfsRealtime.VehicleDescriptor result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.VehicleDescriptor buildPartial() {
        com.google.transit.realtime.GtfsRealtime.VehicleDescriptor result = new com.google.transit.realtime.GtfsRealtime.VehicleDescriptor(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.transit.realtime.GtfsRealtime.VehicleDescriptor result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.id_ = id_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.label_ = label_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.licensePlate_ = licensePlate_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.wheelchairAccessible_ = wheelchairAccessible_;
          to_bitField0_ |= 0x00000008;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.transit.realtime.GtfsRealtime.VehicleDescriptor) {
          return mergeFrom((com.google.transit.realtime.GtfsRealtime.VehicleDescriptor)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.VehicleDescriptor other) {
        if (other == com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.getDefaultInstance()) return this;
        if (other.hasId()) {
          id_ = other.id_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasLabel()) {
          label_ = other.label_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasLicensePlate()) {
          licensePlate_ = other.licensePlate_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (other.hasWheelchairAccessible()) {
          setWheelchairAccessible(other.getWheelchairAccessible());
        }
        this.mergeExtensionFields(other);
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!extensionsAreInitialized()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                id_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                label_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                licensePlate_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 32: {
                int tmpRaw = input.readEnum();
                com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.WheelchairAccessible tmpValue =
                    com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.WheelchairAccessible.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(4, tmpRaw);
                } else {
                  wheelchairAccessible_ = tmpRaw;
                  bitField0_ |= 0x00000008;
                }
                break;
              } // case 32
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object id_ = "";
      /**
       * <pre>
       * Internal system identification of the vehicle. Should be unique per
       * vehicle, and can be used for tracking the vehicle as it proceeds through
       * the system.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       * @return Whether the id field is set.
       */
      public boolean hasId() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Internal system identification of the vehicle. Should be unique per
       * vehicle, and can be used for tracking the vehicle as it proceeds through
       * the system.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       * @return The id.
       */
      public java.lang.String getId() {
        java.lang.Object ref = id_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            id_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Internal system identification of the vehicle. Should be unique per
       * vehicle, and can be used for tracking the vehicle as it proceeds through
       * the system.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       * @return The bytes for id.
       */
      public com.google.protobuf.ByteString
          getIdBytes() {
        java.lang.Object ref = id_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          id_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Internal system identification of the vehicle. Should be unique per
       * vehicle, and can be used for tracking the vehicle as it proceeds through
       * the system.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       * @param value The id to set.
       * @return This builder for chaining.
       */
      public Builder setId(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        id_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Internal system identification of the vehicle. Should be unique per
       * vehicle, and can be used for tracking the vehicle as it proceeds through
       * the system.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearId() {
        id_ = getDefaultInstance().getId();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Internal system identification of the vehicle. Should be unique per
       * vehicle, and can be used for tracking the vehicle as it proceeds through
       * the system.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       * @param value The bytes for id to set.
       * @return This builder for chaining.
       */
      public Builder setIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        id_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object label_ = "";
      /**
       * <pre>
       * User visible label, i.e., something that must be shown to the passenger to
       * help identify the correct vehicle.
       * </pre>
       *
       * <code>optional string label = 2;</code>
       * @return Whether the label field is set.
       */
      public boolean hasLabel() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * User visible label, i.e., something that must be shown to the passenger to
       * help identify the correct vehicle.
       * </pre>
       *
       * <code>optional string label = 2;</code>
       * @return The label.
       */
      public java.lang.String getLabel() {
        java.lang.Object ref = label_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            label_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * User visible label, i.e., something that must be shown to the passenger to
       * help identify the correct vehicle.
       * </pre>
       *
       * <code>optional string label = 2;</code>
       * @return The bytes for label.
       */
      public com.google.protobuf.ByteString
          getLabelBytes() {
        java.lang.Object ref = label_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          label_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * User visible label, i.e., something that must be shown to the passenger to
       * help identify the correct vehicle.
       * </pre>
       *
       * <code>optional string label = 2;</code>
       * @param value The label to set.
       * @return This builder for chaining.
       */
      public Builder setLabel(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        label_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * User visible label, i.e., something that must be shown to the passenger to
       * help identify the correct vehicle.
       * </pre>
       *
       * <code>optional string label = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearLabel() {
        label_ = getDefaultInstance().getLabel();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * User visible label, i.e., something that must be shown to the passenger to
       * help identify the correct vehicle.
       * </pre>
       *
       * <code>optional string label = 2;</code>
       * @param value The bytes for label to set.
       * @return This builder for chaining.
       */
      public Builder setLabelBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        label_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.lang.Object licensePlate_ = "";
      /**
       * <pre>
       * The license plate of the vehicle.
       * </pre>
       *
       * <code>optional string license_plate = 3;</code>
       * @return Whether the licensePlate field is set.
       */
      public boolean hasLicensePlate() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The license plate of the vehicle.
       * </pre>
       *
       * <code>optional string license_plate = 3;</code>
       * @return The licensePlate.
       */
      public java.lang.String getLicensePlate() {
        java.lang.Object ref = licensePlate_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            licensePlate_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The license plate of the vehicle.
       * </pre>
       *
       * <code>optional string license_plate = 3;</code>
       * @return The bytes for licensePlate.
       */
      public com.google.protobuf.ByteString
          getLicensePlateBytes() {
        java.lang.Object ref = licensePlate_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          licensePlate_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The license plate of the vehicle.
       * </pre>
       *
       * <code>optional string license_plate = 3;</code>
       * @param value The licensePlate to set.
       * @return This builder for chaining.
       */
      public Builder setLicensePlate(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        licensePlate_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The license plate of the vehicle.
       * </pre>
       *
       * <code>optional string license_plate = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearLicensePlate() {
        licensePlate_ = getDefaultInstance().getLicensePlate();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The license plate of the vehicle.
       * </pre>
       *
       * <code>optional string license_plate = 3;</code>
       * @param value The bytes for licensePlate to set.
       * @return This builder for chaining.
       */
      public Builder setLicensePlateBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        licensePlate_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private int wheelchairAccessible_ = 0;
      /**
       * <code>optional .transit_realtime.VehicleDescriptor.WheelchairAccessible wheelchair_accessible = 4 [default = NO_VALUE];</code>
       * @return Whether the wheelchairAccessible field is set.
       */
      @java.lang.Override public boolean hasWheelchairAccessible() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <code>optional .transit_realtime.VehicleDescriptor.WheelchairAccessible wheelchair_accessible = 4 [default = NO_VALUE];</code>
       * @return The wheelchairAccessible.
       */
      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.WheelchairAccessible getWheelchairAccessible() {
        com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.WheelchairAccessible result = com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.WheelchairAccessible.forNumber(wheelchairAccessible_);
        return result == null ? com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.WheelchairAccessible.NO_VALUE : result;
      }
      /**
       * <code>optional .transit_realtime.VehicleDescriptor.WheelchairAccessible wheelchair_accessible = 4 [default = NO_VALUE];</code>
       * @param value The wheelchairAccessible to set.
       * @return This builder for chaining.
       */
      public Builder setWheelchairAccessible(com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.WheelchairAccessible value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000008;
        wheelchairAccessible_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.VehicleDescriptor.WheelchairAccessible wheelchair_accessible = 4 [default = NO_VALUE];</code>
       * @return This builder for chaining.
       */
      public Builder clearWheelchairAccessible() {
        bitField0_ = (bitField0_ & ~0x00000008);
        wheelchairAccessible_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.VehicleDescriptor)
    }

    // @@protoc_insertion_point(class_scope:transit_realtime.VehicleDescriptor)
    private static final com.google.transit.realtime.GtfsRealtime.VehicleDescriptor DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.VehicleDescriptor();
    }

    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<VehicleDescriptor>
        PARSER = new com.google.protobuf.AbstractParser<VehicleDescriptor>() {
      @java.lang.Override
      public VehicleDescriptor parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<VehicleDescriptor> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<VehicleDescriptor> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.VehicleDescriptor getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface EntitySelectorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_realtime.EntitySelector)
      com.google.protobuf.GeneratedMessage.
          ExtendableMessageOrBuilder<EntitySelector> {

    /**
     * <pre>
     * The values of the fields should correspond to the appropriate fields in the
     * GTFS feed.
     * At least one specifier must be given. If several are given, then the
     * matching has to apply to all the given specifiers.
     * </pre>
     *
     * <code>optional string agency_id = 1;</code>
     * @return Whether the agencyId field is set.
     */
    boolean hasAgencyId();
    /**
     * <pre>
     * The values of the fields should correspond to the appropriate fields in the
     * GTFS feed.
     * At least one specifier must be given. If several are given, then the
     * matching has to apply to all the given specifiers.
     * </pre>
     *
     * <code>optional string agency_id = 1;</code>
     * @return The agencyId.
     */
    java.lang.String getAgencyId();
    /**
     * <pre>
     * The values of the fields should correspond to the appropriate fields in the
     * GTFS feed.
     * At least one specifier must be given. If several are given, then the
     * matching has to apply to all the given specifiers.
     * </pre>
     *
     * <code>optional string agency_id = 1;</code>
     * @return The bytes for agencyId.
     */
    com.google.protobuf.ByteString
        getAgencyIdBytes();

    /**
     * <code>optional string route_id = 2;</code>
     * @return Whether the routeId field is set.
     */
    boolean hasRouteId();
    /**
     * <code>optional string route_id = 2;</code>
     * @return The routeId.
     */
    java.lang.String getRouteId();
    /**
     * <code>optional string route_id = 2;</code>
     * @return The bytes for routeId.
     */
    com.google.protobuf.ByteString
        getRouteIdBytes();

    /**
     * <pre>
     * corresponds to route_type in GTFS.
     * </pre>
     *
     * <code>optional int32 route_type = 3;</code>
     * @return Whether the routeType field is set.
     */
    boolean hasRouteType();
    /**
     * <pre>
     * corresponds to route_type in GTFS.
     * </pre>
     *
     * <code>optional int32 route_type = 3;</code>
     * @return The routeType.
     */
    int getRouteType();

    /**
     * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
     * @return Whether the trip field is set.
     */
    boolean hasTrip();
    /**
     * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
     * @return The trip.
     */
    com.google.transit.realtime.GtfsRealtime.TripDescriptor getTrip();
    /**
     * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TripDescriptorOrBuilder getTripOrBuilder();

    /**
     * <code>optional string stop_id = 5;</code>
     * @return Whether the stopId field is set.
     */
    boolean hasStopId();
    /**
     * <code>optional string stop_id = 5;</code>
     * @return The stopId.
     */
    java.lang.String getStopId();
    /**
     * <code>optional string stop_id = 5;</code>
     * @return The bytes for stopId.
     */
    com.google.protobuf.ByteString
        getStopIdBytes();

    /**
     * <pre>
     * Corresponds to trip direction_id in GTFS trips.txt. If provided the
     * route_id must also be provided.
     * </pre>
     *
     * <code>optional uint32 direction_id = 6;</code>
     * @return Whether the directionId field is set.
     */
    boolean hasDirectionId();
    /**
     * <pre>
     * Corresponds to trip direction_id in GTFS trips.txt. If provided the
     * route_id must also be provided.
     * </pre>
     *
     * <code>optional uint32 direction_id = 6;</code>
     * @return The directionId.
     */
    int getDirectionId();
  }
  /**
   * <pre>
   * A selector for an entity in a GTFS feed.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.EntitySelector}
   */
  public static final class EntitySelector extends
      com.google.protobuf.GeneratedMessage.ExtendableMessage<
        EntitySelector> implements
      // @@protoc_insertion_point(message_implements:transit_realtime.EntitySelector)
      EntitySelectorOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 28,
        /* patch= */ 3,
        /* suffix= */ "",
        EntitySelector.class.getName());
    }
    // Use EntitySelector.newBuilder() to construct.
    private EntitySelector(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.EntitySelector, ?> builder) {
      super(builder);
    }
    private EntitySelector() {
      agencyId_ = "";
      routeId_ = "";
      stopId_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_EntitySelector_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_EntitySelector_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.transit.realtime.GtfsRealtime.EntitySelector.class, com.google.transit.realtime.GtfsRealtime.EntitySelector.Builder.class);
    }

    private int bitField0_;
    public static final int AGENCY_ID_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object agencyId_ = "";
    /**
     * <pre>
     * The values of the fields should correspond to the appropriate fields in the
     * GTFS feed.
     * At least one specifier must be given. If several are given, then the
     * matching has to apply to all the given specifiers.
     * </pre>
     *
     * <code>optional string agency_id = 1;</code>
     * @return Whether the agencyId field is set.
     */
    @java.lang.Override
    public boolean hasAgencyId() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The values of the fields should correspond to the appropriate fields in the
     * GTFS feed.
     * At least one specifier must be given. If several are given, then the
     * matching has to apply to all the given specifiers.
     * </pre>
     *
     * <code>optional string agency_id = 1;</code>
     * @return The agencyId.
     */
    @java.lang.Override
    public java.lang.String getAgencyId() {
      java.lang.Object ref = agencyId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          agencyId_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The values of the fields should correspond to the appropriate fields in the
     * GTFS feed.
     * At least one specifier must be given. If several are given, then the
     * matching has to apply to all the given specifiers.
     * </pre>
     *
     * <code>optional string agency_id = 1;</code>
     * @return The bytes for agencyId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAgencyIdBytes() {
      java.lang.Object ref = agencyId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        agencyId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ROUTE_ID_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object routeId_ = "";
    /**
     * <code>optional string route_id = 2;</code>
     * @return Whether the routeId field is set.
     */
    @java.lang.Override
    public boolean hasRouteId() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional string route_id = 2;</code>
     * @return The routeId.
     */
    @java.lang.Override
    public java.lang.String getRouteId() {
      java.lang.Object ref = routeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          routeId_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string route_id = 2;</code>
     * @return The bytes for routeId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRouteIdBytes() {
      java.lang.Object ref = routeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        routeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ROUTE_TYPE_FIELD_NUMBER = 3;
    private int routeType_ = 0;
    /**
     * <pre>
     * corresponds to route_type in GTFS.
     * </pre>
     *
     * <code>optional int32 route_type = 3;</code>
     * @return Whether the routeType field is set.
     */
    @java.lang.Override
    public boolean hasRouteType() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * corresponds to route_type in GTFS.
     * </pre>
     *
     * <code>optional int32 route_type = 3;</code>
     * @return The routeType.
     */
    @java.lang.Override
    public int getRouteType() {
      return routeType_;
    }

    public static final int TRIP_FIELD_NUMBER = 4;
    private com.google.transit.realtime.GtfsRealtime.TripDescriptor trip_;
    /**
     * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
     * @return Whether the trip field is set.
     */
    @java.lang.Override
    public boolean hasTrip() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
     * @return The trip.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripDescriptor getTrip() {
      return trip_ == null ? com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance() : trip_;
    }
    /**
     * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripDescriptorOrBuilder getTripOrBuilder() {
      return trip_ == null ? com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance() : trip_;
    }

    public static final int STOP_ID_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private volatile java.lang.Object stopId_ = "";
    /**
     * <code>optional string stop_id = 5;</code>
     * @return Whether the stopId field is set.
     */
    @java.lang.Override
    public boolean hasStopId() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <code>optional string stop_id = 5;</code>
     * @return The stopId.
     */
    @java.lang.Override
    public java.lang.String getStopId() {
      java.lang.Object ref = stopId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          stopId_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string stop_id = 5;</code>
     * @return The bytes for stopId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStopIdBytes() {
      java.lang.Object ref = stopId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        stopId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DIRECTION_ID_FIELD_NUMBER = 6;
    private int directionId_ = 0;
    /**
     * <pre>
     * Corresponds to trip direction_id in GTFS trips.txt. If provided the
     * route_id must also be provided.
     * </pre>
     *
     * <code>optional uint32 direction_id = 6;</code>
     * @return Whether the directionId field is set.
     */
    @java.lang.Override
    public boolean hasDirectionId() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Corresponds to trip direction_id in GTFS trips.txt. If provided the
     * route_id must also be provided.
     * </pre>
     *
     * <code>optional uint32 direction_id = 6;</code>
     * @return The directionId.
     */
    @java.lang.Override
    public int getDirectionId() {
      return directionId_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (hasTrip()) {
        if (!getTrip().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (!extensionsAreInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessage
        .ExtendableMessage.ExtensionSerializer
          extensionWriter = newExtensionSerializer();
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, agencyId_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, routeId_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeInt32(3, routeType_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(4, getTrip());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 5, stopId_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeUInt32(6, directionId_);
      }
      extensionWriter.writeUntil(10000, output);
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, agencyId_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, routeId_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(3, routeType_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getTrip());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(5, stopId_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(6, directionId_);
      }
      size += extensionsSerializedSize();
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.EntitySelector)) {
        return super.equals(obj);
      }
      com.google.transit.realtime.GtfsRealtime.EntitySelector other = (com.google.transit.realtime.GtfsRealtime.EntitySelector) obj;

      if (hasAgencyId() != other.hasAgencyId()) return false;
      if (hasAgencyId()) {
        if (!getAgencyId()
            .equals(other.getAgencyId())) return false;
      }
      if (hasRouteId() != other.hasRouteId()) return false;
      if (hasRouteId()) {
        if (!getRouteId()
            .equals(other.getRouteId())) return false;
      }
      if (hasRouteType() != other.hasRouteType()) return false;
      if (hasRouteType()) {
        if (getRouteType()
            != other.getRouteType()) return false;
      }
      if (hasTrip() != other.hasTrip()) return false;
      if (hasTrip()) {
        if (!getTrip()
            .equals(other.getTrip())) return false;
      }
      if (hasStopId() != other.hasStopId()) return false;
      if (hasStopId()) {
        if (!getStopId()
            .equals(other.getStopId())) return false;
      }
      if (hasDirectionId() != other.hasDirectionId()) return false;
      if (hasDirectionId()) {
        if (getDirectionId()
            != other.getDirectionId()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      if (!getExtensionFields().equals(other.getExtensionFields()))
        return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasAgencyId()) {
        hash = (37 * hash) + AGENCY_ID_FIELD_NUMBER;
        hash = (53 * hash) + getAgencyId().hashCode();
      }
      if (hasRouteId()) {
        hash = (37 * hash) + ROUTE_ID_FIELD_NUMBER;
        hash = (53 * hash) + getRouteId().hashCode();
      }
      if (hasRouteType()) {
        hash = (37 * hash) + ROUTE_TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getRouteType();
      }
      if (hasTrip()) {
        hash = (37 * hash) + TRIP_FIELD_NUMBER;
        hash = (53 * hash) + getTrip().hashCode();
      }
      if (hasStopId()) {
        hash = (37 * hash) + STOP_ID_FIELD_NUMBER;
        hash = (53 * hash) + getStopId().hashCode();
      }
      if (hasDirectionId()) {
        hash = (37 * hash) + DIRECTION_ID_FIELD_NUMBER;
        hash = (53 * hash) + getDirectionId();
      }
      hash = hashFields(hash, getExtensionFields());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.transit.realtime.GtfsRealtime.EntitySelector parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.EntitySelector parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.EntitySelector parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.EntitySelector parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.EntitySelector parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.EntitySelector parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.EntitySelector parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.EntitySelector parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.transit.realtime.GtfsRealtime.EntitySelector parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.transit.realtime.GtfsRealtime.EntitySelector parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.EntitySelector parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.EntitySelector parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.EntitySelector prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * A selector for an entity in a GTFS feed.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.EntitySelector}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
          com.google.transit.realtime.GtfsRealtime.EntitySelector, Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_realtime.EntitySelector)
        com.google.transit.realtime.GtfsRealtime.EntitySelectorOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_EntitySelector_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_EntitySelector_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.EntitySelector.class, com.google.transit.realtime.GtfsRealtime.EntitySelector.Builder.class);
      }

      // Construct using com.google.transit.realtime.GtfsRealtime.EntitySelector.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getTripFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        agencyId_ = "";
        routeId_ = "";
        routeType_ = 0;
        trip_ = null;
        if (tripBuilder_ != null) {
          tripBuilder_.dispose();
          tripBuilder_ = null;
        }
        stopId_ = "";
        directionId_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_EntitySelector_descriptor;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.EntitySelector getDefaultInstanceForType() {
        return com.google.transit.realtime.GtfsRealtime.EntitySelector.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.EntitySelector build() {
        com.google.transit.realtime.GtfsRealtime.EntitySelector result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.EntitySelector buildPartial() {
        com.google.transit.realtime.GtfsRealtime.EntitySelector result = new com.google.transit.realtime.GtfsRealtime.EntitySelector(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.transit.realtime.GtfsRealtime.EntitySelector result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.agencyId_ = agencyId_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.routeId_ = routeId_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.routeType_ = routeType_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.trip_ = tripBuilder_ == null
              ? trip_
              : tripBuilder_.build();
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.stopId_ = stopId_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.directionId_ = directionId_;
          to_bitField0_ |= 0x00000020;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.transit.realtime.GtfsRealtime.EntitySelector) {
          return mergeFrom((com.google.transit.realtime.GtfsRealtime.EntitySelector)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.EntitySelector other) {
        if (other == com.google.transit.realtime.GtfsRealtime.EntitySelector.getDefaultInstance()) return this;
        if (other.hasAgencyId()) {
          agencyId_ = other.agencyId_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasRouteId()) {
          routeId_ = other.routeId_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasRouteType()) {
          setRouteType(other.getRouteType());
        }
        if (other.hasTrip()) {
          mergeTrip(other.getTrip());
        }
        if (other.hasStopId()) {
          stopId_ = other.stopId_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (other.hasDirectionId()) {
          setDirectionId(other.getDirectionId());
        }
        this.mergeExtensionFields(other);
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (hasTrip()) {
          if (!getTrip().isInitialized()) {
            return false;
          }
        }
        if (!extensionsAreInitialized()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                agencyId_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                routeId_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 24: {
                routeType_ = input.readInt32();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 34: {
                input.readMessage(
                    getTripFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                stopId_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              case 48: {
                directionId_ = input.readUInt32();
                bitField0_ |= 0x00000020;
                break;
              } // case 48
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object agencyId_ = "";
      /**
       * <pre>
       * The values of the fields should correspond to the appropriate fields in the
       * GTFS feed.
       * At least one specifier must be given. If several are given, then the
       * matching has to apply to all the given specifiers.
       * </pre>
       *
       * <code>optional string agency_id = 1;</code>
       * @return Whether the agencyId field is set.
       */
      public boolean hasAgencyId() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The values of the fields should correspond to the appropriate fields in the
       * GTFS feed.
       * At least one specifier must be given. If several are given, then the
       * matching has to apply to all the given specifiers.
       * </pre>
       *
       * <code>optional string agency_id = 1;</code>
       * @return The agencyId.
       */
      public java.lang.String getAgencyId() {
        java.lang.Object ref = agencyId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            agencyId_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The values of the fields should correspond to the appropriate fields in the
       * GTFS feed.
       * At least one specifier must be given. If several are given, then the
       * matching has to apply to all the given specifiers.
       * </pre>
       *
       * <code>optional string agency_id = 1;</code>
       * @return The bytes for agencyId.
       */
      public com.google.protobuf.ByteString
          getAgencyIdBytes() {
        java.lang.Object ref = agencyId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          agencyId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The values of the fields should correspond to the appropriate fields in the
       * GTFS feed.
       * At least one specifier must be given. If several are given, then the
       * matching has to apply to all the given specifiers.
       * </pre>
       *
       * <code>optional string agency_id = 1;</code>
       * @param value The agencyId to set.
       * @return This builder for chaining.
       */
      public Builder setAgencyId(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        agencyId_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The values of the fields should correspond to the appropriate fields in the
       * GTFS feed.
       * At least one specifier must be given. If several are given, then the
       * matching has to apply to all the given specifiers.
       * </pre>
       *
       * <code>optional string agency_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearAgencyId() {
        agencyId_ = getDefaultInstance().getAgencyId();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The values of the fields should correspond to the appropriate fields in the
       * GTFS feed.
       * At least one specifier must be given. If several are given, then the
       * matching has to apply to all the given specifiers.
       * </pre>
       *
       * <code>optional string agency_id = 1;</code>
       * @param value The bytes for agencyId to set.
       * @return This builder for chaining.
       */
      public Builder setAgencyIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        agencyId_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object routeId_ = "";
      /**
       * <code>optional string route_id = 2;</code>
       * @return Whether the routeId field is set.
       */
      public boolean hasRouteId() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional string route_id = 2;</code>
       * @return The routeId.
       */
      public java.lang.String getRouteId() {
        java.lang.Object ref = routeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            routeId_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string route_id = 2;</code>
       * @return The bytes for routeId.
       */
      public com.google.protobuf.ByteString
          getRouteIdBytes() {
        java.lang.Object ref = routeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          routeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string route_id = 2;</code>
       * @param value The routeId to set.
       * @return This builder for chaining.
       */
      public Builder setRouteId(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        routeId_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional string route_id = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearRouteId() {
        routeId_ = getDefaultInstance().getRouteId();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <code>optional string route_id = 2;</code>
       * @param value The bytes for routeId to set.
       * @return This builder for chaining.
       */
      public Builder setRouteIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        routeId_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private int routeType_ ;
      /**
       * <pre>
       * corresponds to route_type in GTFS.
       * </pre>
       *
       * <code>optional int32 route_type = 3;</code>
       * @return Whether the routeType field is set.
       */
      @java.lang.Override
      public boolean hasRouteType() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * corresponds to route_type in GTFS.
       * </pre>
       *
       * <code>optional int32 route_type = 3;</code>
       * @return The routeType.
       */
      @java.lang.Override
      public int getRouteType() {
        return routeType_;
      }
      /**
       * <pre>
       * corresponds to route_type in GTFS.
       * </pre>
       *
       * <code>optional int32 route_type = 3;</code>
       * @param value The routeType to set.
       * @return This builder for chaining.
       */
      public Builder setRouteType(int value) {

        routeType_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * corresponds to route_type in GTFS.
       * </pre>
       *
       * <code>optional int32 route_type = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearRouteType() {
        bitField0_ = (bitField0_ & ~0x00000004);
        routeType_ = 0;
        onChanged();
        return this;
      }

      private com.google.transit.realtime.GtfsRealtime.TripDescriptor trip_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TripDescriptor, com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder, com.google.transit.realtime.GtfsRealtime.TripDescriptorOrBuilder> tripBuilder_;
      /**
       * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
       * @return Whether the trip field is set.
       */
      public boolean hasTrip() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
       * @return The trip.
       */
      public com.google.transit.realtime.GtfsRealtime.TripDescriptor getTrip() {
        if (tripBuilder_ == null) {
          return trip_ == null ? com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance() : trip_;
        } else {
          return tripBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
       */
      public Builder setTrip(com.google.transit.realtime.GtfsRealtime.TripDescriptor value) {
        if (tripBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          trip_ = value;
        } else {
          tripBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
       */
      public Builder setTrip(
          com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder builderForValue) {
        if (tripBuilder_ == null) {
          trip_ = builderForValue.build();
        } else {
          tripBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
       */
      public Builder mergeTrip(com.google.transit.realtime.GtfsRealtime.TripDescriptor value) {
        if (tripBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0) &&
            trip_ != null &&
            trip_ != com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance()) {
            getTripBuilder().mergeFrom(value);
          } else {
            trip_ = value;
          }
        } else {
          tripBuilder_.mergeFrom(value);
        }
        if (trip_ != null) {
          bitField0_ |= 0x00000008;
          onChanged();
        }
        return this;
      }
      /**
       * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
       */
      public Builder clearTrip() {
        bitField0_ = (bitField0_ & ~0x00000008);
        trip_ = null;
        if (tripBuilder_ != null) {
          tripBuilder_.dispose();
          tripBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder getTripBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getTripFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripDescriptorOrBuilder getTripOrBuilder() {
        if (tripBuilder_ != null) {
          return tripBuilder_.getMessageOrBuilder();
        } else {
          return trip_ == null ?
              com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance() : trip_;
        }
      }
      /**
       * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TripDescriptor, com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder, com.google.transit.realtime.GtfsRealtime.TripDescriptorOrBuilder> 
          getTripFieldBuilder() {
        if (tripBuilder_ == null) {
          tripBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TripDescriptor, com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder, com.google.transit.realtime.GtfsRealtime.TripDescriptorOrBuilder>(
                  getTrip(),
                  getParentForChildren(),
                  isClean());
          trip_ = null;
        }
        return tripBuilder_;
      }

      private java.lang.Object stopId_ = "";
      /**
       * <code>optional string stop_id = 5;</code>
       * @return Whether the stopId field is set.
       */
      public boolean hasStopId() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <code>optional string stop_id = 5;</code>
       * @return The stopId.
       */
      public java.lang.String getStopId() {
        java.lang.Object ref = stopId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            stopId_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string stop_id = 5;</code>
       * @return The bytes for stopId.
       */
      public com.google.protobuf.ByteString
          getStopIdBytes() {
        java.lang.Object ref = stopId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          stopId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string stop_id = 5;</code>
       * @param value The stopId to set.
       * @return This builder for chaining.
       */
      public Builder setStopId(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        stopId_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <code>optional string stop_id = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearStopId() {
        stopId_ = getDefaultInstance().getStopId();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <code>optional string stop_id = 5;</code>
       * @param value The bytes for stopId to set.
       * @return This builder for chaining.
       */
      public Builder setStopIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        stopId_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private int directionId_ ;
      /**
       * <pre>
       * Corresponds to trip direction_id in GTFS trips.txt. If provided the
       * route_id must also be provided.
       * </pre>
       *
       * <code>optional uint32 direction_id = 6;</code>
       * @return Whether the directionId field is set.
       */
      @java.lang.Override
      public boolean hasDirectionId() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Corresponds to trip direction_id in GTFS trips.txt. If provided the
       * route_id must also be provided.
       * </pre>
       *
       * <code>optional uint32 direction_id = 6;</code>
       * @return The directionId.
       */
      @java.lang.Override
      public int getDirectionId() {
        return directionId_;
      }
      /**
       * <pre>
       * Corresponds to trip direction_id in GTFS trips.txt. If provided the
       * route_id must also be provided.
       * </pre>
       *
       * <code>optional uint32 direction_id = 6;</code>
       * @param value The directionId to set.
       * @return This builder for chaining.
       */
      public Builder setDirectionId(int value) {

        directionId_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Corresponds to trip direction_id in GTFS trips.txt. If provided the
       * route_id must also be provided.
       * </pre>
       *
       * <code>optional uint32 direction_id = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearDirectionId() {
        bitField0_ = (bitField0_ & ~0x00000020);
        directionId_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.EntitySelector)
    }

    // @@protoc_insertion_point(class_scope:transit_realtime.EntitySelector)
    private static final com.google.transit.realtime.GtfsRealtime.EntitySelector DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.EntitySelector();
    }

    public static com.google.transit.realtime.GtfsRealtime.EntitySelector getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<EntitySelector>
        PARSER = new com.google.protobuf.AbstractParser<EntitySelector>() {
      @java.lang.Override
      public EntitySelector parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<EntitySelector> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<EntitySelector> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.EntitySelector getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TranslatedStringOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_realtime.TranslatedString)
      com.google.protobuf.GeneratedMessage.
          ExtendableMessageOrBuilder<TranslatedString> {

    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    java.util.List<com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation> 
        getTranslationList();
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation getTranslation(int index);
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    int getTranslationCount();
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    java.util.List<? extends com.google.transit.realtime.GtfsRealtime.TranslatedString.TranslationOrBuilder> 
        getTranslationOrBuilderList();
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedString.TranslationOrBuilder getTranslationOrBuilder(
        int index);
  }
  /**
   * <pre>
   * An internationalized message containing per-language versions of a snippet of
   * text or a URL.
   * One of the strings from a message will be picked up. The resolution proceeds
   * as follows:
   * 1. If the UI language matches the language code of a translation,
   * the first matching translation is picked.
   * 2. If a default UI language (e.g., English) matches the language code of a
   * translation, the first matching translation is picked.
   * 3. If some translation has an unspecified language code, that translation is
   * picked.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.TranslatedString}
   */
  public static final class TranslatedString extends
      com.google.protobuf.GeneratedMessage.ExtendableMessage<
        TranslatedString> implements
      // @@protoc_insertion_point(message_implements:transit_realtime.TranslatedString)
      TranslatedStringOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 28,
        /* patch= */ 3,
        /* suffix= */ "",
        TranslatedString.class.getName());
    }
    // Use TranslatedString.newBuilder() to construct.
    private TranslatedString(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.TranslatedString, ?> builder) {
      super(builder);
    }
    private TranslatedString() {
      translation_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TranslatedString_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TranslatedString_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.transit.realtime.GtfsRealtime.TranslatedString.class, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder.class);
    }

    public interface TranslationOrBuilder extends
        // @@protoc_insertion_point(interface_extends:transit_realtime.TranslatedString.Translation)
        com.google.protobuf.GeneratedMessage.
            ExtendableMessageOrBuilder<Translation> {

      /**
       * <pre>
       * A UTF-8 string containing the message.
       * </pre>
       *
       * <code>required string text = 1;</code>
       * @return Whether the text field is set.
       */
      boolean hasText();
      /**
       * <pre>
       * A UTF-8 string containing the message.
       * </pre>
       *
       * <code>required string text = 1;</code>
       * @return The text.
       */
      java.lang.String getText();
      /**
       * <pre>
       * A UTF-8 string containing the message.
       * </pre>
       *
       * <code>required string text = 1;</code>
       * @return The bytes for text.
       */
      com.google.protobuf.ByteString
          getTextBytes();

      /**
       * <pre>
       * BCP-47 language code. Can be omitted if the language is unknown or if
       * no i18n is done at all for the feed. At most one translation is
       * allowed to have an unspecified language tag.
       * </pre>
       *
       * <code>optional string language = 2;</code>
       * @return Whether the language field is set.
       */
      boolean hasLanguage();
      /**
       * <pre>
       * BCP-47 language code. Can be omitted if the language is unknown or if
       * no i18n is done at all for the feed. At most one translation is
       * allowed to have an unspecified language tag.
       * </pre>
       *
       * <code>optional string language = 2;</code>
       * @return The language.
       */
      java.lang.String getLanguage();
      /**
       * <pre>
       * BCP-47 language code. Can be omitted if the language is unknown or if
       * no i18n is done at all for the feed. At most one translation is
       * allowed to have an unspecified language tag.
       * </pre>
       *
       * <code>optional string language = 2;</code>
       * @return The bytes for language.
       */
      com.google.protobuf.ByteString
          getLanguageBytes();
    }
    /**
     * Protobuf type {@code transit_realtime.TranslatedString.Translation}
     */
    public static final class Translation extends
        com.google.protobuf.GeneratedMessage.ExtendableMessage<
          Translation> implements
        // @@protoc_insertion_point(message_implements:transit_realtime.TranslatedString.Translation)
        TranslationOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 28,
          /* patch= */ 3,
          /* suffix= */ "",
          Translation.class.getName());
      }
      // Use Translation.newBuilder() to construct.
      private Translation(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation, ?> builder) {
        super(builder);
      }
      private Translation() {
        text_ = "";
        language_ = "";
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TranslatedString_Translation_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TranslatedString_Translation_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.class, com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.Builder.class);
      }

      private int bitField0_;
      public static final int TEXT_FIELD_NUMBER = 1;
      @SuppressWarnings("serial")
      private volatile java.lang.Object text_ = "";
      /**
       * <pre>
       * A UTF-8 string containing the message.
       * </pre>
       *
       * <code>required string text = 1;</code>
       * @return Whether the text field is set.
       */
      @java.lang.Override
      public boolean hasText() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * A UTF-8 string containing the message.
       * </pre>
       *
       * <code>required string text = 1;</code>
       * @return The text.
       */
      @java.lang.Override
      public java.lang.String getText() {
        java.lang.Object ref = text_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            text_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * A UTF-8 string containing the message.
       * </pre>
       *
       * <code>required string text = 1;</code>
       * @return The bytes for text.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getTextBytes() {
        java.lang.Object ref = text_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          text_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int LANGUAGE_FIELD_NUMBER = 2;
      @SuppressWarnings("serial")
      private volatile java.lang.Object language_ = "";
      /**
       * <pre>
       * BCP-47 language code. Can be omitted if the language is unknown or if
       * no i18n is done at all for the feed. At most one translation is
       * allowed to have an unspecified language tag.
       * </pre>
       *
       * <code>optional string language = 2;</code>
       * @return Whether the language field is set.
       */
      @java.lang.Override
      public boolean hasLanguage() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * BCP-47 language code. Can be omitted if the language is unknown or if
       * no i18n is done at all for the feed. At most one translation is
       * allowed to have an unspecified language tag.
       * </pre>
       *
       * <code>optional string language = 2;</code>
       * @return The language.
       */
      @java.lang.Override
      public java.lang.String getLanguage() {
        java.lang.Object ref = language_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            language_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * BCP-47 language code. Can be omitted if the language is unknown or if
       * no i18n is done at all for the feed. At most one translation is
       * allowed to have an unspecified language tag.
       * </pre>
       *
       * <code>optional string language = 2;</code>
       * @return The bytes for language.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getLanguageBytes() {
        java.lang.Object ref = language_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          language_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        if (!hasText()) {
          memoizedIsInitialized = 0;
          return false;
        }
        if (!extensionsAreInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        com.google.protobuf.GeneratedMessage
          .ExtendableMessage.ExtensionSerializer
            extensionWriter = newExtensionSerializer();
        if (((bitField0_ & 0x00000001) != 0)) {
          com.google.protobuf.GeneratedMessage.writeString(output, 1, text_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          com.google.protobuf.GeneratedMessage.writeString(output, 2, language_);
        }
        extensionWriter.writeUntil(10000, output);
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.GeneratedMessage.computeStringSize(1, text_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.GeneratedMessage.computeStringSize(2, language_);
        }
        size += extensionsSerializedSize();
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation)) {
          return super.equals(obj);
        }
        com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation other = (com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation) obj;

        if (hasText() != other.hasText()) return false;
        if (hasText()) {
          if (!getText()
              .equals(other.getText())) return false;
        }
        if (hasLanguage() != other.hasLanguage()) return false;
        if (hasLanguage()) {
          if (!getLanguage()
              .equals(other.getLanguage())) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        if (!getExtensionFields().equals(other.getExtensionFields()))
          return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasText()) {
          hash = (37 * hash) + TEXT_FIELD_NUMBER;
          hash = (53 * hash) + getText().hashCode();
        }
        if (hasLanguage()) {
          hash = (37 * hash) + LANGUAGE_FIELD_NUMBER;
          hash = (53 * hash) + getLanguage().hashCode();
        }
        hash = hashFields(hash, getExtensionFields());
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code transit_realtime.TranslatedString.Translation}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.ExtendableBuilder<
            com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation, Builder> implements
          // @@protoc_insertion_point(builder_implements:transit_realtime.TranslatedString.Translation)
          com.google.transit.realtime.GtfsRealtime.TranslatedString.TranslationOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TranslatedString_Translation_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TranslatedString_Translation_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.class, com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.Builder.class);
        }

        // Construct using com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          text_ = "";
          language_ = "";
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TranslatedString_Translation_descriptor;
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation getDefaultInstanceForType() {
          return com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.getDefaultInstance();
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation build() {
          com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation buildPartial() {
          com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation result = new com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.text_ = text_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.language_ = language_;
            to_bitField0_ |= 0x00000002;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation) {
            return mergeFrom((com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation other) {
          if (other == com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.getDefaultInstance()) return this;
          if (other.hasText()) {
            text_ = other.text_;
            bitField0_ |= 0x00000001;
            onChanged();
          }
          if (other.hasLanguage()) {
            language_ = other.language_;
            bitField0_ |= 0x00000002;
            onChanged();
          }
          this.mergeExtensionFields(other);
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          if (!hasText()) {
            return false;
          }
          if (!extensionsAreInitialized()) {
            return false;
          }
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 10: {
                  text_ = input.readBytes();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
                case 18: {
                  language_ = input.readBytes();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private java.lang.Object text_ = "";
        /**
         * <pre>
         * A UTF-8 string containing the message.
         * </pre>
         *
         * <code>required string text = 1;</code>
         * @return Whether the text field is set.
         */
        public boolean hasText() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * A UTF-8 string containing the message.
         * </pre>
         *
         * <code>required string text = 1;</code>
         * @return The text.
         */
        public java.lang.String getText() {
          java.lang.Object ref = text_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              text_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * A UTF-8 string containing the message.
         * </pre>
         *
         * <code>required string text = 1;</code>
         * @return The bytes for text.
         */
        public com.google.protobuf.ByteString
            getTextBytes() {
          java.lang.Object ref = text_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            text_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * A UTF-8 string containing the message.
         * </pre>
         *
         * <code>required string text = 1;</code>
         * @param value The text to set.
         * @return This builder for chaining.
         */
        public Builder setText(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          text_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * A UTF-8 string containing the message.
         * </pre>
         *
         * <code>required string text = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearText() {
          text_ = getDefaultInstance().getText();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * A UTF-8 string containing the message.
         * </pre>
         *
         * <code>required string text = 1;</code>
         * @param value The bytes for text to set.
         * @return This builder for chaining.
         */
        public Builder setTextBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          text_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }

        private java.lang.Object language_ = "";
        /**
         * <pre>
         * BCP-47 language code. Can be omitted if the language is unknown or if
         * no i18n is done at all for the feed. At most one translation is
         * allowed to have an unspecified language tag.
         * </pre>
         *
         * <code>optional string language = 2;</code>
         * @return Whether the language field is set.
         */
        public boolean hasLanguage() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * BCP-47 language code. Can be omitted if the language is unknown or if
         * no i18n is done at all for the feed. At most one translation is
         * allowed to have an unspecified language tag.
         * </pre>
         *
         * <code>optional string language = 2;</code>
         * @return The language.
         */
        public java.lang.String getLanguage() {
          java.lang.Object ref = language_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              language_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * BCP-47 language code. Can be omitted if the language is unknown or if
         * no i18n is done at all for the feed. At most one translation is
         * allowed to have an unspecified language tag.
         * </pre>
         *
         * <code>optional string language = 2;</code>
         * @return The bytes for language.
         */
        public com.google.protobuf.ByteString
            getLanguageBytes() {
          java.lang.Object ref = language_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            language_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * BCP-47 language code. Can be omitted if the language is unknown or if
         * no i18n is done at all for the feed. At most one translation is
         * allowed to have an unspecified language tag.
         * </pre>
         *
         * <code>optional string language = 2;</code>
         * @param value The language to set.
         * @return This builder for chaining.
         */
        public Builder setLanguage(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          language_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * BCP-47 language code. Can be omitted if the language is unknown or if
         * no i18n is done at all for the feed. At most one translation is
         * allowed to have an unspecified language tag.
         * </pre>
         *
         * <code>optional string language = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearLanguage() {
          language_ = getDefaultInstance().getLanguage();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * BCP-47 language code. Can be omitted if the language is unknown or if
         * no i18n is done at all for the feed. At most one translation is
         * allowed to have an unspecified language tag.
         * </pre>
         *
         * <code>optional string language = 2;</code>
         * @param value The bytes for language to set.
         * @return This builder for chaining.
         */
        public Builder setLanguageBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          language_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:transit_realtime.TranslatedString.Translation)
      }

      // @@protoc_insertion_point(class_scope:transit_realtime.TranslatedString.Translation)
      private static final com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation();
      }

      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<Translation>
          PARSER = new com.google.protobuf.AbstractParser<Translation>() {
        @java.lang.Override
        public Translation parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<Translation> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Translation> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public static final int TRANSLATION_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation> translation_;
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation> getTranslationList() {
      return translation_;
    }
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.TranslatedString.TranslationOrBuilder> 
        getTranslationOrBuilderList() {
      return translation_;
    }
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    @java.lang.Override
    public int getTranslationCount() {
      return translation_.size();
    }
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation getTranslation(int index) {
      return translation_.get(index);
    }
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedString.TranslationOrBuilder getTranslationOrBuilder(
        int index) {
      return translation_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      for (int i = 0; i < getTranslationCount(); i++) {
        if (!getTranslation(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (!extensionsAreInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessage
        .ExtendableMessage.ExtensionSerializer
          extensionWriter = newExtensionSerializer();
      for (int i = 0; i < translation_.size(); i++) {
        output.writeMessage(1, translation_.get(i));
      }
      extensionWriter.writeUntil(10000, output);
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < translation_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, translation_.get(i));
      }
      size += extensionsSerializedSize();
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.TranslatedString)) {
        return super.equals(obj);
      }
      com.google.transit.realtime.GtfsRealtime.TranslatedString other = (com.google.transit.realtime.GtfsRealtime.TranslatedString) obj;

      if (!getTranslationList()
          .equals(other.getTranslationList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      if (!getExtensionFields().equals(other.getExtensionFields()))
        return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getTranslationCount() > 0) {
        hash = (37 * hash) + TRANSLATION_FIELD_NUMBER;
        hash = (53 * hash) + getTranslationList().hashCode();
      }
      hash = hashFields(hash, getExtensionFields());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.transit.realtime.GtfsRealtime.TranslatedString parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedString parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedString parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedString parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedString parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedString parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedString parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedString parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.transit.realtime.GtfsRealtime.TranslatedString parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.transit.realtime.GtfsRealtime.TranslatedString parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedString parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedString parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.TranslatedString prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * An internationalized message containing per-language versions of a snippet of
     * text or a URL.
     * One of the strings from a message will be picked up. The resolution proceeds
     * as follows:
     * 1. If the UI language matches the language code of a translation,
     * the first matching translation is picked.
     * 2. If a default UI language (e.g., English) matches the language code of a
     * translation, the first matching translation is picked.
     * 3. If some translation has an unspecified language code, that translation is
     * picked.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.TranslatedString}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_realtime.TranslatedString)
        com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TranslatedString_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TranslatedString_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.TranslatedString.class, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder.class);
      }

      // Construct using com.google.transit.realtime.GtfsRealtime.TranslatedString.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (translationBuilder_ == null) {
          translation_ = java.util.Collections.emptyList();
        } else {
          translation_ = null;
          translationBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TranslatedString_descriptor;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TranslatedString getDefaultInstanceForType() {
        return com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TranslatedString build() {
        com.google.transit.realtime.GtfsRealtime.TranslatedString result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TranslatedString buildPartial() {
        com.google.transit.realtime.GtfsRealtime.TranslatedString result = new com.google.transit.realtime.GtfsRealtime.TranslatedString(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(com.google.transit.realtime.GtfsRealtime.TranslatedString result) {
        if (translationBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            translation_ = java.util.Collections.unmodifiableList(translation_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.translation_ = translation_;
        } else {
          result.translation_ = translationBuilder_.build();
        }
      }

      private void buildPartial0(com.google.transit.realtime.GtfsRealtime.TranslatedString result) {
        int from_bitField0_ = bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.transit.realtime.GtfsRealtime.TranslatedString) {
          return mergeFrom((com.google.transit.realtime.GtfsRealtime.TranslatedString)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.TranslatedString other) {
        if (other == com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance()) return this;
        if (translationBuilder_ == null) {
          if (!other.translation_.isEmpty()) {
            if (translation_.isEmpty()) {
              translation_ = other.translation_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureTranslationIsMutable();
              translation_.addAll(other.translation_);
            }
            onChanged();
          }
        } else {
          if (!other.translation_.isEmpty()) {
            if (translationBuilder_.isEmpty()) {
              translationBuilder_.dispose();
              translationBuilder_ = null;
              translation_ = other.translation_;
              bitField0_ = (bitField0_ & ~0x00000001);
              translationBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getTranslationFieldBuilder() : null;
            } else {
              translationBuilder_.addAllMessages(other.translation_);
            }
          }
        }
        this.mergeExtensionFields(other);
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        for (int i = 0; i < getTranslationCount(); i++) {
          if (!getTranslation(i).isInitialized()) {
            return false;
          }
        }
        if (!extensionsAreInitialized()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation m =
                    input.readMessage(
                        com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.parser(),
                        extensionRegistry);
                if (translationBuilder_ == null) {
                  ensureTranslationIsMutable();
                  translation_.add(m);
                } else {
                  translationBuilder_.addMessage(m);
                }
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation> translation_ =
        java.util.Collections.emptyList();
      private void ensureTranslationIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          translation_ = new java.util.ArrayList<com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation>(translation_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation, com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedString.TranslationOrBuilder> translationBuilder_;

      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation> getTranslationList() {
        if (translationBuilder_ == null) {
          return java.util.Collections.unmodifiableList(translation_);
        } else {
          return translationBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public int getTranslationCount() {
        if (translationBuilder_ == null) {
          return translation_.size();
        } else {
          return translationBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation getTranslation(int index) {
        if (translationBuilder_ == null) {
          return translation_.get(index);
        } else {
          return translationBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public Builder setTranslation(
          int index, com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation value) {
        if (translationBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTranslationIsMutable();
          translation_.set(index, value);
          onChanged();
        } else {
          translationBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public Builder setTranslation(
          int index, com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.Builder builderForValue) {
        if (translationBuilder_ == null) {
          ensureTranslationIsMutable();
          translation_.set(index, builderForValue.build());
          onChanged();
        } else {
          translationBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public Builder addTranslation(com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation value) {
        if (translationBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTranslationIsMutable();
          translation_.add(value);
          onChanged();
        } else {
          translationBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public Builder addTranslation(
          int index, com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation value) {
        if (translationBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTranslationIsMutable();
          translation_.add(index, value);
          onChanged();
        } else {
          translationBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public Builder addTranslation(
          com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.Builder builderForValue) {
        if (translationBuilder_ == null) {
          ensureTranslationIsMutable();
          translation_.add(builderForValue.build());
          onChanged();
        } else {
          translationBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public Builder addTranslation(
          int index, com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.Builder builderForValue) {
        if (translationBuilder_ == null) {
          ensureTranslationIsMutable();
          translation_.add(index, builderForValue.build());
          onChanged();
        } else {
          translationBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public Builder addAllTranslation(
          java.lang.Iterable<? extends com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation> values) {
        if (translationBuilder_ == null) {
          ensureTranslationIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, translation_);
          onChanged();
        } else {
          translationBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public Builder clearTranslation() {
        if (translationBuilder_ == null) {
          translation_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          translationBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public Builder removeTranslation(int index) {
        if (translationBuilder_ == null) {
          ensureTranslationIsMutable();
          translation_.remove(index);
          onChanged();
        } else {
          translationBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.Builder getTranslationBuilder(
          int index) {
        return getTranslationFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString.TranslationOrBuilder getTranslationOrBuilder(
          int index) {
        if (translationBuilder_ == null) {
          return translation_.get(index);  } else {
          return translationBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.TranslatedString.TranslationOrBuilder> 
           getTranslationOrBuilderList() {
        if (translationBuilder_ != null) {
          return translationBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(translation_);
        }
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.Builder addTranslationBuilder() {
        return getTranslationFieldBuilder().addBuilder(
            com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.getDefaultInstance());
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.Builder addTranslationBuilder(
          int index) {
        return getTranslationFieldBuilder().addBuilder(
            index, com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.getDefaultInstance());
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.Builder> 
           getTranslationBuilderList() {
        return getTranslationFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation, com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedString.TranslationOrBuilder> 
          getTranslationFieldBuilder() {
        if (translationBuilder_ == null) {
          translationBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation, com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedString.TranslationOrBuilder>(
                  translation_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          translation_ = null;
        }
        return translationBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.TranslatedString)
    }

    // @@protoc_insertion_point(class_scope:transit_realtime.TranslatedString)
    private static final com.google.transit.realtime.GtfsRealtime.TranslatedString DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.TranslatedString();
    }

    public static com.google.transit.realtime.GtfsRealtime.TranslatedString getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TranslatedString>
        PARSER = new com.google.protobuf.AbstractParser<TranslatedString>() {
      @java.lang.Override
      public TranslatedString parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TranslatedString> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TranslatedString> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedString getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TranslatedImageOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_realtime.TranslatedImage)
      com.google.protobuf.GeneratedMessage.
          ExtendableMessageOrBuilder<TranslatedImage> {

    /**
     * <pre>
     * At least one localized image must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
     */
    java.util.List<com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage> 
        getLocalizedImageList();
    /**
     * <pre>
     * At least one localized image must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage getLocalizedImage(int index);
    /**
     * <pre>
     * At least one localized image must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
     */
    int getLocalizedImageCount();
    /**
     * <pre>
     * At least one localized image must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
     */
    java.util.List<? extends com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImageOrBuilder> 
        getLocalizedImageOrBuilderList();
    /**
     * <pre>
     * At least one localized image must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImageOrBuilder getLocalizedImageOrBuilder(
        int index);
  }
  /**
   * <pre>
   * An internationalized image containing per-language versions of a URL linking to an image
   * along with meta information
   * Only one of the images from a message will be retained by consumers. The resolution proceeds
   * as follows:
   * 1. If the UI language matches the language code of a translation,
   * the first matching translation is picked.
   * 2. If a default UI language (e.g., English) matches the language code of a
   * translation, the first matching translation is picked.
   * 3. If some translation has an unspecified language code, that translation is
   * picked.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.TranslatedImage}
   */
  public static final class TranslatedImage extends
      com.google.protobuf.GeneratedMessage.ExtendableMessage<
        TranslatedImage> implements
      // @@protoc_insertion_point(message_implements:transit_realtime.TranslatedImage)
      TranslatedImageOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 28,
        /* patch= */ 3,
        /* suffix= */ "",
        TranslatedImage.class.getName());
    }
    // Use TranslatedImage.newBuilder() to construct.
    private TranslatedImage(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.TranslatedImage, ?> builder) {
      super(builder);
    }
    private TranslatedImage() {
      localizedImage_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TranslatedImage_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TranslatedImage_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.transit.realtime.GtfsRealtime.TranslatedImage.class, com.google.transit.realtime.GtfsRealtime.TranslatedImage.Builder.class);
    }

    public interface LocalizedImageOrBuilder extends
        // @@protoc_insertion_point(interface_extends:transit_realtime.TranslatedImage.LocalizedImage)
        com.google.protobuf.GeneratedMessage.
            ExtendableMessageOrBuilder<LocalizedImage> {

      /**
       * <pre>
       * String containing an URL linking to an image
       * The image linked must be less than 2MB. 
       * If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one.
       * The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following http://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values.
       * </pre>
       *
       * <code>required string url = 1;</code>
       * @return Whether the url field is set.
       */
      boolean hasUrl();
      /**
       * <pre>
       * String containing an URL linking to an image
       * The image linked must be less than 2MB. 
       * If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one.
       * The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following http://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values.
       * </pre>
       *
       * <code>required string url = 1;</code>
       * @return The url.
       */
      java.lang.String getUrl();
      /**
       * <pre>
       * String containing an URL linking to an image
       * The image linked must be less than 2MB. 
       * If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one.
       * The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following http://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values.
       * </pre>
       *
       * <code>required string url = 1;</code>
       * @return The bytes for url.
       */
      com.google.protobuf.ByteString
          getUrlBytes();

      /**
       * <pre>
       * IANA media type as to specify the type of image to be displayed. 
       * The type must start with "image/"
       * </pre>
       *
       * <code>required string media_type = 2;</code>
       * @return Whether the mediaType field is set.
       */
      boolean hasMediaType();
      /**
       * <pre>
       * IANA media type as to specify the type of image to be displayed. 
       * The type must start with "image/"
       * </pre>
       *
       * <code>required string media_type = 2;</code>
       * @return The mediaType.
       */
      java.lang.String getMediaType();
      /**
       * <pre>
       * IANA media type as to specify the type of image to be displayed. 
       * The type must start with "image/"
       * </pre>
       *
       * <code>required string media_type = 2;</code>
       * @return The bytes for mediaType.
       */
      com.google.protobuf.ByteString
          getMediaTypeBytes();

      /**
       * <pre>
       * BCP-47 language code. Can be omitted if the language is unknown or if
       * no i18n is done at all for the feed. At most one translation is
       * allowed to have an unspecified language tag.
       * </pre>
       *
       * <code>optional string language = 3;</code>
       * @return Whether the language field is set.
       */
      boolean hasLanguage();
      /**
       * <pre>
       * BCP-47 language code. Can be omitted if the language is unknown or if
       * no i18n is done at all for the feed. At most one translation is
       * allowed to have an unspecified language tag.
       * </pre>
       *
       * <code>optional string language = 3;</code>
       * @return The language.
       */
      java.lang.String getLanguage();
      /**
       * <pre>
       * BCP-47 language code. Can be omitted if the language is unknown or if
       * no i18n is done at all for the feed. At most one translation is
       * allowed to have an unspecified language tag.
       * </pre>
       *
       * <code>optional string language = 3;</code>
       * @return The bytes for language.
       */
      com.google.protobuf.ByteString
          getLanguageBytes();
    }
    /**
     * Protobuf type {@code transit_realtime.TranslatedImage.LocalizedImage}
     */
    public static final class LocalizedImage extends
        com.google.protobuf.GeneratedMessage.ExtendableMessage<
          LocalizedImage> implements
        // @@protoc_insertion_point(message_implements:transit_realtime.TranslatedImage.LocalizedImage)
        LocalizedImageOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 28,
          /* patch= */ 3,
          /* suffix= */ "",
          LocalizedImage.class.getName());
      }
      // Use LocalizedImage.newBuilder() to construct.
      private LocalizedImage(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage, ?> builder) {
        super(builder);
      }
      private LocalizedImage() {
        url_ = "";
        mediaType_ = "";
        language_ = "";
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TranslatedImage_LocalizedImage_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TranslatedImage_LocalizedImage_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage.class, com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage.Builder.class);
      }

      private int bitField0_;
      public static final int URL_FIELD_NUMBER = 1;
      @SuppressWarnings("serial")
      private volatile java.lang.Object url_ = "";
      /**
       * <pre>
       * String containing an URL linking to an image
       * The image linked must be less than 2MB. 
       * If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one.
       * The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following http://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values.
       * </pre>
       *
       * <code>required string url = 1;</code>
       * @return Whether the url field is set.
       */
      @java.lang.Override
      public boolean hasUrl() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * String containing an URL linking to an image
       * The image linked must be less than 2MB. 
       * If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one.
       * The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following http://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values.
       * </pre>
       *
       * <code>required string url = 1;</code>
       * @return The url.
       */
      @java.lang.Override
      public java.lang.String getUrl() {
        java.lang.Object ref = url_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            url_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * String containing an URL linking to an image
       * The image linked must be less than 2MB. 
       * If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one.
       * The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following http://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values.
       * </pre>
       *
       * <code>required string url = 1;</code>
       * @return The bytes for url.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getUrlBytes() {
        java.lang.Object ref = url_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          url_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int MEDIA_TYPE_FIELD_NUMBER = 2;
      @SuppressWarnings("serial")
      private volatile java.lang.Object mediaType_ = "";
      /**
       * <pre>
       * IANA media type as to specify the type of image to be displayed. 
       * The type must start with "image/"
       * </pre>
       *
       * <code>required string media_type = 2;</code>
       * @return Whether the mediaType field is set.
       */
      @java.lang.Override
      public boolean hasMediaType() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * IANA media type as to specify the type of image to be displayed. 
       * The type must start with "image/"
       * </pre>
       *
       * <code>required string media_type = 2;</code>
       * @return The mediaType.
       */
      @java.lang.Override
      public java.lang.String getMediaType() {
        java.lang.Object ref = mediaType_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            mediaType_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * IANA media type as to specify the type of image to be displayed. 
       * The type must start with "image/"
       * </pre>
       *
       * <code>required string media_type = 2;</code>
       * @return The bytes for mediaType.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getMediaTypeBytes() {
        java.lang.Object ref = mediaType_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          mediaType_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int LANGUAGE_FIELD_NUMBER = 3;
      @SuppressWarnings("serial")
      private volatile java.lang.Object language_ = "";
      /**
       * <pre>
       * BCP-47 language code. Can be omitted if the language is unknown or if
       * no i18n is done at all for the feed. At most one translation is
       * allowed to have an unspecified language tag.
       * </pre>
       *
       * <code>optional string language = 3;</code>
       * @return Whether the language field is set.
       */
      @java.lang.Override
      public boolean hasLanguage() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * BCP-47 language code. Can be omitted if the language is unknown or if
       * no i18n is done at all for the feed. At most one translation is
       * allowed to have an unspecified language tag.
       * </pre>
       *
       * <code>optional string language = 3;</code>
       * @return The language.
       */
      @java.lang.Override
      public java.lang.String getLanguage() {
        java.lang.Object ref = language_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            language_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * BCP-47 language code. Can be omitted if the language is unknown or if
       * no i18n is done at all for the feed. At most one translation is
       * allowed to have an unspecified language tag.
       * </pre>
       *
       * <code>optional string language = 3;</code>
       * @return The bytes for language.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getLanguageBytes() {
        java.lang.Object ref = language_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          language_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        if (!hasUrl()) {
          memoizedIsInitialized = 0;
          return false;
        }
        if (!hasMediaType()) {
          memoizedIsInitialized = 0;
          return false;
        }
        if (!extensionsAreInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        com.google.protobuf.GeneratedMessage
          .ExtendableMessage.ExtensionSerializer
            extensionWriter = newExtensionSerializer();
        if (((bitField0_ & 0x00000001) != 0)) {
          com.google.protobuf.GeneratedMessage.writeString(output, 1, url_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          com.google.protobuf.GeneratedMessage.writeString(output, 2, mediaType_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          com.google.protobuf.GeneratedMessage.writeString(output, 3, language_);
        }
        extensionWriter.writeUntil(10000, output);
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.GeneratedMessage.computeStringSize(1, url_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.GeneratedMessage.computeStringSize(2, mediaType_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.GeneratedMessage.computeStringSize(3, language_);
        }
        size += extensionsSerializedSize();
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage)) {
          return super.equals(obj);
        }
        com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage other = (com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage) obj;

        if (hasUrl() != other.hasUrl()) return false;
        if (hasUrl()) {
          if (!getUrl()
              .equals(other.getUrl())) return false;
        }
        if (hasMediaType() != other.hasMediaType()) return false;
        if (hasMediaType()) {
          if (!getMediaType()
              .equals(other.getMediaType())) return false;
        }
        if (hasLanguage() != other.hasLanguage()) return false;
        if (hasLanguage()) {
          if (!getLanguage()
              .equals(other.getLanguage())) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        if (!getExtensionFields().equals(other.getExtensionFields()))
          return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasUrl()) {
          hash = (37 * hash) + URL_FIELD_NUMBER;
          hash = (53 * hash) + getUrl().hashCode();
        }
        if (hasMediaType()) {
          hash = (37 * hash) + MEDIA_TYPE_FIELD_NUMBER;
          hash = (53 * hash) + getMediaType().hashCode();
        }
        if (hasLanguage()) {
          hash = (37 * hash) + LANGUAGE_FIELD_NUMBER;
          hash = (53 * hash) + getLanguage().hashCode();
        }
        hash = hashFields(hash, getExtensionFields());
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code transit_realtime.TranslatedImage.LocalizedImage}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.ExtendableBuilder<
            com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage, Builder> implements
          // @@protoc_insertion_point(builder_implements:transit_realtime.TranslatedImage.LocalizedImage)
          com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImageOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TranslatedImage_LocalizedImage_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TranslatedImage_LocalizedImage_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage.class, com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage.Builder.class);
        }

        // Construct using com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          url_ = "";
          mediaType_ = "";
          language_ = "";
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TranslatedImage_LocalizedImage_descriptor;
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage getDefaultInstanceForType() {
          return com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage.getDefaultInstance();
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage build() {
          com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage buildPartial() {
          com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage result = new com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.url_ = url_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.mediaType_ = mediaType_;
            to_bitField0_ |= 0x00000002;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.language_ = language_;
            to_bitField0_ |= 0x00000004;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage) {
            return mergeFrom((com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage other) {
          if (other == com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage.getDefaultInstance()) return this;
          if (other.hasUrl()) {
            url_ = other.url_;
            bitField0_ |= 0x00000001;
            onChanged();
          }
          if (other.hasMediaType()) {
            mediaType_ = other.mediaType_;
            bitField0_ |= 0x00000002;
            onChanged();
          }
          if (other.hasLanguage()) {
            language_ = other.language_;
            bitField0_ |= 0x00000004;
            onChanged();
          }
          this.mergeExtensionFields(other);
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          if (!hasUrl()) {
            return false;
          }
          if (!hasMediaType()) {
            return false;
          }
          if (!extensionsAreInitialized()) {
            return false;
          }
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 10: {
                  url_ = input.readBytes();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
                case 18: {
                  mediaType_ = input.readBytes();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
                case 26: {
                  language_ = input.readBytes();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 26
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private java.lang.Object url_ = "";
        /**
         * <pre>
         * String containing an URL linking to an image
         * The image linked must be less than 2MB. 
         * If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one.
         * The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following http://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values.
         * </pre>
         *
         * <code>required string url = 1;</code>
         * @return Whether the url field is set.
         */
        public boolean hasUrl() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * String containing an URL linking to an image
         * The image linked must be less than 2MB. 
         * If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one.
         * The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following http://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values.
         * </pre>
         *
         * <code>required string url = 1;</code>
         * @return The url.
         */
        public java.lang.String getUrl() {
          java.lang.Object ref = url_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              url_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * String containing an URL linking to an image
         * The image linked must be less than 2MB. 
         * If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one.
         * The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following http://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values.
         * </pre>
         *
         * <code>required string url = 1;</code>
         * @return The bytes for url.
         */
        public com.google.protobuf.ByteString
            getUrlBytes() {
          java.lang.Object ref = url_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            url_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * String containing an URL linking to an image
         * The image linked must be less than 2MB. 
         * If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one.
         * The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following http://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values.
         * </pre>
         *
         * <code>required string url = 1;</code>
         * @param value The url to set.
         * @return This builder for chaining.
         */
        public Builder setUrl(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          url_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * String containing an URL linking to an image
         * The image linked must be less than 2MB. 
         * If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one.
         * The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following http://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values.
         * </pre>
         *
         * <code>required string url = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearUrl() {
          url_ = getDefaultInstance().getUrl();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * String containing an URL linking to an image
         * The image linked must be less than 2MB. 
         * If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one.
         * The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following http://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values.
         * </pre>
         *
         * <code>required string url = 1;</code>
         * @param value The bytes for url to set.
         * @return This builder for chaining.
         */
        public Builder setUrlBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          url_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }

        private java.lang.Object mediaType_ = "";
        /**
         * <pre>
         * IANA media type as to specify the type of image to be displayed. 
         * The type must start with "image/"
         * </pre>
         *
         * <code>required string media_type = 2;</code>
         * @return Whether the mediaType field is set.
         */
        public boolean hasMediaType() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * IANA media type as to specify the type of image to be displayed. 
         * The type must start with "image/"
         * </pre>
         *
         * <code>required string media_type = 2;</code>
         * @return The mediaType.
         */
        public java.lang.String getMediaType() {
          java.lang.Object ref = mediaType_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              mediaType_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * IANA media type as to specify the type of image to be displayed. 
         * The type must start with "image/"
         * </pre>
         *
         * <code>required string media_type = 2;</code>
         * @return The bytes for mediaType.
         */
        public com.google.protobuf.ByteString
            getMediaTypeBytes() {
          java.lang.Object ref = mediaType_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            mediaType_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * IANA media type as to specify the type of image to be displayed. 
         * The type must start with "image/"
         * </pre>
         *
         * <code>required string media_type = 2;</code>
         * @param value The mediaType to set.
         * @return This builder for chaining.
         */
        public Builder setMediaType(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          mediaType_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * IANA media type as to specify the type of image to be displayed. 
         * The type must start with "image/"
         * </pre>
         *
         * <code>required string media_type = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearMediaType() {
          mediaType_ = getDefaultInstance().getMediaType();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * IANA media type as to specify the type of image to be displayed. 
         * The type must start with "image/"
         * </pre>
         *
         * <code>required string media_type = 2;</code>
         * @param value The bytes for mediaType to set.
         * @return This builder for chaining.
         */
        public Builder setMediaTypeBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          mediaType_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }

        private java.lang.Object language_ = "";
        /**
         * <pre>
         * BCP-47 language code. Can be omitted if the language is unknown or if
         * no i18n is done at all for the feed. At most one translation is
         * allowed to have an unspecified language tag.
         * </pre>
         *
         * <code>optional string language = 3;</code>
         * @return Whether the language field is set.
         */
        public boolean hasLanguage() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * BCP-47 language code. Can be omitted if the language is unknown or if
         * no i18n is done at all for the feed. At most one translation is
         * allowed to have an unspecified language tag.
         * </pre>
         *
         * <code>optional string language = 3;</code>
         * @return The language.
         */
        public java.lang.String getLanguage() {
          java.lang.Object ref = language_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              language_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * BCP-47 language code. Can be omitted if the language is unknown or if
         * no i18n is done at all for the feed. At most one translation is
         * allowed to have an unspecified language tag.
         * </pre>
         *
         * <code>optional string language = 3;</code>
         * @return The bytes for language.
         */
        public com.google.protobuf.ByteString
            getLanguageBytes() {
          java.lang.Object ref = language_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            language_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * BCP-47 language code. Can be omitted if the language is unknown or if
         * no i18n is done at all for the feed. At most one translation is
         * allowed to have an unspecified language tag.
         * </pre>
         *
         * <code>optional string language = 3;</code>
         * @param value The language to set.
         * @return This builder for chaining.
         */
        public Builder setLanguage(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          language_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * BCP-47 language code. Can be omitted if the language is unknown or if
         * no i18n is done at all for the feed. At most one translation is
         * allowed to have an unspecified language tag.
         * </pre>
         *
         * <code>optional string language = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearLanguage() {
          language_ = getDefaultInstance().getLanguage();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * BCP-47 language code. Can be omitted if the language is unknown or if
         * no i18n is done at all for the feed. At most one translation is
         * allowed to have an unspecified language tag.
         * </pre>
         *
         * <code>optional string language = 3;</code>
         * @param value The bytes for language to set.
         * @return This builder for chaining.
         */
        public Builder setLanguageBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          language_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:transit_realtime.TranslatedImage.LocalizedImage)
      }

      // @@protoc_insertion_point(class_scope:transit_realtime.TranslatedImage.LocalizedImage)
      private static final com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage();
      }

      public static com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<LocalizedImage>
          PARSER = new com.google.protobuf.AbstractParser<LocalizedImage>() {
        @java.lang.Override
        public LocalizedImage parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<LocalizedImage> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<LocalizedImage> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public static final int LOCALIZED_IMAGE_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage> localizedImage_;
    /**
     * <pre>
     * At least one localized image must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage> getLocalizedImageList() {
      return localizedImage_;
    }
    /**
     * <pre>
     * At least one localized image must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImageOrBuilder> 
        getLocalizedImageOrBuilderList() {
      return localizedImage_;
    }
    /**
     * <pre>
     * At least one localized image must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
     */
    @java.lang.Override
    public int getLocalizedImageCount() {
      return localizedImage_.size();
    }
    /**
     * <pre>
     * At least one localized image must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage getLocalizedImage(int index) {
      return localizedImage_.get(index);
    }
    /**
     * <pre>
     * At least one localized image must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImageOrBuilder getLocalizedImageOrBuilder(
        int index) {
      return localizedImage_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      for (int i = 0; i < getLocalizedImageCount(); i++) {
        if (!getLocalizedImage(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (!extensionsAreInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessage
        .ExtendableMessage.ExtensionSerializer
          extensionWriter = newExtensionSerializer();
      for (int i = 0; i < localizedImage_.size(); i++) {
        output.writeMessage(1, localizedImage_.get(i));
      }
      extensionWriter.writeUntil(10000, output);
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < localizedImage_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, localizedImage_.get(i));
      }
      size += extensionsSerializedSize();
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.TranslatedImage)) {
        return super.equals(obj);
      }
      com.google.transit.realtime.GtfsRealtime.TranslatedImage other = (com.google.transit.realtime.GtfsRealtime.TranslatedImage) obj;

      if (!getLocalizedImageList()
          .equals(other.getLocalizedImageList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      if (!getExtensionFields().equals(other.getExtensionFields()))
        return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getLocalizedImageCount() > 0) {
        hash = (37 * hash) + LOCALIZED_IMAGE_FIELD_NUMBER;
        hash = (53 * hash) + getLocalizedImageList().hashCode();
      }
      hash = hashFields(hash, getExtensionFields());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.transit.realtime.GtfsRealtime.TranslatedImage parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedImage parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedImage parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedImage parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedImage parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedImage parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedImage parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedImage parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.transit.realtime.GtfsRealtime.TranslatedImage parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.transit.realtime.GtfsRealtime.TranslatedImage parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedImage parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedImage parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.TranslatedImage prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * An internationalized image containing per-language versions of a URL linking to an image
     * along with meta information
     * Only one of the images from a message will be retained by consumers. The resolution proceeds
     * as follows:
     * 1. If the UI language matches the language code of a translation,
     * the first matching translation is picked.
     * 2. If a default UI language (e.g., English) matches the language code of a
     * translation, the first matching translation is picked.
     * 3. If some translation has an unspecified language code, that translation is
     * picked.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.TranslatedImage}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedImage, Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_realtime.TranslatedImage)
        com.google.transit.realtime.GtfsRealtime.TranslatedImageOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TranslatedImage_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TranslatedImage_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.TranslatedImage.class, com.google.transit.realtime.GtfsRealtime.TranslatedImage.Builder.class);
      }

      // Construct using com.google.transit.realtime.GtfsRealtime.TranslatedImage.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (localizedImageBuilder_ == null) {
          localizedImage_ = java.util.Collections.emptyList();
        } else {
          localizedImage_ = null;
          localizedImageBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TranslatedImage_descriptor;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TranslatedImage getDefaultInstanceForType() {
        return com.google.transit.realtime.GtfsRealtime.TranslatedImage.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TranslatedImage build() {
        com.google.transit.realtime.GtfsRealtime.TranslatedImage result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TranslatedImage buildPartial() {
        com.google.transit.realtime.GtfsRealtime.TranslatedImage result = new com.google.transit.realtime.GtfsRealtime.TranslatedImage(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(com.google.transit.realtime.GtfsRealtime.TranslatedImage result) {
        if (localizedImageBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            localizedImage_ = java.util.Collections.unmodifiableList(localizedImage_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.localizedImage_ = localizedImage_;
        } else {
          result.localizedImage_ = localizedImageBuilder_.build();
        }
      }

      private void buildPartial0(com.google.transit.realtime.GtfsRealtime.TranslatedImage result) {
        int from_bitField0_ = bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.transit.realtime.GtfsRealtime.TranslatedImage) {
          return mergeFrom((com.google.transit.realtime.GtfsRealtime.TranslatedImage)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.TranslatedImage other) {
        if (other == com.google.transit.realtime.GtfsRealtime.TranslatedImage.getDefaultInstance()) return this;
        if (localizedImageBuilder_ == null) {
          if (!other.localizedImage_.isEmpty()) {
            if (localizedImage_.isEmpty()) {
              localizedImage_ = other.localizedImage_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureLocalizedImageIsMutable();
              localizedImage_.addAll(other.localizedImage_);
            }
            onChanged();
          }
        } else {
          if (!other.localizedImage_.isEmpty()) {
            if (localizedImageBuilder_.isEmpty()) {
              localizedImageBuilder_.dispose();
              localizedImageBuilder_ = null;
              localizedImage_ = other.localizedImage_;
              bitField0_ = (bitField0_ & ~0x00000001);
              localizedImageBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getLocalizedImageFieldBuilder() : null;
            } else {
              localizedImageBuilder_.addAllMessages(other.localizedImage_);
            }
          }
        }
        this.mergeExtensionFields(other);
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        for (int i = 0; i < getLocalizedImageCount(); i++) {
          if (!getLocalizedImage(i).isInitialized()) {
            return false;
          }
        }
        if (!extensionsAreInitialized()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage m =
                    input.readMessage(
                        com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage.parser(),
                        extensionRegistry);
                if (localizedImageBuilder_ == null) {
                  ensureLocalizedImageIsMutable();
                  localizedImage_.add(m);
                } else {
                  localizedImageBuilder_.addMessage(m);
                }
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage> localizedImage_ =
        java.util.Collections.emptyList();
      private void ensureLocalizedImageIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          localizedImage_ = new java.util.ArrayList<com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage>(localizedImage_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage, com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImageOrBuilder> localizedImageBuilder_;

      /**
       * <pre>
       * At least one localized image must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage> getLocalizedImageList() {
        if (localizedImageBuilder_ == null) {
          return java.util.Collections.unmodifiableList(localizedImage_);
        } else {
          return localizedImageBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * At least one localized image must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
       */
      public int getLocalizedImageCount() {
        if (localizedImageBuilder_ == null) {
          return localizedImage_.size();
        } else {
          return localizedImageBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * At least one localized image must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage getLocalizedImage(int index) {
        if (localizedImageBuilder_ == null) {
          return localizedImage_.get(index);
        } else {
          return localizedImageBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * At least one localized image must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
       */
      public Builder setLocalizedImage(
          int index, com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage value) {
        if (localizedImageBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureLocalizedImageIsMutable();
          localizedImage_.set(index, value);
          onChanged();
        } else {
          localizedImageBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * At least one localized image must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
       */
      public Builder setLocalizedImage(
          int index, com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage.Builder builderForValue) {
        if (localizedImageBuilder_ == null) {
          ensureLocalizedImageIsMutable();
          localizedImage_.set(index, builderForValue.build());
          onChanged();
        } else {
          localizedImageBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * At least one localized image must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
       */
      public Builder addLocalizedImage(com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage value) {
        if (localizedImageBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureLocalizedImageIsMutable();
          localizedImage_.add(value);
          onChanged();
        } else {
          localizedImageBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * At least one localized image must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
       */
      public Builder addLocalizedImage(
          int index, com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage value) {
        if (localizedImageBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureLocalizedImageIsMutable();
          localizedImage_.add(index, value);
          onChanged();
        } else {
          localizedImageBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * At least one localized image must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
       */
      public Builder addLocalizedImage(
          com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage.Builder builderForValue) {
        if (localizedImageBuilder_ == null) {
          ensureLocalizedImageIsMutable();
          localizedImage_.add(builderForValue.build());
          onChanged();
        } else {
          localizedImageBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * At least one localized image must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
       */
      public Builder addLocalizedImage(
          int index, com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage.Builder builderForValue) {
        if (localizedImageBuilder_ == null) {
          ensureLocalizedImageIsMutable();
          localizedImage_.add(index, builderForValue.build());
          onChanged();
        } else {
          localizedImageBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * At least one localized image must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
       */
      public Builder addAllLocalizedImage(
          java.lang.Iterable<? extends com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage> values) {
        if (localizedImageBuilder_ == null) {
          ensureLocalizedImageIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, localizedImage_);
          onChanged();
        } else {
          localizedImageBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * At least one localized image must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
       */
      public Builder clearLocalizedImage() {
        if (localizedImageBuilder_ == null) {
          localizedImage_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          localizedImageBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * At least one localized image must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
       */
      public Builder removeLocalizedImage(int index) {
        if (localizedImageBuilder_ == null) {
          ensureLocalizedImageIsMutable();
          localizedImage_.remove(index);
          onChanged();
        } else {
          localizedImageBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * At least one localized image must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage.Builder getLocalizedImageBuilder(
          int index) {
        return getLocalizedImageFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * At least one localized image must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImageOrBuilder getLocalizedImageOrBuilder(
          int index) {
        if (localizedImageBuilder_ == null) {
          return localizedImage_.get(index);  } else {
          return localizedImageBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * At least one localized image must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
       */
      public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImageOrBuilder> 
           getLocalizedImageOrBuilderList() {
        if (localizedImageBuilder_ != null) {
          return localizedImageBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(localizedImage_);
        }
      }
      /**
       * <pre>
       * At least one localized image must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage.Builder addLocalizedImageBuilder() {
        return getLocalizedImageFieldBuilder().addBuilder(
            com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage.getDefaultInstance());
      }
      /**
       * <pre>
       * At least one localized image must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage.Builder addLocalizedImageBuilder(
          int index) {
        return getLocalizedImageFieldBuilder().addBuilder(
            index, com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage.getDefaultInstance());
      }
      /**
       * <pre>
       * At least one localized image must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage.Builder> 
           getLocalizedImageBuilderList() {
        return getLocalizedImageFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage, com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImageOrBuilder> 
          getLocalizedImageFieldBuilder() {
        if (localizedImageBuilder_ == null) {
          localizedImageBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage, com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImage.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedImage.LocalizedImageOrBuilder>(
                  localizedImage_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          localizedImage_ = null;
        }
        return localizedImageBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.TranslatedImage)
    }

    // @@protoc_insertion_point(class_scope:transit_realtime.TranslatedImage)
    private static final com.google.transit.realtime.GtfsRealtime.TranslatedImage DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.TranslatedImage();
    }

    public static com.google.transit.realtime.GtfsRealtime.TranslatedImage getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TranslatedImage>
        PARSER = new com.google.protobuf.AbstractParser<TranslatedImage>() {
      @java.lang.Override
      public TranslatedImage parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TranslatedImage> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TranslatedImage> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedImage getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ShapeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_realtime.Shape)
      com.google.protobuf.GeneratedMessage.
          ExtendableMessageOrBuilder<Shape> {

    /**
     * <pre>
     * Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS.
     * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
     * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional string shape_id = 1;</code>
     * @return Whether the shapeId field is set.
     */
    boolean hasShapeId();
    /**
     * <pre>
     * Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS.
     * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
     * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional string shape_id = 1;</code>
     * @return The shapeId.
     */
    java.lang.String getShapeId();
    /**
     * <pre>
     * Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS.
     * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
     * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional string shape_id = 1;</code>
     * @return The bytes for shapeId.
     */
    com.google.protobuf.ByteString
        getShapeIdBytes();

    /**
     * <pre>
     * Encoded polyline representation of the shape. This polyline must contain at least two points.
     * For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
     * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
     * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional string encoded_polyline = 2;</code>
     * @return Whether the encodedPolyline field is set.
     */
    boolean hasEncodedPolyline();
    /**
     * <pre>
     * Encoded polyline representation of the shape. This polyline must contain at least two points.
     * For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
     * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
     * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional string encoded_polyline = 2;</code>
     * @return The encodedPolyline.
     */
    java.lang.String getEncodedPolyline();
    /**
     * <pre>
     * Encoded polyline representation of the shape. This polyline must contain at least two points.
     * For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
     * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
     * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional string encoded_polyline = 2;</code>
     * @return The bytes for encodedPolyline.
     */
    com.google.protobuf.ByteString
        getEncodedPolylineBytes();
  }
  /**
   * <pre>
   * Describes the physical path that a vehicle takes when it's not part of the (CSV) GTFS,
   * such as for a detour. Shapes belong to Trips, and consist of a sequence of shape points.
   * Tracing the points in order provides the path of the vehicle.  Shapes do not need to intercept
   * the location of Stops exactly, but all Stops on a trip should lie within a small distance of
   * the shape for that trip, i.e. close to straight line segments connecting the shape points
   * NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.Shape}
   */
  public static final class Shape extends
      com.google.protobuf.GeneratedMessage.ExtendableMessage<
        Shape> implements
      // @@protoc_insertion_point(message_implements:transit_realtime.Shape)
      ShapeOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 28,
        /* patch= */ 3,
        /* suffix= */ "",
        Shape.class.getName());
    }
    // Use Shape.newBuilder() to construct.
    private Shape(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.Shape, ?> builder) {
      super(builder);
    }
    private Shape() {
      shapeId_ = "";
      encodedPolyline_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_Shape_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_Shape_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.transit.realtime.GtfsRealtime.Shape.class, com.google.transit.realtime.GtfsRealtime.Shape.Builder.class);
    }

    private int bitField0_;
    public static final int SHAPE_ID_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object shapeId_ = "";
    /**
     * <pre>
     * Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS.
     * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
     * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional string shape_id = 1;</code>
     * @return Whether the shapeId field is set.
     */
    @java.lang.Override
    public boolean hasShapeId() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS.
     * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
     * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional string shape_id = 1;</code>
     * @return The shapeId.
     */
    @java.lang.Override
    public java.lang.String getShapeId() {
      java.lang.Object ref = shapeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          shapeId_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS.
     * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
     * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional string shape_id = 1;</code>
     * @return The bytes for shapeId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getShapeIdBytes() {
      java.lang.Object ref = shapeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        shapeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ENCODED_POLYLINE_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object encodedPolyline_ = "";
    /**
     * <pre>
     * Encoded polyline representation of the shape. This polyline must contain at least two points.
     * For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
     * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
     * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional string encoded_polyline = 2;</code>
     * @return Whether the encodedPolyline field is set.
     */
    @java.lang.Override
    public boolean hasEncodedPolyline() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Encoded polyline representation of the shape. This polyline must contain at least two points.
     * For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
     * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
     * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional string encoded_polyline = 2;</code>
     * @return The encodedPolyline.
     */
    @java.lang.Override
    public java.lang.String getEncodedPolyline() {
      java.lang.Object ref = encodedPolyline_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          encodedPolyline_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Encoded polyline representation of the shape. This polyline must contain at least two points.
     * For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
     * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
     * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * <code>optional string encoded_polyline = 2;</code>
     * @return The bytes for encodedPolyline.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getEncodedPolylineBytes() {
      java.lang.Object ref = encodedPolyline_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        encodedPolyline_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!extensionsAreInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessage
        .ExtendableMessage.ExtensionSerializer
          extensionWriter = newExtensionSerializer();
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, shapeId_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, encodedPolyline_);
      }
      extensionWriter.writeUntil(10000, output);
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, shapeId_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, encodedPolyline_);
      }
      size += extensionsSerializedSize();
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.Shape)) {
        return super.equals(obj);
      }
      com.google.transit.realtime.GtfsRealtime.Shape other = (com.google.transit.realtime.GtfsRealtime.Shape) obj;

      if (hasShapeId() != other.hasShapeId()) return false;
      if (hasShapeId()) {
        if (!getShapeId()
            .equals(other.getShapeId())) return false;
      }
      if (hasEncodedPolyline() != other.hasEncodedPolyline()) return false;
      if (hasEncodedPolyline()) {
        if (!getEncodedPolyline()
            .equals(other.getEncodedPolyline())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      if (!getExtensionFields().equals(other.getExtensionFields()))
        return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasShapeId()) {
        hash = (37 * hash) + SHAPE_ID_FIELD_NUMBER;
        hash = (53 * hash) + getShapeId().hashCode();
      }
      if (hasEncodedPolyline()) {
        hash = (37 * hash) + ENCODED_POLYLINE_FIELD_NUMBER;
        hash = (53 * hash) + getEncodedPolyline().hashCode();
      }
      hash = hashFields(hash, getExtensionFields());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.transit.realtime.GtfsRealtime.Shape parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.Shape parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Shape parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.Shape parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Shape parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.Shape parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Shape parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.Shape parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.transit.realtime.GtfsRealtime.Shape parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.transit.realtime.GtfsRealtime.Shape parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Shape parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.Shape parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.Shape prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Describes the physical path that a vehicle takes when it's not part of the (CSV) GTFS,
     * such as for a detour. Shapes belong to Trips, and consist of a sequence of shape points.
     * Tracing the points in order provides the path of the vehicle.  Shapes do not need to intercept
     * the location of Stops exactly, but all Stops on a trip should lie within a small distance of
     * the shape for that trip, i.e. close to straight line segments connecting the shape points
     * NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.Shape}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
          com.google.transit.realtime.GtfsRealtime.Shape, Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_realtime.Shape)
        com.google.transit.realtime.GtfsRealtime.ShapeOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_Shape_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_Shape_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.Shape.class, com.google.transit.realtime.GtfsRealtime.Shape.Builder.class);
      }

      // Construct using com.google.transit.realtime.GtfsRealtime.Shape.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        shapeId_ = "";
        encodedPolyline_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_Shape_descriptor;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.Shape getDefaultInstanceForType() {
        return com.google.transit.realtime.GtfsRealtime.Shape.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.Shape build() {
        com.google.transit.realtime.GtfsRealtime.Shape result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.Shape buildPartial() {
        com.google.transit.realtime.GtfsRealtime.Shape result = new com.google.transit.realtime.GtfsRealtime.Shape(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.transit.realtime.GtfsRealtime.Shape result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.shapeId_ = shapeId_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.encodedPolyline_ = encodedPolyline_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.transit.realtime.GtfsRealtime.Shape) {
          return mergeFrom((com.google.transit.realtime.GtfsRealtime.Shape)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.Shape other) {
        if (other == com.google.transit.realtime.GtfsRealtime.Shape.getDefaultInstance()) return this;
        if (other.hasShapeId()) {
          shapeId_ = other.shapeId_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasEncodedPolyline()) {
          encodedPolyline_ = other.encodedPolyline_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeExtensionFields(other);
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!extensionsAreInitialized()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                shapeId_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                encodedPolyline_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object shapeId_ = "";
      /**
       * <pre>
       * Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS.
       * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
       * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string shape_id = 1;</code>
       * @return Whether the shapeId field is set.
       */
      public boolean hasShapeId() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS.
       * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
       * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string shape_id = 1;</code>
       * @return The shapeId.
       */
      public java.lang.String getShapeId() {
        java.lang.Object ref = shapeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            shapeId_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS.
       * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
       * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string shape_id = 1;</code>
       * @return The bytes for shapeId.
       */
      public com.google.protobuf.ByteString
          getShapeIdBytes() {
        java.lang.Object ref = shapeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          shapeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS.
       * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
       * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string shape_id = 1;</code>
       * @param value The shapeId to set.
       * @return This builder for chaining.
       */
      public Builder setShapeId(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        shapeId_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS.
       * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
       * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string shape_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearShapeId() {
        shapeId_ = getDefaultInstance().getShapeId();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS.
       * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
       * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string shape_id = 1;</code>
       * @param value The bytes for shapeId to set.
       * @return This builder for chaining.
       */
      public Builder setShapeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        shapeId_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object encodedPolyline_ = "";
      /**
       * <pre>
       * Encoded polyline representation of the shape. This polyline must contain at least two points.
       * For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
       * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
       * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string encoded_polyline = 2;</code>
       * @return Whether the encodedPolyline field is set.
       */
      public boolean hasEncodedPolyline() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Encoded polyline representation of the shape. This polyline must contain at least two points.
       * For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
       * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
       * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string encoded_polyline = 2;</code>
       * @return The encodedPolyline.
       */
      public java.lang.String getEncodedPolyline() {
        java.lang.Object ref = encodedPolyline_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            encodedPolyline_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Encoded polyline representation of the shape. This polyline must contain at least two points.
       * For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
       * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
       * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string encoded_polyline = 2;</code>
       * @return The bytes for encodedPolyline.
       */
      public com.google.protobuf.ByteString
          getEncodedPolylineBytes() {
        java.lang.Object ref = encodedPolyline_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          encodedPolyline_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Encoded polyline representation of the shape. This polyline must contain at least two points.
       * For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
       * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
       * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string encoded_polyline = 2;</code>
       * @param value The encodedPolyline to set.
       * @return This builder for chaining.
       */
      public Builder setEncodedPolyline(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        encodedPolyline_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Encoded polyline representation of the shape. This polyline must contain at least two points.
       * For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
       * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
       * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string encoded_polyline = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearEncodedPolyline() {
        encodedPolyline_ = getDefaultInstance().getEncodedPolyline();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Encoded polyline representation of the shape. This polyline must contain at least two points.
       * For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
       * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
       * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
       * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
       * </pre>
       *
       * <code>optional string encoded_polyline = 2;</code>
       * @param value The bytes for encodedPolyline to set.
       * @return This builder for chaining.
       */
      public Builder setEncodedPolylineBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        encodedPolyline_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.Shape)
    }

    // @@protoc_insertion_point(class_scope:transit_realtime.Shape)
    private static final com.google.transit.realtime.GtfsRealtime.Shape DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.Shape();
    }

    public static com.google.transit.realtime.GtfsRealtime.Shape getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Shape>
        PARSER = new com.google.protobuf.AbstractParser<Shape>() {
      @java.lang.Override
      public Shape parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Shape> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Shape> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.Shape getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface StopOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_realtime.Stop)
      com.google.protobuf.GeneratedMessage.
          ExtendableMessageOrBuilder<Stop> {

    /**
     * <code>optional string stop_id = 1;</code>
     * @return Whether the stopId field is set.
     */
    boolean hasStopId();
    /**
     * <code>optional string stop_id = 1;</code>
     * @return The stopId.
     */
    java.lang.String getStopId();
    /**
     * <code>optional string stop_id = 1;</code>
     * @return The bytes for stopId.
     */
    com.google.protobuf.ByteString
        getStopIdBytes();

    /**
     * <code>optional .transit_realtime.TranslatedString stop_code = 2;</code>
     * @return Whether the stopCode field is set.
     */
    boolean hasStopCode();
    /**
     * <code>optional .transit_realtime.TranslatedString stop_code = 2;</code>
     * @return The stopCode.
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedString getStopCode();
    /**
     * <code>optional .transit_realtime.TranslatedString stop_code = 2;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getStopCodeOrBuilder();

    /**
     * <code>optional .transit_realtime.TranslatedString stop_name = 3;</code>
     * @return Whether the stopName field is set.
     */
    boolean hasStopName();
    /**
     * <code>optional .transit_realtime.TranslatedString stop_name = 3;</code>
     * @return The stopName.
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedString getStopName();
    /**
     * <code>optional .transit_realtime.TranslatedString stop_name = 3;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getStopNameOrBuilder();

    /**
     * <code>optional .transit_realtime.TranslatedString tts_stop_name = 4;</code>
     * @return Whether the ttsStopName field is set.
     */
    boolean hasTtsStopName();
    /**
     * <code>optional .transit_realtime.TranslatedString tts_stop_name = 4;</code>
     * @return The ttsStopName.
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedString getTtsStopName();
    /**
     * <code>optional .transit_realtime.TranslatedString tts_stop_name = 4;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getTtsStopNameOrBuilder();

    /**
     * <code>optional .transit_realtime.TranslatedString stop_desc = 5;</code>
     * @return Whether the stopDesc field is set.
     */
    boolean hasStopDesc();
    /**
     * <code>optional .transit_realtime.TranslatedString stop_desc = 5;</code>
     * @return The stopDesc.
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedString getStopDesc();
    /**
     * <code>optional .transit_realtime.TranslatedString stop_desc = 5;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getStopDescOrBuilder();

    /**
     * <code>optional float stop_lat = 6;</code>
     * @return Whether the stopLat field is set.
     */
    boolean hasStopLat();
    /**
     * <code>optional float stop_lat = 6;</code>
     * @return The stopLat.
     */
    float getStopLat();

    /**
     * <code>optional float stop_lon = 7;</code>
     * @return Whether the stopLon field is set.
     */
    boolean hasStopLon();
    /**
     * <code>optional float stop_lon = 7;</code>
     * @return The stopLon.
     */
    float getStopLon();

    /**
     * <code>optional string zone_id = 8;</code>
     * @return Whether the zoneId field is set.
     */
    boolean hasZoneId();
    /**
     * <code>optional string zone_id = 8;</code>
     * @return The zoneId.
     */
    java.lang.String getZoneId();
    /**
     * <code>optional string zone_id = 8;</code>
     * @return The bytes for zoneId.
     */
    com.google.protobuf.ByteString
        getZoneIdBytes();

    /**
     * <code>optional .transit_realtime.TranslatedString stop_url = 9;</code>
     * @return Whether the stopUrl field is set.
     */
    boolean hasStopUrl();
    /**
     * <code>optional .transit_realtime.TranslatedString stop_url = 9;</code>
     * @return The stopUrl.
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedString getStopUrl();
    /**
     * <code>optional .transit_realtime.TranslatedString stop_url = 9;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getStopUrlOrBuilder();

    /**
     * <code>optional string parent_station = 11;</code>
     * @return Whether the parentStation field is set.
     */
    boolean hasParentStation();
    /**
     * <code>optional string parent_station = 11;</code>
     * @return The parentStation.
     */
    java.lang.String getParentStation();
    /**
     * <code>optional string parent_station = 11;</code>
     * @return The bytes for parentStation.
     */
    com.google.protobuf.ByteString
        getParentStationBytes();

    /**
     * <code>optional string stop_timezone = 12;</code>
     * @return Whether the stopTimezone field is set.
     */
    boolean hasStopTimezone();
    /**
     * <code>optional string stop_timezone = 12;</code>
     * @return The stopTimezone.
     */
    java.lang.String getStopTimezone();
    /**
     * <code>optional string stop_timezone = 12;</code>
     * @return The bytes for stopTimezone.
     */
    com.google.protobuf.ByteString
        getStopTimezoneBytes();

    /**
     * <code>optional .transit_realtime.Stop.WheelchairBoarding wheelchair_boarding = 13 [default = UNKNOWN];</code>
     * @return Whether the wheelchairBoarding field is set.
     */
    boolean hasWheelchairBoarding();
    /**
     * <code>optional .transit_realtime.Stop.WheelchairBoarding wheelchair_boarding = 13 [default = UNKNOWN];</code>
     * @return The wheelchairBoarding.
     */
    com.google.transit.realtime.GtfsRealtime.Stop.WheelchairBoarding getWheelchairBoarding();

    /**
     * <code>optional string level_id = 14;</code>
     * @return Whether the levelId field is set.
     */
    boolean hasLevelId();
    /**
     * <code>optional string level_id = 14;</code>
     * @return The levelId.
     */
    java.lang.String getLevelId();
    /**
     * <code>optional string level_id = 14;</code>
     * @return The bytes for levelId.
     */
    com.google.protobuf.ByteString
        getLevelIdBytes();

    /**
     * <code>optional .transit_realtime.TranslatedString platform_code = 15;</code>
     * @return Whether the platformCode field is set.
     */
    boolean hasPlatformCode();
    /**
     * <code>optional .transit_realtime.TranslatedString platform_code = 15;</code>
     * @return The platformCode.
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedString getPlatformCode();
    /**
     * <code>optional .transit_realtime.TranslatedString platform_code = 15;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getPlatformCodeOrBuilder();
  }
  /**
   * <pre>
   * Describes a stop which is served by trips. All fields are as described in the GTFS-Static specification.
   * NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.Stop}
   */
  public static final class Stop extends
      com.google.protobuf.GeneratedMessage.ExtendableMessage<
        Stop> implements
      // @@protoc_insertion_point(message_implements:transit_realtime.Stop)
      StopOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 28,
        /* patch= */ 3,
        /* suffix= */ "",
        Stop.class.getName());
    }
    // Use Stop.newBuilder() to construct.
    private Stop(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.Stop, ?> builder) {
      super(builder);
    }
    private Stop() {
      stopId_ = "";
      zoneId_ = "";
      parentStation_ = "";
      stopTimezone_ = "";
      wheelchairBoarding_ = 0;
      levelId_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_Stop_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_Stop_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.transit.realtime.GtfsRealtime.Stop.class, com.google.transit.realtime.GtfsRealtime.Stop.Builder.class);
    }

    /**
     * Protobuf enum {@code transit_realtime.Stop.WheelchairBoarding}
     */
    public enum WheelchairBoarding
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>UNKNOWN = 0;</code>
       */
      UNKNOWN(0),
      /**
       * <code>AVAILABLE = 1;</code>
       */
      AVAILABLE(1),
      /**
       * <code>NOT_AVAILABLE = 2;</code>
       */
      NOT_AVAILABLE(2),
      ;

      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 28,
          /* patch= */ 3,
          /* suffix= */ "",
          WheelchairBoarding.class.getName());
      }
      /**
       * <code>UNKNOWN = 0;</code>
       */
      public static final int UNKNOWN_VALUE = 0;
      /**
       * <code>AVAILABLE = 1;</code>
       */
      public static final int AVAILABLE_VALUE = 1;
      /**
       * <code>NOT_AVAILABLE = 2;</code>
       */
      public static final int NOT_AVAILABLE_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static WheelchairBoarding valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static WheelchairBoarding forNumber(int value) {
        switch (value) {
          case 0: return UNKNOWN;
          case 1: return AVAILABLE;
          case 2: return NOT_AVAILABLE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<WheelchairBoarding>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          WheelchairBoarding> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<WheelchairBoarding>() {
              public WheelchairBoarding findValueByNumber(int number) {
                return WheelchairBoarding.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.Stop.getDescriptor().getEnumTypes().get(0);
      }

      private static final WheelchairBoarding[] VALUES = values();

      public static WheelchairBoarding valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private WheelchairBoarding(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_realtime.Stop.WheelchairBoarding)
    }

    private int bitField0_;
    public static final int STOP_ID_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object stopId_ = "";
    /**
     * <code>optional string stop_id = 1;</code>
     * @return Whether the stopId field is set.
     */
    @java.lang.Override
    public boolean hasStopId() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string stop_id = 1;</code>
     * @return The stopId.
     */
    @java.lang.Override
    public java.lang.String getStopId() {
      java.lang.Object ref = stopId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          stopId_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string stop_id = 1;</code>
     * @return The bytes for stopId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStopIdBytes() {
      java.lang.Object ref = stopId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        stopId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STOP_CODE_FIELD_NUMBER = 2;
    private com.google.transit.realtime.GtfsRealtime.TranslatedString stopCode_;
    /**
     * <code>optional .transit_realtime.TranslatedString stop_code = 2;</code>
     * @return Whether the stopCode field is set.
     */
    @java.lang.Override
    public boolean hasStopCode() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional .transit_realtime.TranslatedString stop_code = 2;</code>
     * @return The stopCode.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedString getStopCode() {
      return stopCode_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : stopCode_;
    }
    /**
     * <code>optional .transit_realtime.TranslatedString stop_code = 2;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getStopCodeOrBuilder() {
      return stopCode_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : stopCode_;
    }

    public static final int STOP_NAME_FIELD_NUMBER = 3;
    private com.google.transit.realtime.GtfsRealtime.TranslatedString stopName_;
    /**
     * <code>optional .transit_realtime.TranslatedString stop_name = 3;</code>
     * @return Whether the stopName field is set.
     */
    @java.lang.Override
    public boolean hasStopName() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional .transit_realtime.TranslatedString stop_name = 3;</code>
     * @return The stopName.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedString getStopName() {
      return stopName_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : stopName_;
    }
    /**
     * <code>optional .transit_realtime.TranslatedString stop_name = 3;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getStopNameOrBuilder() {
      return stopName_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : stopName_;
    }

    public static final int TTS_STOP_NAME_FIELD_NUMBER = 4;
    private com.google.transit.realtime.GtfsRealtime.TranslatedString ttsStopName_;
    /**
     * <code>optional .transit_realtime.TranslatedString tts_stop_name = 4;</code>
     * @return Whether the ttsStopName field is set.
     */
    @java.lang.Override
    public boolean hasTtsStopName() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional .transit_realtime.TranslatedString tts_stop_name = 4;</code>
     * @return The ttsStopName.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedString getTtsStopName() {
      return ttsStopName_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : ttsStopName_;
    }
    /**
     * <code>optional .transit_realtime.TranslatedString tts_stop_name = 4;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getTtsStopNameOrBuilder() {
      return ttsStopName_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : ttsStopName_;
    }

    public static final int STOP_DESC_FIELD_NUMBER = 5;
    private com.google.transit.realtime.GtfsRealtime.TranslatedString stopDesc_;
    /**
     * <code>optional .transit_realtime.TranslatedString stop_desc = 5;</code>
     * @return Whether the stopDesc field is set.
     */
    @java.lang.Override
    public boolean hasStopDesc() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <code>optional .transit_realtime.TranslatedString stop_desc = 5;</code>
     * @return The stopDesc.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedString getStopDesc() {
      return stopDesc_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : stopDesc_;
    }
    /**
     * <code>optional .transit_realtime.TranslatedString stop_desc = 5;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getStopDescOrBuilder() {
      return stopDesc_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : stopDesc_;
    }

    public static final int STOP_LAT_FIELD_NUMBER = 6;
    private float stopLat_ = 0F;
    /**
     * <code>optional float stop_lat = 6;</code>
     * @return Whether the stopLat field is set.
     */
    @java.lang.Override
    public boolean hasStopLat() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <code>optional float stop_lat = 6;</code>
     * @return The stopLat.
     */
    @java.lang.Override
    public float getStopLat() {
      return stopLat_;
    }

    public static final int STOP_LON_FIELD_NUMBER = 7;
    private float stopLon_ = 0F;
    /**
     * <code>optional float stop_lon = 7;</code>
     * @return Whether the stopLon field is set.
     */
    @java.lang.Override
    public boolean hasStopLon() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <code>optional float stop_lon = 7;</code>
     * @return The stopLon.
     */
    @java.lang.Override
    public float getStopLon() {
      return stopLon_;
    }

    public static final int ZONE_ID_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private volatile java.lang.Object zoneId_ = "";
    /**
     * <code>optional string zone_id = 8;</code>
     * @return Whether the zoneId field is set.
     */
    @java.lang.Override
    public boolean hasZoneId() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <code>optional string zone_id = 8;</code>
     * @return The zoneId.
     */
    @java.lang.Override
    public java.lang.String getZoneId() {
      java.lang.Object ref = zoneId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          zoneId_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string zone_id = 8;</code>
     * @return The bytes for zoneId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getZoneIdBytes() {
      java.lang.Object ref = zoneId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        zoneId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STOP_URL_FIELD_NUMBER = 9;
    private com.google.transit.realtime.GtfsRealtime.TranslatedString stopUrl_;
    /**
     * <code>optional .transit_realtime.TranslatedString stop_url = 9;</code>
     * @return Whether the stopUrl field is set.
     */
    @java.lang.Override
    public boolean hasStopUrl() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <code>optional .transit_realtime.TranslatedString stop_url = 9;</code>
     * @return The stopUrl.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedString getStopUrl() {
      return stopUrl_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : stopUrl_;
    }
    /**
     * <code>optional .transit_realtime.TranslatedString stop_url = 9;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getStopUrlOrBuilder() {
      return stopUrl_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : stopUrl_;
    }

    public static final int PARENT_STATION_FIELD_NUMBER = 11;
    @SuppressWarnings("serial")
    private volatile java.lang.Object parentStation_ = "";
    /**
     * <code>optional string parent_station = 11;</code>
     * @return Whether the parentStation field is set.
     */
    @java.lang.Override
    public boolean hasParentStation() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <code>optional string parent_station = 11;</code>
     * @return The parentStation.
     */
    @java.lang.Override
    public java.lang.String getParentStation() {
      java.lang.Object ref = parentStation_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          parentStation_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string parent_station = 11;</code>
     * @return The bytes for parentStation.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getParentStationBytes() {
      java.lang.Object ref = parentStation_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        parentStation_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STOP_TIMEZONE_FIELD_NUMBER = 12;
    @SuppressWarnings("serial")
    private volatile java.lang.Object stopTimezone_ = "";
    /**
     * <code>optional string stop_timezone = 12;</code>
     * @return Whether the stopTimezone field is set.
     */
    @java.lang.Override
    public boolean hasStopTimezone() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <code>optional string stop_timezone = 12;</code>
     * @return The stopTimezone.
     */
    @java.lang.Override
    public java.lang.String getStopTimezone() {
      java.lang.Object ref = stopTimezone_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          stopTimezone_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string stop_timezone = 12;</code>
     * @return The bytes for stopTimezone.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStopTimezoneBytes() {
      java.lang.Object ref = stopTimezone_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        stopTimezone_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int WHEELCHAIR_BOARDING_FIELD_NUMBER = 13;
    private int wheelchairBoarding_ = 0;
    /**
     * <code>optional .transit_realtime.Stop.WheelchairBoarding wheelchair_boarding = 13 [default = UNKNOWN];</code>
     * @return Whether the wheelchairBoarding field is set.
     */
    @java.lang.Override public boolean hasWheelchairBoarding() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <code>optional .transit_realtime.Stop.WheelchairBoarding wheelchair_boarding = 13 [default = UNKNOWN];</code>
     * @return The wheelchairBoarding.
     */
    @java.lang.Override public com.google.transit.realtime.GtfsRealtime.Stop.WheelchairBoarding getWheelchairBoarding() {
      com.google.transit.realtime.GtfsRealtime.Stop.WheelchairBoarding result = com.google.transit.realtime.GtfsRealtime.Stop.WheelchairBoarding.forNumber(wheelchairBoarding_);
      return result == null ? com.google.transit.realtime.GtfsRealtime.Stop.WheelchairBoarding.UNKNOWN : result;
    }

    public static final int LEVEL_ID_FIELD_NUMBER = 14;
    @SuppressWarnings("serial")
    private volatile java.lang.Object levelId_ = "";
    /**
     * <code>optional string level_id = 14;</code>
     * @return Whether the levelId field is set.
     */
    @java.lang.Override
    public boolean hasLevelId() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <code>optional string level_id = 14;</code>
     * @return The levelId.
     */
    @java.lang.Override
    public java.lang.String getLevelId() {
      java.lang.Object ref = levelId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          levelId_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string level_id = 14;</code>
     * @return The bytes for levelId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLevelIdBytes() {
      java.lang.Object ref = levelId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        levelId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PLATFORM_CODE_FIELD_NUMBER = 15;
    private com.google.transit.realtime.GtfsRealtime.TranslatedString platformCode_;
    /**
     * <code>optional .transit_realtime.TranslatedString platform_code = 15;</code>
     * @return Whether the platformCode field is set.
     */
    @java.lang.Override
    public boolean hasPlatformCode() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <code>optional .transit_realtime.TranslatedString platform_code = 15;</code>
     * @return The platformCode.
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedString getPlatformCode() {
      return platformCode_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : platformCode_;
    }
    /**
     * <code>optional .transit_realtime.TranslatedString platform_code = 15;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getPlatformCodeOrBuilder() {
      return platformCode_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : platformCode_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (hasStopCode()) {
        if (!getStopCode().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasStopName()) {
        if (!getStopName().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasTtsStopName()) {
        if (!getTtsStopName().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasStopDesc()) {
        if (!getStopDesc().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasStopUrl()) {
        if (!getStopUrl().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasPlatformCode()) {
        if (!getPlatformCode().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (!extensionsAreInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessage
        .ExtendableMessage.ExtensionSerializer
          extensionWriter = newExtensionSerializer();
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, stopId_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getStopCode());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getStopName());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(4, getTtsStopName());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeMessage(5, getStopDesc());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeFloat(6, stopLat_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeFloat(7, stopLon_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 8, zoneId_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeMessage(9, getStopUrl());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 11, parentStation_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 12, stopTimezone_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeEnum(13, wheelchairBoarding_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 14, levelId_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        output.writeMessage(15, getPlatformCode());
      }
      extensionWriter.writeUntil(10000, output);
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, stopId_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getStopCode());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getStopName());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getTtsStopName());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getStopDesc());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(6, stopLat_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(7, stopLon_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(8, zoneId_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, getStopUrl());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(11, parentStation_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(12, stopTimezone_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(13, wheelchairBoarding_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(14, levelId_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(15, getPlatformCode());
      }
      size += extensionsSerializedSize();
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.Stop)) {
        return super.equals(obj);
      }
      com.google.transit.realtime.GtfsRealtime.Stop other = (com.google.transit.realtime.GtfsRealtime.Stop) obj;

      if (hasStopId() != other.hasStopId()) return false;
      if (hasStopId()) {
        if (!getStopId()
            .equals(other.getStopId())) return false;
      }
      if (hasStopCode() != other.hasStopCode()) return false;
      if (hasStopCode()) {
        if (!getStopCode()
            .equals(other.getStopCode())) return false;
      }
      if (hasStopName() != other.hasStopName()) return false;
      if (hasStopName()) {
        if (!getStopName()
            .equals(other.getStopName())) return false;
      }
      if (hasTtsStopName() != other.hasTtsStopName()) return false;
      if (hasTtsStopName()) {
        if (!getTtsStopName()
            .equals(other.getTtsStopName())) return false;
      }
      if (hasStopDesc() != other.hasStopDesc()) return false;
      if (hasStopDesc()) {
        if (!getStopDesc()
            .equals(other.getStopDesc())) return false;
      }
      if (hasStopLat() != other.hasStopLat()) return false;
      if (hasStopLat()) {
        if (java.lang.Float.floatToIntBits(getStopLat())
            != java.lang.Float.floatToIntBits(
                other.getStopLat())) return false;
      }
      if (hasStopLon() != other.hasStopLon()) return false;
      if (hasStopLon()) {
        if (java.lang.Float.floatToIntBits(getStopLon())
            != java.lang.Float.floatToIntBits(
                other.getStopLon())) return false;
      }
      if (hasZoneId() != other.hasZoneId()) return false;
      if (hasZoneId()) {
        if (!getZoneId()
            .equals(other.getZoneId())) return false;
      }
      if (hasStopUrl() != other.hasStopUrl()) return false;
      if (hasStopUrl()) {
        if (!getStopUrl()
            .equals(other.getStopUrl())) return false;
      }
      if (hasParentStation() != other.hasParentStation()) return false;
      if (hasParentStation()) {
        if (!getParentStation()
            .equals(other.getParentStation())) return false;
      }
      if (hasStopTimezone() != other.hasStopTimezone()) return false;
      if (hasStopTimezone()) {
        if (!getStopTimezone()
            .equals(other.getStopTimezone())) return false;
      }
      if (hasWheelchairBoarding() != other.hasWheelchairBoarding()) return false;
      if (hasWheelchairBoarding()) {
        if (wheelchairBoarding_ != other.wheelchairBoarding_) return false;
      }
      if (hasLevelId() != other.hasLevelId()) return false;
      if (hasLevelId()) {
        if (!getLevelId()
            .equals(other.getLevelId())) return false;
      }
      if (hasPlatformCode() != other.hasPlatformCode()) return false;
      if (hasPlatformCode()) {
        if (!getPlatformCode()
            .equals(other.getPlatformCode())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      if (!getExtensionFields().equals(other.getExtensionFields()))
        return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasStopId()) {
        hash = (37 * hash) + STOP_ID_FIELD_NUMBER;
        hash = (53 * hash) + getStopId().hashCode();
      }
      if (hasStopCode()) {
        hash = (37 * hash) + STOP_CODE_FIELD_NUMBER;
        hash = (53 * hash) + getStopCode().hashCode();
      }
      if (hasStopName()) {
        hash = (37 * hash) + STOP_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getStopName().hashCode();
      }
      if (hasTtsStopName()) {
        hash = (37 * hash) + TTS_STOP_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getTtsStopName().hashCode();
      }
      if (hasStopDesc()) {
        hash = (37 * hash) + STOP_DESC_FIELD_NUMBER;
        hash = (53 * hash) + getStopDesc().hashCode();
      }
      if (hasStopLat()) {
        hash = (37 * hash) + STOP_LAT_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getStopLat());
      }
      if (hasStopLon()) {
        hash = (37 * hash) + STOP_LON_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getStopLon());
      }
      if (hasZoneId()) {
        hash = (37 * hash) + ZONE_ID_FIELD_NUMBER;
        hash = (53 * hash) + getZoneId().hashCode();
      }
      if (hasStopUrl()) {
        hash = (37 * hash) + STOP_URL_FIELD_NUMBER;
        hash = (53 * hash) + getStopUrl().hashCode();
      }
      if (hasParentStation()) {
        hash = (37 * hash) + PARENT_STATION_FIELD_NUMBER;
        hash = (53 * hash) + getParentStation().hashCode();
      }
      if (hasStopTimezone()) {
        hash = (37 * hash) + STOP_TIMEZONE_FIELD_NUMBER;
        hash = (53 * hash) + getStopTimezone().hashCode();
      }
      if (hasWheelchairBoarding()) {
        hash = (37 * hash) + WHEELCHAIR_BOARDING_FIELD_NUMBER;
        hash = (53 * hash) + wheelchairBoarding_;
      }
      if (hasLevelId()) {
        hash = (37 * hash) + LEVEL_ID_FIELD_NUMBER;
        hash = (53 * hash) + getLevelId().hashCode();
      }
      if (hasPlatformCode()) {
        hash = (37 * hash) + PLATFORM_CODE_FIELD_NUMBER;
        hash = (53 * hash) + getPlatformCode().hashCode();
      }
      hash = hashFields(hash, getExtensionFields());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.transit.realtime.GtfsRealtime.Stop parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.Stop parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Stop parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.Stop parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Stop parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.Stop parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Stop parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.Stop parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.transit.realtime.GtfsRealtime.Stop parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.transit.realtime.GtfsRealtime.Stop parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Stop parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.Stop parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.Stop prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Describes a stop which is served by trips. All fields are as described in the GTFS-Static specification.
     * NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.Stop}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
          com.google.transit.realtime.GtfsRealtime.Stop, Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_realtime.Stop)
        com.google.transit.realtime.GtfsRealtime.StopOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_Stop_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_Stop_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.Stop.class, com.google.transit.realtime.GtfsRealtime.Stop.Builder.class);
      }

      // Construct using com.google.transit.realtime.GtfsRealtime.Stop.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getStopCodeFieldBuilder();
          getStopNameFieldBuilder();
          getTtsStopNameFieldBuilder();
          getStopDescFieldBuilder();
          getStopUrlFieldBuilder();
          getPlatformCodeFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        stopId_ = "";
        stopCode_ = null;
        if (stopCodeBuilder_ != null) {
          stopCodeBuilder_.dispose();
          stopCodeBuilder_ = null;
        }
        stopName_ = null;
        if (stopNameBuilder_ != null) {
          stopNameBuilder_.dispose();
          stopNameBuilder_ = null;
        }
        ttsStopName_ = null;
        if (ttsStopNameBuilder_ != null) {
          ttsStopNameBuilder_.dispose();
          ttsStopNameBuilder_ = null;
        }
        stopDesc_ = null;
        if (stopDescBuilder_ != null) {
          stopDescBuilder_.dispose();
          stopDescBuilder_ = null;
        }
        stopLat_ = 0F;
        stopLon_ = 0F;
        zoneId_ = "";
        stopUrl_ = null;
        if (stopUrlBuilder_ != null) {
          stopUrlBuilder_.dispose();
          stopUrlBuilder_ = null;
        }
        parentStation_ = "";
        stopTimezone_ = "";
        wheelchairBoarding_ = 0;
        levelId_ = "";
        platformCode_ = null;
        if (platformCodeBuilder_ != null) {
          platformCodeBuilder_.dispose();
          platformCodeBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_Stop_descriptor;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.Stop getDefaultInstanceForType() {
        return com.google.transit.realtime.GtfsRealtime.Stop.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.Stop build() {
        com.google.transit.realtime.GtfsRealtime.Stop result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.Stop buildPartial() {
        com.google.transit.realtime.GtfsRealtime.Stop result = new com.google.transit.realtime.GtfsRealtime.Stop(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.transit.realtime.GtfsRealtime.Stop result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.stopId_ = stopId_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.stopCode_ = stopCodeBuilder_ == null
              ? stopCode_
              : stopCodeBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.stopName_ = stopNameBuilder_ == null
              ? stopName_
              : stopNameBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.ttsStopName_ = ttsStopNameBuilder_ == null
              ? ttsStopName_
              : ttsStopNameBuilder_.build();
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.stopDesc_ = stopDescBuilder_ == null
              ? stopDesc_
              : stopDescBuilder_.build();
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.stopLat_ = stopLat_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.stopLon_ = stopLon_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.zoneId_ = zoneId_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.stopUrl_ = stopUrlBuilder_ == null
              ? stopUrl_
              : stopUrlBuilder_.build();
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.parentStation_ = parentStation_;
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.stopTimezone_ = stopTimezone_;
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.wheelchairBoarding_ = wheelchairBoarding_;
          to_bitField0_ |= 0x00000800;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.levelId_ = levelId_;
          to_bitField0_ |= 0x00001000;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.platformCode_ = platformCodeBuilder_ == null
              ? platformCode_
              : platformCodeBuilder_.build();
          to_bitField0_ |= 0x00002000;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.transit.realtime.GtfsRealtime.Stop) {
          return mergeFrom((com.google.transit.realtime.GtfsRealtime.Stop)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.Stop other) {
        if (other == com.google.transit.realtime.GtfsRealtime.Stop.getDefaultInstance()) return this;
        if (other.hasStopId()) {
          stopId_ = other.stopId_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasStopCode()) {
          mergeStopCode(other.getStopCode());
        }
        if (other.hasStopName()) {
          mergeStopName(other.getStopName());
        }
        if (other.hasTtsStopName()) {
          mergeTtsStopName(other.getTtsStopName());
        }
        if (other.hasStopDesc()) {
          mergeStopDesc(other.getStopDesc());
        }
        if (other.hasStopLat()) {
          setStopLat(other.getStopLat());
        }
        if (other.hasStopLon()) {
          setStopLon(other.getStopLon());
        }
        if (other.hasZoneId()) {
          zoneId_ = other.zoneId_;
          bitField0_ |= 0x00000080;
          onChanged();
        }
        if (other.hasStopUrl()) {
          mergeStopUrl(other.getStopUrl());
        }
        if (other.hasParentStation()) {
          parentStation_ = other.parentStation_;
          bitField0_ |= 0x00000200;
          onChanged();
        }
        if (other.hasStopTimezone()) {
          stopTimezone_ = other.stopTimezone_;
          bitField0_ |= 0x00000400;
          onChanged();
        }
        if (other.hasWheelchairBoarding()) {
          setWheelchairBoarding(other.getWheelchairBoarding());
        }
        if (other.hasLevelId()) {
          levelId_ = other.levelId_;
          bitField0_ |= 0x00001000;
          onChanged();
        }
        if (other.hasPlatformCode()) {
          mergePlatformCode(other.getPlatformCode());
        }
        this.mergeExtensionFields(other);
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (hasStopCode()) {
          if (!getStopCode().isInitialized()) {
            return false;
          }
        }
        if (hasStopName()) {
          if (!getStopName().isInitialized()) {
            return false;
          }
        }
        if (hasTtsStopName()) {
          if (!getTtsStopName().isInitialized()) {
            return false;
          }
        }
        if (hasStopDesc()) {
          if (!getStopDesc().isInitialized()) {
            return false;
          }
        }
        if (hasStopUrl()) {
          if (!getStopUrl().isInitialized()) {
            return false;
          }
        }
        if (hasPlatformCode()) {
          if (!getPlatformCode().isInitialized()) {
            return false;
          }
        }
        if (!extensionsAreInitialized()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                stopId_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getStopCodeFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getStopNameFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                input.readMessage(
                    getTtsStopNameFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                input.readMessage(
                    getStopDescFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              case 53: {
                stopLat_ = input.readFloat();
                bitField0_ |= 0x00000020;
                break;
              } // case 53
              case 61: {
                stopLon_ = input.readFloat();
                bitField0_ |= 0x00000040;
                break;
              } // case 61
              case 66: {
                zoneId_ = input.readBytes();
                bitField0_ |= 0x00000080;
                break;
              } // case 66
              case 74: {
                input.readMessage(
                    getStopUrlFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000100;
                break;
              } // case 74
              case 90: {
                parentStation_ = input.readBytes();
                bitField0_ |= 0x00000200;
                break;
              } // case 90
              case 98: {
                stopTimezone_ = input.readBytes();
                bitField0_ |= 0x00000400;
                break;
              } // case 98
              case 104: {
                int tmpRaw = input.readEnum();
                com.google.transit.realtime.GtfsRealtime.Stop.WheelchairBoarding tmpValue =
                    com.google.transit.realtime.GtfsRealtime.Stop.WheelchairBoarding.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(13, tmpRaw);
                } else {
                  wheelchairBoarding_ = tmpRaw;
                  bitField0_ |= 0x00000800;
                }
                break;
              } // case 104
              case 114: {
                levelId_ = input.readBytes();
                bitField0_ |= 0x00001000;
                break;
              } // case 114
              case 122: {
                input.readMessage(
                    getPlatformCodeFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00002000;
                break;
              } // case 122
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object stopId_ = "";
      /**
       * <code>optional string stop_id = 1;</code>
       * @return Whether the stopId field is set.
       */
      public boolean hasStopId() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional string stop_id = 1;</code>
       * @return The stopId.
       */
      public java.lang.String getStopId() {
        java.lang.Object ref = stopId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            stopId_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string stop_id = 1;</code>
       * @return The bytes for stopId.
       */
      public com.google.protobuf.ByteString
          getStopIdBytes() {
        java.lang.Object ref = stopId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          stopId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string stop_id = 1;</code>
       * @param value The stopId to set.
       * @return This builder for chaining.
       */
      public Builder setStopId(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        stopId_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>optional string stop_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearStopId() {
        stopId_ = getDefaultInstance().getStopId();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <code>optional string stop_id = 1;</code>
       * @param value The bytes for stopId to set.
       * @return This builder for chaining.
       */
      public Builder setStopIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        stopId_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private com.google.transit.realtime.GtfsRealtime.TranslatedString stopCode_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> stopCodeBuilder_;
      /**
       * <code>optional .transit_realtime.TranslatedString stop_code = 2;</code>
       * @return Whether the stopCode field is set.
       */
      public boolean hasStopCode() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_code = 2;</code>
       * @return The stopCode.
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString getStopCode() {
        if (stopCodeBuilder_ == null) {
          return stopCode_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : stopCode_;
        } else {
          return stopCodeBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_code = 2;</code>
       */
      public Builder setStopCode(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (stopCodeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          stopCode_ = value;
        } else {
          stopCodeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_code = 2;</code>
       */
      public Builder setStopCode(
          com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder builderForValue) {
        if (stopCodeBuilder_ == null) {
          stopCode_ = builderForValue.build();
        } else {
          stopCodeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_code = 2;</code>
       */
      public Builder mergeStopCode(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (stopCodeBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            stopCode_ != null &&
            stopCode_ != com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance()) {
            getStopCodeBuilder().mergeFrom(value);
          } else {
            stopCode_ = value;
          }
        } else {
          stopCodeBuilder_.mergeFrom(value);
        }
        if (stopCode_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_code = 2;</code>
       */
      public Builder clearStopCode() {
        bitField0_ = (bitField0_ & ~0x00000002);
        stopCode_ = null;
        if (stopCodeBuilder_ != null) {
          stopCodeBuilder_.dispose();
          stopCodeBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_code = 2;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder getStopCodeBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getStopCodeFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_code = 2;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getStopCodeOrBuilder() {
        if (stopCodeBuilder_ != null) {
          return stopCodeBuilder_.getMessageOrBuilder();
        } else {
          return stopCode_ == null ?
              com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : stopCode_;
        }
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_code = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> 
          getStopCodeFieldBuilder() {
        if (stopCodeBuilder_ == null) {
          stopCodeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder>(
                  getStopCode(),
                  getParentForChildren(),
                  isClean());
          stopCode_ = null;
        }
        return stopCodeBuilder_;
      }

      private com.google.transit.realtime.GtfsRealtime.TranslatedString stopName_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> stopNameBuilder_;
      /**
       * <code>optional .transit_realtime.TranslatedString stop_name = 3;</code>
       * @return Whether the stopName field is set.
       */
      public boolean hasStopName() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_name = 3;</code>
       * @return The stopName.
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString getStopName() {
        if (stopNameBuilder_ == null) {
          return stopName_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : stopName_;
        } else {
          return stopNameBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_name = 3;</code>
       */
      public Builder setStopName(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (stopNameBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          stopName_ = value;
        } else {
          stopNameBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_name = 3;</code>
       */
      public Builder setStopName(
          com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder builderForValue) {
        if (stopNameBuilder_ == null) {
          stopName_ = builderForValue.build();
        } else {
          stopNameBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_name = 3;</code>
       */
      public Builder mergeStopName(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (stopNameBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            stopName_ != null &&
            stopName_ != com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance()) {
            getStopNameBuilder().mergeFrom(value);
          } else {
            stopName_ = value;
          }
        } else {
          stopNameBuilder_.mergeFrom(value);
        }
        if (stopName_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_name = 3;</code>
       */
      public Builder clearStopName() {
        bitField0_ = (bitField0_ & ~0x00000004);
        stopName_ = null;
        if (stopNameBuilder_ != null) {
          stopNameBuilder_.dispose();
          stopNameBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_name = 3;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder getStopNameBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getStopNameFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_name = 3;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getStopNameOrBuilder() {
        if (stopNameBuilder_ != null) {
          return stopNameBuilder_.getMessageOrBuilder();
        } else {
          return stopName_ == null ?
              com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : stopName_;
        }
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_name = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> 
          getStopNameFieldBuilder() {
        if (stopNameBuilder_ == null) {
          stopNameBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder>(
                  getStopName(),
                  getParentForChildren(),
                  isClean());
          stopName_ = null;
        }
        return stopNameBuilder_;
      }

      private com.google.transit.realtime.GtfsRealtime.TranslatedString ttsStopName_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> ttsStopNameBuilder_;
      /**
       * <code>optional .transit_realtime.TranslatedString tts_stop_name = 4;</code>
       * @return Whether the ttsStopName field is set.
       */
      public boolean hasTtsStopName() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <code>optional .transit_realtime.TranslatedString tts_stop_name = 4;</code>
       * @return The ttsStopName.
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString getTtsStopName() {
        if (ttsStopNameBuilder_ == null) {
          return ttsStopName_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : ttsStopName_;
        } else {
          return ttsStopNameBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .transit_realtime.TranslatedString tts_stop_name = 4;</code>
       */
      public Builder setTtsStopName(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (ttsStopNameBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ttsStopName_ = value;
        } else {
          ttsStopNameBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString tts_stop_name = 4;</code>
       */
      public Builder setTtsStopName(
          com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder builderForValue) {
        if (ttsStopNameBuilder_ == null) {
          ttsStopName_ = builderForValue.build();
        } else {
          ttsStopNameBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString tts_stop_name = 4;</code>
       */
      public Builder mergeTtsStopName(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (ttsStopNameBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0) &&
            ttsStopName_ != null &&
            ttsStopName_ != com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance()) {
            getTtsStopNameBuilder().mergeFrom(value);
          } else {
            ttsStopName_ = value;
          }
        } else {
          ttsStopNameBuilder_.mergeFrom(value);
        }
        if (ttsStopName_ != null) {
          bitField0_ |= 0x00000008;
          onChanged();
        }
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString tts_stop_name = 4;</code>
       */
      public Builder clearTtsStopName() {
        bitField0_ = (bitField0_ & ~0x00000008);
        ttsStopName_ = null;
        if (ttsStopNameBuilder_ != null) {
          ttsStopNameBuilder_.dispose();
          ttsStopNameBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString tts_stop_name = 4;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder getTtsStopNameBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getTtsStopNameFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .transit_realtime.TranslatedString tts_stop_name = 4;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getTtsStopNameOrBuilder() {
        if (ttsStopNameBuilder_ != null) {
          return ttsStopNameBuilder_.getMessageOrBuilder();
        } else {
          return ttsStopName_ == null ?
              com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : ttsStopName_;
        }
      }
      /**
       * <code>optional .transit_realtime.TranslatedString tts_stop_name = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> 
          getTtsStopNameFieldBuilder() {
        if (ttsStopNameBuilder_ == null) {
          ttsStopNameBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder>(
                  getTtsStopName(),
                  getParentForChildren(),
                  isClean());
          ttsStopName_ = null;
        }
        return ttsStopNameBuilder_;
      }

      private com.google.transit.realtime.GtfsRealtime.TranslatedString stopDesc_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> stopDescBuilder_;
      /**
       * <code>optional .transit_realtime.TranslatedString stop_desc = 5;</code>
       * @return Whether the stopDesc field is set.
       */
      public boolean hasStopDesc() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_desc = 5;</code>
       * @return The stopDesc.
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString getStopDesc() {
        if (stopDescBuilder_ == null) {
          return stopDesc_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : stopDesc_;
        } else {
          return stopDescBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_desc = 5;</code>
       */
      public Builder setStopDesc(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (stopDescBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          stopDesc_ = value;
        } else {
          stopDescBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_desc = 5;</code>
       */
      public Builder setStopDesc(
          com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder builderForValue) {
        if (stopDescBuilder_ == null) {
          stopDesc_ = builderForValue.build();
        } else {
          stopDescBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_desc = 5;</code>
       */
      public Builder mergeStopDesc(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (stopDescBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0) &&
            stopDesc_ != null &&
            stopDesc_ != com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance()) {
            getStopDescBuilder().mergeFrom(value);
          } else {
            stopDesc_ = value;
          }
        } else {
          stopDescBuilder_.mergeFrom(value);
        }
        if (stopDesc_ != null) {
          bitField0_ |= 0x00000010;
          onChanged();
        }
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_desc = 5;</code>
       */
      public Builder clearStopDesc() {
        bitField0_ = (bitField0_ & ~0x00000010);
        stopDesc_ = null;
        if (stopDescBuilder_ != null) {
          stopDescBuilder_.dispose();
          stopDescBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_desc = 5;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder getStopDescBuilder() {
        bitField0_ |= 0x00000010;
        onChanged();
        return getStopDescFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_desc = 5;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getStopDescOrBuilder() {
        if (stopDescBuilder_ != null) {
          return stopDescBuilder_.getMessageOrBuilder();
        } else {
          return stopDesc_ == null ?
              com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : stopDesc_;
        }
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_desc = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> 
          getStopDescFieldBuilder() {
        if (stopDescBuilder_ == null) {
          stopDescBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder>(
                  getStopDesc(),
                  getParentForChildren(),
                  isClean());
          stopDesc_ = null;
        }
        return stopDescBuilder_;
      }

      private float stopLat_ ;
      /**
       * <code>optional float stop_lat = 6;</code>
       * @return Whether the stopLat field is set.
       */
      @java.lang.Override
      public boolean hasStopLat() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <code>optional float stop_lat = 6;</code>
       * @return The stopLat.
       */
      @java.lang.Override
      public float getStopLat() {
        return stopLat_;
      }
      /**
       * <code>optional float stop_lat = 6;</code>
       * @param value The stopLat to set.
       * @return This builder for chaining.
       */
      public Builder setStopLat(float value) {

        stopLat_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <code>optional float stop_lat = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearStopLat() {
        bitField0_ = (bitField0_ & ~0x00000020);
        stopLat_ = 0F;
        onChanged();
        return this;
      }

      private float stopLon_ ;
      /**
       * <code>optional float stop_lon = 7;</code>
       * @return Whether the stopLon field is set.
       */
      @java.lang.Override
      public boolean hasStopLon() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <code>optional float stop_lon = 7;</code>
       * @return The stopLon.
       */
      @java.lang.Override
      public float getStopLon() {
        return stopLon_;
      }
      /**
       * <code>optional float stop_lon = 7;</code>
       * @param value The stopLon to set.
       * @return This builder for chaining.
       */
      public Builder setStopLon(float value) {

        stopLon_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <code>optional float stop_lon = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearStopLon() {
        bitField0_ = (bitField0_ & ~0x00000040);
        stopLon_ = 0F;
        onChanged();
        return this;
      }

      private java.lang.Object zoneId_ = "";
      /**
       * <code>optional string zone_id = 8;</code>
       * @return Whether the zoneId field is set.
       */
      public boolean hasZoneId() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <code>optional string zone_id = 8;</code>
       * @return The zoneId.
       */
      public java.lang.String getZoneId() {
        java.lang.Object ref = zoneId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            zoneId_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string zone_id = 8;</code>
       * @return The bytes for zoneId.
       */
      public com.google.protobuf.ByteString
          getZoneIdBytes() {
        java.lang.Object ref = zoneId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          zoneId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string zone_id = 8;</code>
       * @param value The zoneId to set.
       * @return This builder for chaining.
       */
      public Builder setZoneId(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        zoneId_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <code>optional string zone_id = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearZoneId() {
        zoneId_ = getDefaultInstance().getZoneId();
        bitField0_ = (bitField0_ & ~0x00000080);
        onChanged();
        return this;
      }
      /**
       * <code>optional string zone_id = 8;</code>
       * @param value The bytes for zoneId to set.
       * @return This builder for chaining.
       */
      public Builder setZoneIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        zoneId_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }

      private com.google.transit.realtime.GtfsRealtime.TranslatedString stopUrl_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> stopUrlBuilder_;
      /**
       * <code>optional .transit_realtime.TranslatedString stop_url = 9;</code>
       * @return Whether the stopUrl field is set.
       */
      public boolean hasStopUrl() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_url = 9;</code>
       * @return The stopUrl.
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString getStopUrl() {
        if (stopUrlBuilder_ == null) {
          return stopUrl_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : stopUrl_;
        } else {
          return stopUrlBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_url = 9;</code>
       */
      public Builder setStopUrl(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (stopUrlBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          stopUrl_ = value;
        } else {
          stopUrlBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_url = 9;</code>
       */
      public Builder setStopUrl(
          com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder builderForValue) {
        if (stopUrlBuilder_ == null) {
          stopUrl_ = builderForValue.build();
        } else {
          stopUrlBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_url = 9;</code>
       */
      public Builder mergeStopUrl(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (stopUrlBuilder_ == null) {
          if (((bitField0_ & 0x00000100) != 0) &&
            stopUrl_ != null &&
            stopUrl_ != com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance()) {
            getStopUrlBuilder().mergeFrom(value);
          } else {
            stopUrl_ = value;
          }
        } else {
          stopUrlBuilder_.mergeFrom(value);
        }
        if (stopUrl_ != null) {
          bitField0_ |= 0x00000100;
          onChanged();
        }
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_url = 9;</code>
       */
      public Builder clearStopUrl() {
        bitField0_ = (bitField0_ & ~0x00000100);
        stopUrl_ = null;
        if (stopUrlBuilder_ != null) {
          stopUrlBuilder_.dispose();
          stopUrlBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_url = 9;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder getStopUrlBuilder() {
        bitField0_ |= 0x00000100;
        onChanged();
        return getStopUrlFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_url = 9;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getStopUrlOrBuilder() {
        if (stopUrlBuilder_ != null) {
          return stopUrlBuilder_.getMessageOrBuilder();
        } else {
          return stopUrl_ == null ?
              com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : stopUrl_;
        }
      }
      /**
       * <code>optional .transit_realtime.TranslatedString stop_url = 9;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> 
          getStopUrlFieldBuilder() {
        if (stopUrlBuilder_ == null) {
          stopUrlBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder>(
                  getStopUrl(),
                  getParentForChildren(),
                  isClean());
          stopUrl_ = null;
        }
        return stopUrlBuilder_;
      }

      private java.lang.Object parentStation_ = "";
      /**
       * <code>optional string parent_station = 11;</code>
       * @return Whether the parentStation field is set.
       */
      public boolean hasParentStation() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <code>optional string parent_station = 11;</code>
       * @return The parentStation.
       */
      public java.lang.String getParentStation() {
        java.lang.Object ref = parentStation_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            parentStation_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string parent_station = 11;</code>
       * @return The bytes for parentStation.
       */
      public com.google.protobuf.ByteString
          getParentStationBytes() {
        java.lang.Object ref = parentStation_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          parentStation_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string parent_station = 11;</code>
       * @param value The parentStation to set.
       * @return This builder for chaining.
       */
      public Builder setParentStation(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        parentStation_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <code>optional string parent_station = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearParentStation() {
        parentStation_ = getDefaultInstance().getParentStation();
        bitField0_ = (bitField0_ & ~0x00000200);
        onChanged();
        return this;
      }
      /**
       * <code>optional string parent_station = 11;</code>
       * @param value The bytes for parentStation to set.
       * @return This builder for chaining.
       */
      public Builder setParentStationBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        parentStation_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }

      private java.lang.Object stopTimezone_ = "";
      /**
       * <code>optional string stop_timezone = 12;</code>
       * @return Whether the stopTimezone field is set.
       */
      public boolean hasStopTimezone() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <code>optional string stop_timezone = 12;</code>
       * @return The stopTimezone.
       */
      public java.lang.String getStopTimezone() {
        java.lang.Object ref = stopTimezone_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            stopTimezone_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string stop_timezone = 12;</code>
       * @return The bytes for stopTimezone.
       */
      public com.google.protobuf.ByteString
          getStopTimezoneBytes() {
        java.lang.Object ref = stopTimezone_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          stopTimezone_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string stop_timezone = 12;</code>
       * @param value The stopTimezone to set.
       * @return This builder for chaining.
       */
      public Builder setStopTimezone(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        stopTimezone_ = value;
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <code>optional string stop_timezone = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearStopTimezone() {
        stopTimezone_ = getDefaultInstance().getStopTimezone();
        bitField0_ = (bitField0_ & ~0x00000400);
        onChanged();
        return this;
      }
      /**
       * <code>optional string stop_timezone = 12;</code>
       * @param value The bytes for stopTimezone to set.
       * @return This builder for chaining.
       */
      public Builder setStopTimezoneBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        stopTimezone_ = value;
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }

      private int wheelchairBoarding_ = 0;
      /**
       * <code>optional .transit_realtime.Stop.WheelchairBoarding wheelchair_boarding = 13 [default = UNKNOWN];</code>
       * @return Whether the wheelchairBoarding field is set.
       */
      @java.lang.Override public boolean hasWheelchairBoarding() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <code>optional .transit_realtime.Stop.WheelchairBoarding wheelchair_boarding = 13 [default = UNKNOWN];</code>
       * @return The wheelchairBoarding.
       */
      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.Stop.WheelchairBoarding getWheelchairBoarding() {
        com.google.transit.realtime.GtfsRealtime.Stop.WheelchairBoarding result = com.google.transit.realtime.GtfsRealtime.Stop.WheelchairBoarding.forNumber(wheelchairBoarding_);
        return result == null ? com.google.transit.realtime.GtfsRealtime.Stop.WheelchairBoarding.UNKNOWN : result;
      }
      /**
       * <code>optional .transit_realtime.Stop.WheelchairBoarding wheelchair_boarding = 13 [default = UNKNOWN];</code>
       * @param value The wheelchairBoarding to set.
       * @return This builder for chaining.
       */
      public Builder setWheelchairBoarding(com.google.transit.realtime.GtfsRealtime.Stop.WheelchairBoarding value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000800;
        wheelchairBoarding_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.Stop.WheelchairBoarding wheelchair_boarding = 13 [default = UNKNOWN];</code>
       * @return This builder for chaining.
       */
      public Builder clearWheelchairBoarding() {
        bitField0_ = (bitField0_ & ~0x00000800);
        wheelchairBoarding_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object levelId_ = "";
      /**
       * <code>optional string level_id = 14;</code>
       * @return Whether the levelId field is set.
       */
      public boolean hasLevelId() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <code>optional string level_id = 14;</code>
       * @return The levelId.
       */
      public java.lang.String getLevelId() {
        java.lang.Object ref = levelId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            levelId_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string level_id = 14;</code>
       * @return The bytes for levelId.
       */
      public com.google.protobuf.ByteString
          getLevelIdBytes() {
        java.lang.Object ref = levelId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          levelId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string level_id = 14;</code>
       * @param value The levelId to set.
       * @return This builder for chaining.
       */
      public Builder setLevelId(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        levelId_ = value;
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <code>optional string level_id = 14;</code>
       * @return This builder for chaining.
       */
      public Builder clearLevelId() {
        levelId_ = getDefaultInstance().getLevelId();
        bitField0_ = (bitField0_ & ~0x00001000);
        onChanged();
        return this;
      }
      /**
       * <code>optional string level_id = 14;</code>
       * @param value The bytes for levelId to set.
       * @return This builder for chaining.
       */
      public Builder setLevelIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        levelId_ = value;
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }

      private com.google.transit.realtime.GtfsRealtime.TranslatedString platformCode_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> platformCodeBuilder_;
      /**
       * <code>optional .transit_realtime.TranslatedString platform_code = 15;</code>
       * @return Whether the platformCode field is set.
       */
      public boolean hasPlatformCode() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <code>optional .transit_realtime.TranslatedString platform_code = 15;</code>
       * @return The platformCode.
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString getPlatformCode() {
        if (platformCodeBuilder_ == null) {
          return platformCode_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : platformCode_;
        } else {
          return platformCodeBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .transit_realtime.TranslatedString platform_code = 15;</code>
       */
      public Builder setPlatformCode(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (platformCodeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          platformCode_ = value;
        } else {
          platformCodeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString platform_code = 15;</code>
       */
      public Builder setPlatformCode(
          com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder builderForValue) {
        if (platformCodeBuilder_ == null) {
          platformCode_ = builderForValue.build();
        } else {
          platformCodeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString platform_code = 15;</code>
       */
      public Builder mergePlatformCode(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        if (platformCodeBuilder_ == null) {
          if (((bitField0_ & 0x00002000) != 0) &&
            platformCode_ != null &&
            platformCode_ != com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance()) {
            getPlatformCodeBuilder().mergeFrom(value);
          } else {
            platformCode_ = value;
          }
        } else {
          platformCodeBuilder_.mergeFrom(value);
        }
        if (platformCode_ != null) {
          bitField0_ |= 0x00002000;
          onChanged();
        }
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString platform_code = 15;</code>
       */
      public Builder clearPlatformCode() {
        bitField0_ = (bitField0_ & ~0x00002000);
        platformCode_ = null;
        if (platformCodeBuilder_ != null) {
          platformCodeBuilder_.dispose();
          platformCodeBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .transit_realtime.TranslatedString platform_code = 15;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder getPlatformCodeBuilder() {
        bitField0_ |= 0x00002000;
        onChanged();
        return getPlatformCodeFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .transit_realtime.TranslatedString platform_code = 15;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder getPlatformCodeOrBuilder() {
        if (platformCodeBuilder_ != null) {
          return platformCodeBuilder_.getMessageOrBuilder();
        } else {
          return platformCode_ == null ?
              com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : platformCode_;
        }
      }
      /**
       * <code>optional .transit_realtime.TranslatedString platform_code = 15;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder> 
          getPlatformCodeFieldBuilder() {
        if (platformCodeBuilder_ == null) {
          platformCodeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder, com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder>(
                  getPlatformCode(),
                  getParentForChildren(),
                  isClean());
          platformCode_ = null;
        }
        return platformCodeBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.Stop)
    }

    // @@protoc_insertion_point(class_scope:transit_realtime.Stop)
    private static final com.google.transit.realtime.GtfsRealtime.Stop DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.Stop();
    }

    public static com.google.transit.realtime.GtfsRealtime.Stop getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Stop>
        PARSER = new com.google.protobuf.AbstractParser<Stop>() {
      @java.lang.Override
      public Stop parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Stop> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Stop> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.Stop getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TripModificationsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_realtime.TripModifications)
      com.google.protobuf.GeneratedMessage.
          ExtendableMessageOrBuilder<TripModifications> {

    /**
     * <pre>
     * A list of selected trips affected by this TripModifications.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
     */
    java.util.List<com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips> 
        getSelectedTripsList();
    /**
     * <pre>
     * A list of selected trips affected by this TripModifications.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips getSelectedTrips(int index);
    /**
     * <pre>
     * A list of selected trips affected by this TripModifications.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
     */
    int getSelectedTripsCount();
    /**
     * <pre>
     * A list of selected trips affected by this TripModifications.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
     */
    java.util.List<? extends com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTripsOrBuilder> 
        getSelectedTripsOrBuilderList();
    /**
     * <pre>
     * A list of selected trips affected by this TripModifications.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTripsOrBuilder getSelectedTripsOrBuilder(
        int index);

    /**
     * <pre>
     * A list of start times in the real-time trip descriptor for the trip_id defined in trip_ids. 
     * Useful to target multiple departures of a trip_id in a frequency-based trip.
     * </pre>
     *
     * <code>repeated string start_times = 2;</code>
     * @return A list containing the startTimes.
     */
    java.util.List<java.lang.String>
        getStartTimesList();
    /**
     * <pre>
     * A list of start times in the real-time trip descriptor for the trip_id defined in trip_ids. 
     * Useful to target multiple departures of a trip_id in a frequency-based trip.
     * </pre>
     *
     * <code>repeated string start_times = 2;</code>
     * @return The count of startTimes.
     */
    int getStartTimesCount();
    /**
     * <pre>
     * A list of start times in the real-time trip descriptor for the trip_id defined in trip_ids. 
     * Useful to target multiple departures of a trip_id in a frequency-based trip.
     * </pre>
     *
     * <code>repeated string start_times = 2;</code>
     * @param index The index of the element to return.
     * @return The startTimes at the given index.
     */
    java.lang.String getStartTimes(int index);
    /**
     * <pre>
     * A list of start times in the real-time trip descriptor for the trip_id defined in trip_ids. 
     * Useful to target multiple departures of a trip_id in a frequency-based trip.
     * </pre>
     *
     * <code>repeated string start_times = 2;</code>
     * @param index The index of the value to return.
     * @return The bytes of the startTimes at the given index.
     */
    com.google.protobuf.ByteString
        getStartTimesBytes(int index);

    /**
     * <pre>
     * Dates on which the modifications occurs, in the YYYYMMDD format. Producers SHOULD only transmit detours occurring within the next week.
     * The dates provided should not be used as user-facing information, if a user-facing start and end date needs to be provided, they can be provided in the linked service alert with `service_alert_id`
     * </pre>
     *
     * <code>repeated string service_dates = 3;</code>
     * @return A list containing the serviceDates.
     */
    java.util.List<java.lang.String>
        getServiceDatesList();
    /**
     * <pre>
     * Dates on which the modifications occurs, in the YYYYMMDD format. Producers SHOULD only transmit detours occurring within the next week.
     * The dates provided should not be used as user-facing information, if a user-facing start and end date needs to be provided, they can be provided in the linked service alert with `service_alert_id`
     * </pre>
     *
     * <code>repeated string service_dates = 3;</code>
     * @return The count of serviceDates.
     */
    int getServiceDatesCount();
    /**
     * <pre>
     * Dates on which the modifications occurs, in the YYYYMMDD format. Producers SHOULD only transmit detours occurring within the next week.
     * The dates provided should not be used as user-facing information, if a user-facing start and end date needs to be provided, they can be provided in the linked service alert with `service_alert_id`
     * </pre>
     *
     * <code>repeated string service_dates = 3;</code>
     * @param index The index of the element to return.
     * @return The serviceDates at the given index.
     */
    java.lang.String getServiceDates(int index);
    /**
     * <pre>
     * Dates on which the modifications occurs, in the YYYYMMDD format. Producers SHOULD only transmit detours occurring within the next week.
     * The dates provided should not be used as user-facing information, if a user-facing start and end date needs to be provided, they can be provided in the linked service alert with `service_alert_id`
     * </pre>
     *
     * <code>repeated string service_dates = 3;</code>
     * @param index The index of the value to return.
     * @return The bytes of the serviceDates at the given index.
     */
    com.google.protobuf.ByteString
        getServiceDatesBytes(int index);

    /**
     * <pre>
     * A list of modifications to apply to the affected trips. 
     * </pre>
     *
     * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
     */
    java.util.List<com.google.transit.realtime.GtfsRealtime.TripModifications.Modification> 
        getModificationsList();
    /**
     * <pre>
     * A list of modifications to apply to the affected trips. 
     * </pre>
     *
     * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TripModifications.Modification getModifications(int index);
    /**
     * <pre>
     * A list of modifications to apply to the affected trips. 
     * </pre>
     *
     * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
     */
    int getModificationsCount();
    /**
     * <pre>
     * A list of modifications to apply to the affected trips. 
     * </pre>
     *
     * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
     */
    java.util.List<? extends com.google.transit.realtime.GtfsRealtime.TripModifications.ModificationOrBuilder> 
        getModificationsOrBuilderList();
    /**
     * <pre>
     * A list of modifications to apply to the affected trips. 
     * </pre>
     *
     * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TripModifications.ModificationOrBuilder getModificationsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.TripModifications}
   */
  public static final class TripModifications extends
      com.google.protobuf.GeneratedMessage.ExtendableMessage<
        TripModifications> implements
      // @@protoc_insertion_point(message_implements:transit_realtime.TripModifications)
      TripModificationsOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 28,
        /* patch= */ 3,
        /* suffix= */ "",
        TripModifications.class.getName());
    }
    // Use TripModifications.newBuilder() to construct.
    private TripModifications(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.TripModifications, ?> builder) {
      super(builder);
    }
    private TripModifications() {
      selectedTrips_ = java.util.Collections.emptyList();
      startTimes_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      serviceDates_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      modifications_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripModifications_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripModifications_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.transit.realtime.GtfsRealtime.TripModifications.class, com.google.transit.realtime.GtfsRealtime.TripModifications.Builder.class);
    }

    public interface ModificationOrBuilder extends
        // @@protoc_insertion_point(interface_extends:transit_realtime.TripModifications.Modification)
        com.google.protobuf.GeneratedMessage.
            ExtendableMessageOrBuilder<Modification> {

      /**
       * <pre>
       * The stop selector of the first stop_time of the original trip that is to be affected by this modification.
       * Used in conjuction with `end_stop_selector`. 
       * `start_stop_selector` is required and is used to define the reference stop used with `travel_time_to_stop`.
       * </pre>
       *
       * <code>optional .transit_realtime.StopSelector start_stop_selector = 1;</code>
       * @return Whether the startStopSelector field is set.
       */
      boolean hasStartStopSelector();
      /**
       * <pre>
       * The stop selector of the first stop_time of the original trip that is to be affected by this modification.
       * Used in conjuction with `end_stop_selector`. 
       * `start_stop_selector` is required and is used to define the reference stop used with `travel_time_to_stop`.
       * </pre>
       *
       * <code>optional .transit_realtime.StopSelector start_stop_selector = 1;</code>
       * @return The startStopSelector.
       */
      com.google.transit.realtime.GtfsRealtime.StopSelector getStartStopSelector();
      /**
       * <pre>
       * The stop selector of the first stop_time of the original trip that is to be affected by this modification.
       * Used in conjuction with `end_stop_selector`. 
       * `start_stop_selector` is required and is used to define the reference stop used with `travel_time_to_stop`.
       * </pre>
       *
       * <code>optional .transit_realtime.StopSelector start_stop_selector = 1;</code>
       */
      com.google.transit.realtime.GtfsRealtime.StopSelectorOrBuilder getStartStopSelectorOrBuilder();

      /**
       * <pre>
       * The stop selector of the last stop of the original trip that is to be affected by this modification. 
       * The selection is inclusive, so if only one stop_time is replaced by that modification, `start_stop_selector` and `end_stop_selector` must be equivalent.
       * If no stop_time is replaced, `end_stop_selector` must not be provided. It's otherwise required.
       * </pre>
       *
       * <code>optional .transit_realtime.StopSelector end_stop_selector = 2;</code>
       * @return Whether the endStopSelector field is set.
       */
      boolean hasEndStopSelector();
      /**
       * <pre>
       * The stop selector of the last stop of the original trip that is to be affected by this modification. 
       * The selection is inclusive, so if only one stop_time is replaced by that modification, `start_stop_selector` and `end_stop_selector` must be equivalent.
       * If no stop_time is replaced, `end_stop_selector` must not be provided. It's otherwise required.
       * </pre>
       *
       * <code>optional .transit_realtime.StopSelector end_stop_selector = 2;</code>
       * @return The endStopSelector.
       */
      com.google.transit.realtime.GtfsRealtime.StopSelector getEndStopSelector();
      /**
       * <pre>
       * The stop selector of the last stop of the original trip that is to be affected by this modification. 
       * The selection is inclusive, so if only one stop_time is replaced by that modification, `start_stop_selector` and `end_stop_selector` must be equivalent.
       * If no stop_time is replaced, `end_stop_selector` must not be provided. It's otherwise required.
       * </pre>
       *
       * <code>optional .transit_realtime.StopSelector end_stop_selector = 2;</code>
       */
      com.google.transit.realtime.GtfsRealtime.StopSelectorOrBuilder getEndStopSelectorOrBuilder();

      /**
       * <pre>
       * The number of seconds of delay to add to all departure and arrival times following the end of this modification. 
       * If multiple modifications apply to the same trip, the delays accumulate as the trip advances. 
       * </pre>
       *
       * <code>optional int32 propagated_modification_delay = 3 [default = 0];</code>
       * @return Whether the propagatedModificationDelay field is set.
       */
      boolean hasPropagatedModificationDelay();
      /**
       * <pre>
       * The number of seconds of delay to add to all departure and arrival times following the end of this modification. 
       * If multiple modifications apply to the same trip, the delays accumulate as the trip advances. 
       * </pre>
       *
       * <code>optional int32 propagated_modification_delay = 3 [default = 0];</code>
       * @return The propagatedModificationDelay.
       */
      int getPropagatedModificationDelay();

      /**
       * <pre>
       * A list of replacement stops, replacing those of the original trip. 
       * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
       * </pre>
       *
       * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
       */
      java.util.List<com.google.transit.realtime.GtfsRealtime.ReplacementStop> 
          getReplacementStopsList();
      /**
       * <pre>
       * A list of replacement stops, replacing those of the original trip. 
       * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
       * </pre>
       *
       * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
       */
      com.google.transit.realtime.GtfsRealtime.ReplacementStop getReplacementStops(int index);
      /**
       * <pre>
       * A list of replacement stops, replacing those of the original trip. 
       * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
       * </pre>
       *
       * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
       */
      int getReplacementStopsCount();
      /**
       * <pre>
       * A list of replacement stops, replacing those of the original trip. 
       * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
       * </pre>
       *
       * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
       */
      java.util.List<? extends com.google.transit.realtime.GtfsRealtime.ReplacementStopOrBuilder> 
          getReplacementStopsOrBuilderList();
      /**
       * <pre>
       * A list of replacement stops, replacing those of the original trip. 
       * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
       * </pre>
       *
       * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
       */
      com.google.transit.realtime.GtfsRealtime.ReplacementStopOrBuilder getReplacementStopsOrBuilder(
          int index);

      /**
       * <pre>
       * An `id` value from the `FeedEntity` message that contains the `Alert` describing this Modification for user-facing communication.
       * </pre>
       *
       * <code>optional string service_alert_id = 5;</code>
       * @return Whether the serviceAlertId field is set.
       */
      boolean hasServiceAlertId();
      /**
       * <pre>
       * An `id` value from the `FeedEntity` message that contains the `Alert` describing this Modification for user-facing communication.
       * </pre>
       *
       * <code>optional string service_alert_id = 5;</code>
       * @return The serviceAlertId.
       */
      java.lang.String getServiceAlertId();
      /**
       * <pre>
       * An `id` value from the `FeedEntity` message that contains the `Alert` describing this Modification for user-facing communication.
       * </pre>
       *
       * <code>optional string service_alert_id = 5;</code>
       * @return The bytes for serviceAlertId.
       */
      com.google.protobuf.ByteString
          getServiceAlertIdBytes();

      /**
       * <pre>
       * This timestamp identifies the moment when the modification has last been changed.
       * In POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 last_modified_time = 6;</code>
       * @return Whether the lastModifiedTime field is set.
       */
      boolean hasLastModifiedTime();
      /**
       * <pre>
       * This timestamp identifies the moment when the modification has last been changed.
       * In POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 last_modified_time = 6;</code>
       * @return The lastModifiedTime.
       */
      long getLastModifiedTime();
    }
    /**
     * <pre>
     * A `Modification` message replaces a span of n stop times from each affected trip starting at `start_stop_selector`.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.TripModifications.Modification}
     */
    public static final class Modification extends
        com.google.protobuf.GeneratedMessage.ExtendableMessage<
          Modification> implements
        // @@protoc_insertion_point(message_implements:transit_realtime.TripModifications.Modification)
        ModificationOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 28,
          /* patch= */ 3,
          /* suffix= */ "",
          Modification.class.getName());
      }
      // Use Modification.newBuilder() to construct.
      private Modification(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.TripModifications.Modification, ?> builder) {
        super(builder);
      }
      private Modification() {
        replacementStops_ = java.util.Collections.emptyList();
        serviceAlertId_ = "";
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripModifications_Modification_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripModifications_Modification_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.TripModifications.Modification.class, com.google.transit.realtime.GtfsRealtime.TripModifications.Modification.Builder.class);
      }

      private int bitField0_;
      public static final int START_STOP_SELECTOR_FIELD_NUMBER = 1;
      private com.google.transit.realtime.GtfsRealtime.StopSelector startStopSelector_;
      /**
       * <pre>
       * The stop selector of the first stop_time of the original trip that is to be affected by this modification.
       * Used in conjuction with `end_stop_selector`. 
       * `start_stop_selector` is required and is used to define the reference stop used with `travel_time_to_stop`.
       * </pre>
       *
       * <code>optional .transit_realtime.StopSelector start_stop_selector = 1;</code>
       * @return Whether the startStopSelector field is set.
       */
      @java.lang.Override
      public boolean hasStartStopSelector() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The stop selector of the first stop_time of the original trip that is to be affected by this modification.
       * Used in conjuction with `end_stop_selector`. 
       * `start_stop_selector` is required and is used to define the reference stop used with `travel_time_to_stop`.
       * </pre>
       *
       * <code>optional .transit_realtime.StopSelector start_stop_selector = 1;</code>
       * @return The startStopSelector.
       */
      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.StopSelector getStartStopSelector() {
        return startStopSelector_ == null ? com.google.transit.realtime.GtfsRealtime.StopSelector.getDefaultInstance() : startStopSelector_;
      }
      /**
       * <pre>
       * The stop selector of the first stop_time of the original trip that is to be affected by this modification.
       * Used in conjuction with `end_stop_selector`. 
       * `start_stop_selector` is required and is used to define the reference stop used with `travel_time_to_stop`.
       * </pre>
       *
       * <code>optional .transit_realtime.StopSelector start_stop_selector = 1;</code>
       */
      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.StopSelectorOrBuilder getStartStopSelectorOrBuilder() {
        return startStopSelector_ == null ? com.google.transit.realtime.GtfsRealtime.StopSelector.getDefaultInstance() : startStopSelector_;
      }

      public static final int END_STOP_SELECTOR_FIELD_NUMBER = 2;
      private com.google.transit.realtime.GtfsRealtime.StopSelector endStopSelector_;
      /**
       * <pre>
       * The stop selector of the last stop of the original trip that is to be affected by this modification. 
       * The selection is inclusive, so if only one stop_time is replaced by that modification, `start_stop_selector` and `end_stop_selector` must be equivalent.
       * If no stop_time is replaced, `end_stop_selector` must not be provided. It's otherwise required.
       * </pre>
       *
       * <code>optional .transit_realtime.StopSelector end_stop_selector = 2;</code>
       * @return Whether the endStopSelector field is set.
       */
      @java.lang.Override
      public boolean hasEndStopSelector() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The stop selector of the last stop of the original trip that is to be affected by this modification. 
       * The selection is inclusive, so if only one stop_time is replaced by that modification, `start_stop_selector` and `end_stop_selector` must be equivalent.
       * If no stop_time is replaced, `end_stop_selector` must not be provided. It's otherwise required.
       * </pre>
       *
       * <code>optional .transit_realtime.StopSelector end_stop_selector = 2;</code>
       * @return The endStopSelector.
       */
      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.StopSelector getEndStopSelector() {
        return endStopSelector_ == null ? com.google.transit.realtime.GtfsRealtime.StopSelector.getDefaultInstance() : endStopSelector_;
      }
      /**
       * <pre>
       * The stop selector of the last stop of the original trip that is to be affected by this modification. 
       * The selection is inclusive, so if only one stop_time is replaced by that modification, `start_stop_selector` and `end_stop_selector` must be equivalent.
       * If no stop_time is replaced, `end_stop_selector` must not be provided. It's otherwise required.
       * </pre>
       *
       * <code>optional .transit_realtime.StopSelector end_stop_selector = 2;</code>
       */
      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.StopSelectorOrBuilder getEndStopSelectorOrBuilder() {
        return endStopSelector_ == null ? com.google.transit.realtime.GtfsRealtime.StopSelector.getDefaultInstance() : endStopSelector_;
      }

      public static final int PROPAGATED_MODIFICATION_DELAY_FIELD_NUMBER = 3;
      private int propagatedModificationDelay_ = 0;
      /**
       * <pre>
       * The number of seconds of delay to add to all departure and arrival times following the end of this modification. 
       * If multiple modifications apply to the same trip, the delays accumulate as the trip advances. 
       * </pre>
       *
       * <code>optional int32 propagated_modification_delay = 3 [default = 0];</code>
       * @return Whether the propagatedModificationDelay field is set.
       */
      @java.lang.Override
      public boolean hasPropagatedModificationDelay() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The number of seconds of delay to add to all departure and arrival times following the end of this modification. 
       * If multiple modifications apply to the same trip, the delays accumulate as the trip advances. 
       * </pre>
       *
       * <code>optional int32 propagated_modification_delay = 3 [default = 0];</code>
       * @return The propagatedModificationDelay.
       */
      @java.lang.Override
      public int getPropagatedModificationDelay() {
        return propagatedModificationDelay_;
      }

      public static final int REPLACEMENT_STOPS_FIELD_NUMBER = 4;
      @SuppressWarnings("serial")
      private java.util.List<com.google.transit.realtime.GtfsRealtime.ReplacementStop> replacementStops_;
      /**
       * <pre>
       * A list of replacement stops, replacing those of the original trip. 
       * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
       * </pre>
       *
       * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.transit.realtime.GtfsRealtime.ReplacementStop> getReplacementStopsList() {
        return replacementStops_;
      }
      /**
       * <pre>
       * A list of replacement stops, replacing those of the original trip. 
       * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
       * </pre>
       *
       * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
       */
      @java.lang.Override
      public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.ReplacementStopOrBuilder> 
          getReplacementStopsOrBuilderList() {
        return replacementStops_;
      }
      /**
       * <pre>
       * A list of replacement stops, replacing those of the original trip. 
       * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
       * </pre>
       *
       * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
       */
      @java.lang.Override
      public int getReplacementStopsCount() {
        return replacementStops_.size();
      }
      /**
       * <pre>
       * A list of replacement stops, replacing those of the original trip. 
       * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
       * </pre>
       *
       * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
       */
      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.ReplacementStop getReplacementStops(int index) {
        return replacementStops_.get(index);
      }
      /**
       * <pre>
       * A list of replacement stops, replacing those of the original trip. 
       * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
       * </pre>
       *
       * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
       */
      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.ReplacementStopOrBuilder getReplacementStopsOrBuilder(
          int index) {
        return replacementStops_.get(index);
      }

      public static final int SERVICE_ALERT_ID_FIELD_NUMBER = 5;
      @SuppressWarnings("serial")
      private volatile java.lang.Object serviceAlertId_ = "";
      /**
       * <pre>
       * An `id` value from the `FeedEntity` message that contains the `Alert` describing this Modification for user-facing communication.
       * </pre>
       *
       * <code>optional string service_alert_id = 5;</code>
       * @return Whether the serviceAlertId field is set.
       */
      @java.lang.Override
      public boolean hasServiceAlertId() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * An `id` value from the `FeedEntity` message that contains the `Alert` describing this Modification for user-facing communication.
       * </pre>
       *
       * <code>optional string service_alert_id = 5;</code>
       * @return The serviceAlertId.
       */
      @java.lang.Override
      public java.lang.String getServiceAlertId() {
        java.lang.Object ref = serviceAlertId_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            serviceAlertId_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * An `id` value from the `FeedEntity` message that contains the `Alert` describing this Modification for user-facing communication.
       * </pre>
       *
       * <code>optional string service_alert_id = 5;</code>
       * @return The bytes for serviceAlertId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getServiceAlertIdBytes() {
        java.lang.Object ref = serviceAlertId_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          serviceAlertId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int LAST_MODIFIED_TIME_FIELD_NUMBER = 6;
      private long lastModifiedTime_ = 0L;
      /**
       * <pre>
       * This timestamp identifies the moment when the modification has last been changed.
       * In POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 last_modified_time = 6;</code>
       * @return Whether the lastModifiedTime field is set.
       */
      @java.lang.Override
      public boolean hasLastModifiedTime() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * This timestamp identifies the moment when the modification has last been changed.
       * In POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 last_modified_time = 6;</code>
       * @return The lastModifiedTime.
       */
      @java.lang.Override
      public long getLastModifiedTime() {
        return lastModifiedTime_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        if (hasStartStopSelector()) {
          if (!getStartStopSelector().isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
          }
        }
        if (hasEndStopSelector()) {
          if (!getEndStopSelector().isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
          }
        }
        for (int i = 0; i < getReplacementStopsCount(); i++) {
          if (!getReplacementStops(i).isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
          }
        }
        if (!extensionsAreInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        com.google.protobuf.GeneratedMessage
          .ExtendableMessage.ExtensionSerializer
            extensionWriter = newExtensionSerializer();
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeMessage(1, getStartStopSelector());
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeMessage(2, getEndStopSelector());
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          output.writeInt32(3, propagatedModificationDelay_);
        }
        for (int i = 0; i < replacementStops_.size(); i++) {
          output.writeMessage(4, replacementStops_.get(i));
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          com.google.protobuf.GeneratedMessage.writeString(output, 5, serviceAlertId_);
        }
        if (((bitField0_ & 0x00000010) != 0)) {
          output.writeUInt64(6, lastModifiedTime_);
        }
        extensionWriter.writeUntil(10000, output);
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, getStartStopSelector());
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, getEndStopSelector());
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(3, propagatedModificationDelay_);
        }
        for (int i = 0; i < replacementStops_.size(); i++) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(4, replacementStops_.get(i));
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          size += com.google.protobuf.GeneratedMessage.computeStringSize(5, serviceAlertId_);
        }
        if (((bitField0_ & 0x00000010) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(6, lastModifiedTime_);
        }
        size += extensionsSerializedSize();
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.TripModifications.Modification)) {
          return super.equals(obj);
        }
        com.google.transit.realtime.GtfsRealtime.TripModifications.Modification other = (com.google.transit.realtime.GtfsRealtime.TripModifications.Modification) obj;

        if (hasStartStopSelector() != other.hasStartStopSelector()) return false;
        if (hasStartStopSelector()) {
          if (!getStartStopSelector()
              .equals(other.getStartStopSelector())) return false;
        }
        if (hasEndStopSelector() != other.hasEndStopSelector()) return false;
        if (hasEndStopSelector()) {
          if (!getEndStopSelector()
              .equals(other.getEndStopSelector())) return false;
        }
        if (hasPropagatedModificationDelay() != other.hasPropagatedModificationDelay()) return false;
        if (hasPropagatedModificationDelay()) {
          if (getPropagatedModificationDelay()
              != other.getPropagatedModificationDelay()) return false;
        }
        if (!getReplacementStopsList()
            .equals(other.getReplacementStopsList())) return false;
        if (hasServiceAlertId() != other.hasServiceAlertId()) return false;
        if (hasServiceAlertId()) {
          if (!getServiceAlertId()
              .equals(other.getServiceAlertId())) return false;
        }
        if (hasLastModifiedTime() != other.hasLastModifiedTime()) return false;
        if (hasLastModifiedTime()) {
          if (getLastModifiedTime()
              != other.getLastModifiedTime()) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        if (!getExtensionFields().equals(other.getExtensionFields()))
          return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasStartStopSelector()) {
          hash = (37 * hash) + START_STOP_SELECTOR_FIELD_NUMBER;
          hash = (53 * hash) + getStartStopSelector().hashCode();
        }
        if (hasEndStopSelector()) {
          hash = (37 * hash) + END_STOP_SELECTOR_FIELD_NUMBER;
          hash = (53 * hash) + getEndStopSelector().hashCode();
        }
        if (hasPropagatedModificationDelay()) {
          hash = (37 * hash) + PROPAGATED_MODIFICATION_DELAY_FIELD_NUMBER;
          hash = (53 * hash) + getPropagatedModificationDelay();
        }
        if (getReplacementStopsCount() > 0) {
          hash = (37 * hash) + REPLACEMENT_STOPS_FIELD_NUMBER;
          hash = (53 * hash) + getReplacementStopsList().hashCode();
        }
        if (hasServiceAlertId()) {
          hash = (37 * hash) + SERVICE_ALERT_ID_FIELD_NUMBER;
          hash = (53 * hash) + getServiceAlertId().hashCode();
        }
        if (hasLastModifiedTime()) {
          hash = (37 * hash) + LAST_MODIFIED_TIME_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getLastModifiedTime());
        }
        hash = hashFields(hash, getExtensionFields());
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.google.transit.realtime.GtfsRealtime.TripModifications.Modification parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripModifications.Modification parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripModifications.Modification parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripModifications.Modification parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripModifications.Modification parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripModifications.Modification parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripModifications.Modification parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripModifications.Modification parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static com.google.transit.realtime.GtfsRealtime.TripModifications.Modification parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static com.google.transit.realtime.GtfsRealtime.TripModifications.Modification parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripModifications.Modification parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripModifications.Modification parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.TripModifications.Modification prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * A `Modification` message replaces a span of n stop times from each affected trip starting at `start_stop_selector`.
       * </pre>
       *
       * Protobuf type {@code transit_realtime.TripModifications.Modification}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.ExtendableBuilder<
            com.google.transit.realtime.GtfsRealtime.TripModifications.Modification, Builder> implements
          // @@protoc_insertion_point(builder_implements:transit_realtime.TripModifications.Modification)
          com.google.transit.realtime.GtfsRealtime.TripModifications.ModificationOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripModifications_Modification_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripModifications_Modification_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.google.transit.realtime.GtfsRealtime.TripModifications.Modification.class, com.google.transit.realtime.GtfsRealtime.TripModifications.Modification.Builder.class);
        }

        // Construct using com.google.transit.realtime.GtfsRealtime.TripModifications.Modification.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessage
                  .alwaysUseFieldBuilders) {
            getStartStopSelectorFieldBuilder();
            getEndStopSelectorFieldBuilder();
            getReplacementStopsFieldBuilder();
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          startStopSelector_ = null;
          if (startStopSelectorBuilder_ != null) {
            startStopSelectorBuilder_.dispose();
            startStopSelectorBuilder_ = null;
          }
          endStopSelector_ = null;
          if (endStopSelectorBuilder_ != null) {
            endStopSelectorBuilder_.dispose();
            endStopSelectorBuilder_ = null;
          }
          propagatedModificationDelay_ = 0;
          if (replacementStopsBuilder_ == null) {
            replacementStops_ = java.util.Collections.emptyList();
          } else {
            replacementStops_ = null;
            replacementStopsBuilder_.clear();
          }
          bitField0_ = (bitField0_ & ~0x00000008);
          serviceAlertId_ = "";
          lastModifiedTime_ = 0L;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripModifications_Modification_descriptor;
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TripModifications.Modification getDefaultInstanceForType() {
          return com.google.transit.realtime.GtfsRealtime.TripModifications.Modification.getDefaultInstance();
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TripModifications.Modification build() {
          com.google.transit.realtime.GtfsRealtime.TripModifications.Modification result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TripModifications.Modification buildPartial() {
          com.google.transit.realtime.GtfsRealtime.TripModifications.Modification result = new com.google.transit.realtime.GtfsRealtime.TripModifications.Modification(this);
          buildPartialRepeatedFields(result);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartialRepeatedFields(com.google.transit.realtime.GtfsRealtime.TripModifications.Modification result) {
          if (replacementStopsBuilder_ == null) {
            if (((bitField0_ & 0x00000008) != 0)) {
              replacementStops_ = java.util.Collections.unmodifiableList(replacementStops_);
              bitField0_ = (bitField0_ & ~0x00000008);
            }
            result.replacementStops_ = replacementStops_;
          } else {
            result.replacementStops_ = replacementStopsBuilder_.build();
          }
        }

        private void buildPartial0(com.google.transit.realtime.GtfsRealtime.TripModifications.Modification result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.startStopSelector_ = startStopSelectorBuilder_ == null
                ? startStopSelector_
                : startStopSelectorBuilder_.build();
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.endStopSelector_ = endStopSelectorBuilder_ == null
                ? endStopSelector_
                : endStopSelectorBuilder_.build();
            to_bitField0_ |= 0x00000002;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.propagatedModificationDelay_ = propagatedModificationDelay_;
            to_bitField0_ |= 0x00000004;
          }
          if (((from_bitField0_ & 0x00000010) != 0)) {
            result.serviceAlertId_ = serviceAlertId_;
            to_bitField0_ |= 0x00000008;
          }
          if (((from_bitField0_ & 0x00000020) != 0)) {
            result.lastModifiedTime_ = lastModifiedTime_;
            to_bitField0_ |= 0x00000010;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof com.google.transit.realtime.GtfsRealtime.TripModifications.Modification) {
            return mergeFrom((com.google.transit.realtime.GtfsRealtime.TripModifications.Modification)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.TripModifications.Modification other) {
          if (other == com.google.transit.realtime.GtfsRealtime.TripModifications.Modification.getDefaultInstance()) return this;
          if (other.hasStartStopSelector()) {
            mergeStartStopSelector(other.getStartStopSelector());
          }
          if (other.hasEndStopSelector()) {
            mergeEndStopSelector(other.getEndStopSelector());
          }
          if (other.hasPropagatedModificationDelay()) {
            setPropagatedModificationDelay(other.getPropagatedModificationDelay());
          }
          if (replacementStopsBuilder_ == null) {
            if (!other.replacementStops_.isEmpty()) {
              if (replacementStops_.isEmpty()) {
                replacementStops_ = other.replacementStops_;
                bitField0_ = (bitField0_ & ~0x00000008);
              } else {
                ensureReplacementStopsIsMutable();
                replacementStops_.addAll(other.replacementStops_);
              }
              onChanged();
            }
          } else {
            if (!other.replacementStops_.isEmpty()) {
              if (replacementStopsBuilder_.isEmpty()) {
                replacementStopsBuilder_.dispose();
                replacementStopsBuilder_ = null;
                replacementStops_ = other.replacementStops_;
                bitField0_ = (bitField0_ & ~0x00000008);
                replacementStopsBuilder_ = 
                  com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                     getReplacementStopsFieldBuilder() : null;
              } else {
                replacementStopsBuilder_.addAllMessages(other.replacementStops_);
              }
            }
          }
          if (other.hasServiceAlertId()) {
            serviceAlertId_ = other.serviceAlertId_;
            bitField0_ |= 0x00000010;
            onChanged();
          }
          if (other.hasLastModifiedTime()) {
            setLastModifiedTime(other.getLastModifiedTime());
          }
          this.mergeExtensionFields(other);
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          if (hasStartStopSelector()) {
            if (!getStartStopSelector().isInitialized()) {
              return false;
            }
          }
          if (hasEndStopSelector()) {
            if (!getEndStopSelector().isInitialized()) {
              return false;
            }
          }
          for (int i = 0; i < getReplacementStopsCount(); i++) {
            if (!getReplacementStops(i).isInitialized()) {
              return false;
            }
          }
          if (!extensionsAreInitialized()) {
            return false;
          }
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 10: {
                  input.readMessage(
                      getStartStopSelectorFieldBuilder().getBuilder(),
                      extensionRegistry);
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
                case 18: {
                  input.readMessage(
                      getEndStopSelectorFieldBuilder().getBuilder(),
                      extensionRegistry);
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
                case 24: {
                  propagatedModificationDelay_ = input.readInt32();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 24
                case 34: {
                  com.google.transit.realtime.GtfsRealtime.ReplacementStop m =
                      input.readMessage(
                          com.google.transit.realtime.GtfsRealtime.ReplacementStop.parser(),
                          extensionRegistry);
                  if (replacementStopsBuilder_ == null) {
                    ensureReplacementStopsIsMutable();
                    replacementStops_.add(m);
                  } else {
                    replacementStopsBuilder_.addMessage(m);
                  }
                  break;
                } // case 34
                case 42: {
                  serviceAlertId_ = input.readBytes();
                  bitField0_ |= 0x00000010;
                  break;
                } // case 42
                case 48: {
                  lastModifiedTime_ = input.readUInt64();
                  bitField0_ |= 0x00000020;
                  break;
                } // case 48
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private com.google.transit.realtime.GtfsRealtime.StopSelector startStopSelector_;
        private com.google.protobuf.SingleFieldBuilder<
            com.google.transit.realtime.GtfsRealtime.StopSelector, com.google.transit.realtime.GtfsRealtime.StopSelector.Builder, com.google.transit.realtime.GtfsRealtime.StopSelectorOrBuilder> startStopSelectorBuilder_;
        /**
         * <pre>
         * The stop selector of the first stop_time of the original trip that is to be affected by this modification.
         * Used in conjuction with `end_stop_selector`. 
         * `start_stop_selector` is required and is used to define the reference stop used with `travel_time_to_stop`.
         * </pre>
         *
         * <code>optional .transit_realtime.StopSelector start_stop_selector = 1;</code>
         * @return Whether the startStopSelector field is set.
         */
        public boolean hasStartStopSelector() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * The stop selector of the first stop_time of the original trip that is to be affected by this modification.
         * Used in conjuction with `end_stop_selector`. 
         * `start_stop_selector` is required and is used to define the reference stop used with `travel_time_to_stop`.
         * </pre>
         *
         * <code>optional .transit_realtime.StopSelector start_stop_selector = 1;</code>
         * @return The startStopSelector.
         */
        public com.google.transit.realtime.GtfsRealtime.StopSelector getStartStopSelector() {
          if (startStopSelectorBuilder_ == null) {
            return startStopSelector_ == null ? com.google.transit.realtime.GtfsRealtime.StopSelector.getDefaultInstance() : startStopSelector_;
          } else {
            return startStopSelectorBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * The stop selector of the first stop_time of the original trip that is to be affected by this modification.
         * Used in conjuction with `end_stop_selector`. 
         * `start_stop_selector` is required and is used to define the reference stop used with `travel_time_to_stop`.
         * </pre>
         *
         * <code>optional .transit_realtime.StopSelector start_stop_selector = 1;</code>
         */
        public Builder setStartStopSelector(com.google.transit.realtime.GtfsRealtime.StopSelector value) {
          if (startStopSelectorBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            startStopSelector_ = value;
          } else {
            startStopSelectorBuilder_.setMessage(value);
          }
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The stop selector of the first stop_time of the original trip that is to be affected by this modification.
         * Used in conjuction with `end_stop_selector`. 
         * `start_stop_selector` is required and is used to define the reference stop used with `travel_time_to_stop`.
         * </pre>
         *
         * <code>optional .transit_realtime.StopSelector start_stop_selector = 1;</code>
         */
        public Builder setStartStopSelector(
            com.google.transit.realtime.GtfsRealtime.StopSelector.Builder builderForValue) {
          if (startStopSelectorBuilder_ == null) {
            startStopSelector_ = builderForValue.build();
          } else {
            startStopSelectorBuilder_.setMessage(builderForValue.build());
          }
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The stop selector of the first stop_time of the original trip that is to be affected by this modification.
         * Used in conjuction with `end_stop_selector`. 
         * `start_stop_selector` is required and is used to define the reference stop used with `travel_time_to_stop`.
         * </pre>
         *
         * <code>optional .transit_realtime.StopSelector start_stop_selector = 1;</code>
         */
        public Builder mergeStartStopSelector(com.google.transit.realtime.GtfsRealtime.StopSelector value) {
          if (startStopSelectorBuilder_ == null) {
            if (((bitField0_ & 0x00000001) != 0) &&
              startStopSelector_ != null &&
              startStopSelector_ != com.google.transit.realtime.GtfsRealtime.StopSelector.getDefaultInstance()) {
              getStartStopSelectorBuilder().mergeFrom(value);
            } else {
              startStopSelector_ = value;
            }
          } else {
            startStopSelectorBuilder_.mergeFrom(value);
          }
          if (startStopSelector_ != null) {
            bitField0_ |= 0x00000001;
            onChanged();
          }
          return this;
        }
        /**
         * <pre>
         * The stop selector of the first stop_time of the original trip that is to be affected by this modification.
         * Used in conjuction with `end_stop_selector`. 
         * `start_stop_selector` is required and is used to define the reference stop used with `travel_time_to_stop`.
         * </pre>
         *
         * <code>optional .transit_realtime.StopSelector start_stop_selector = 1;</code>
         */
        public Builder clearStartStopSelector() {
          bitField0_ = (bitField0_ & ~0x00000001);
          startStopSelector_ = null;
          if (startStopSelectorBuilder_ != null) {
            startStopSelectorBuilder_.dispose();
            startStopSelectorBuilder_ = null;
          }
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The stop selector of the first stop_time of the original trip that is to be affected by this modification.
         * Used in conjuction with `end_stop_selector`. 
         * `start_stop_selector` is required and is used to define the reference stop used with `travel_time_to_stop`.
         * </pre>
         *
         * <code>optional .transit_realtime.StopSelector start_stop_selector = 1;</code>
         */
        public com.google.transit.realtime.GtfsRealtime.StopSelector.Builder getStartStopSelectorBuilder() {
          bitField0_ |= 0x00000001;
          onChanged();
          return getStartStopSelectorFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * The stop selector of the first stop_time of the original trip that is to be affected by this modification.
         * Used in conjuction with `end_stop_selector`. 
         * `start_stop_selector` is required and is used to define the reference stop used with `travel_time_to_stop`.
         * </pre>
         *
         * <code>optional .transit_realtime.StopSelector start_stop_selector = 1;</code>
         */
        public com.google.transit.realtime.GtfsRealtime.StopSelectorOrBuilder getStartStopSelectorOrBuilder() {
          if (startStopSelectorBuilder_ != null) {
            return startStopSelectorBuilder_.getMessageOrBuilder();
          } else {
            return startStopSelector_ == null ?
                com.google.transit.realtime.GtfsRealtime.StopSelector.getDefaultInstance() : startStopSelector_;
          }
        }
        /**
         * <pre>
         * The stop selector of the first stop_time of the original trip that is to be affected by this modification.
         * Used in conjuction with `end_stop_selector`. 
         * `start_stop_selector` is required and is used to define the reference stop used with `travel_time_to_stop`.
         * </pre>
         *
         * <code>optional .transit_realtime.StopSelector start_stop_selector = 1;</code>
         */
        private com.google.protobuf.SingleFieldBuilder<
            com.google.transit.realtime.GtfsRealtime.StopSelector, com.google.transit.realtime.GtfsRealtime.StopSelector.Builder, com.google.transit.realtime.GtfsRealtime.StopSelectorOrBuilder> 
            getStartStopSelectorFieldBuilder() {
          if (startStopSelectorBuilder_ == null) {
            startStopSelectorBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                com.google.transit.realtime.GtfsRealtime.StopSelector, com.google.transit.realtime.GtfsRealtime.StopSelector.Builder, com.google.transit.realtime.GtfsRealtime.StopSelectorOrBuilder>(
                    getStartStopSelector(),
                    getParentForChildren(),
                    isClean());
            startStopSelector_ = null;
          }
          return startStopSelectorBuilder_;
        }

        private com.google.transit.realtime.GtfsRealtime.StopSelector endStopSelector_;
        private com.google.protobuf.SingleFieldBuilder<
            com.google.transit.realtime.GtfsRealtime.StopSelector, com.google.transit.realtime.GtfsRealtime.StopSelector.Builder, com.google.transit.realtime.GtfsRealtime.StopSelectorOrBuilder> endStopSelectorBuilder_;
        /**
         * <pre>
         * The stop selector of the last stop of the original trip that is to be affected by this modification. 
         * The selection is inclusive, so if only one stop_time is replaced by that modification, `start_stop_selector` and `end_stop_selector` must be equivalent.
         * If no stop_time is replaced, `end_stop_selector` must not be provided. It's otherwise required.
         * </pre>
         *
         * <code>optional .transit_realtime.StopSelector end_stop_selector = 2;</code>
         * @return Whether the endStopSelector field is set.
         */
        public boolean hasEndStopSelector() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * The stop selector of the last stop of the original trip that is to be affected by this modification. 
         * The selection is inclusive, so if only one stop_time is replaced by that modification, `start_stop_selector` and `end_stop_selector` must be equivalent.
         * If no stop_time is replaced, `end_stop_selector` must not be provided. It's otherwise required.
         * </pre>
         *
         * <code>optional .transit_realtime.StopSelector end_stop_selector = 2;</code>
         * @return The endStopSelector.
         */
        public com.google.transit.realtime.GtfsRealtime.StopSelector getEndStopSelector() {
          if (endStopSelectorBuilder_ == null) {
            return endStopSelector_ == null ? com.google.transit.realtime.GtfsRealtime.StopSelector.getDefaultInstance() : endStopSelector_;
          } else {
            return endStopSelectorBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * The stop selector of the last stop of the original trip that is to be affected by this modification. 
         * The selection is inclusive, so if only one stop_time is replaced by that modification, `start_stop_selector` and `end_stop_selector` must be equivalent.
         * If no stop_time is replaced, `end_stop_selector` must not be provided. It's otherwise required.
         * </pre>
         *
         * <code>optional .transit_realtime.StopSelector end_stop_selector = 2;</code>
         */
        public Builder setEndStopSelector(com.google.transit.realtime.GtfsRealtime.StopSelector value) {
          if (endStopSelectorBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            endStopSelector_ = value;
          } else {
            endStopSelectorBuilder_.setMessage(value);
          }
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The stop selector of the last stop of the original trip that is to be affected by this modification. 
         * The selection is inclusive, so if only one stop_time is replaced by that modification, `start_stop_selector` and `end_stop_selector` must be equivalent.
         * If no stop_time is replaced, `end_stop_selector` must not be provided. It's otherwise required.
         * </pre>
         *
         * <code>optional .transit_realtime.StopSelector end_stop_selector = 2;</code>
         */
        public Builder setEndStopSelector(
            com.google.transit.realtime.GtfsRealtime.StopSelector.Builder builderForValue) {
          if (endStopSelectorBuilder_ == null) {
            endStopSelector_ = builderForValue.build();
          } else {
            endStopSelectorBuilder_.setMessage(builderForValue.build());
          }
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The stop selector of the last stop of the original trip that is to be affected by this modification. 
         * The selection is inclusive, so if only one stop_time is replaced by that modification, `start_stop_selector` and `end_stop_selector` must be equivalent.
         * If no stop_time is replaced, `end_stop_selector` must not be provided. It's otherwise required.
         * </pre>
         *
         * <code>optional .transit_realtime.StopSelector end_stop_selector = 2;</code>
         */
        public Builder mergeEndStopSelector(com.google.transit.realtime.GtfsRealtime.StopSelector value) {
          if (endStopSelectorBuilder_ == null) {
            if (((bitField0_ & 0x00000002) != 0) &&
              endStopSelector_ != null &&
              endStopSelector_ != com.google.transit.realtime.GtfsRealtime.StopSelector.getDefaultInstance()) {
              getEndStopSelectorBuilder().mergeFrom(value);
            } else {
              endStopSelector_ = value;
            }
          } else {
            endStopSelectorBuilder_.mergeFrom(value);
          }
          if (endStopSelector_ != null) {
            bitField0_ |= 0x00000002;
            onChanged();
          }
          return this;
        }
        /**
         * <pre>
         * The stop selector of the last stop of the original trip that is to be affected by this modification. 
         * The selection is inclusive, so if only one stop_time is replaced by that modification, `start_stop_selector` and `end_stop_selector` must be equivalent.
         * If no stop_time is replaced, `end_stop_selector` must not be provided. It's otherwise required.
         * </pre>
         *
         * <code>optional .transit_realtime.StopSelector end_stop_selector = 2;</code>
         */
        public Builder clearEndStopSelector() {
          bitField0_ = (bitField0_ & ~0x00000002);
          endStopSelector_ = null;
          if (endStopSelectorBuilder_ != null) {
            endStopSelectorBuilder_.dispose();
            endStopSelectorBuilder_ = null;
          }
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The stop selector of the last stop of the original trip that is to be affected by this modification. 
         * The selection is inclusive, so if only one stop_time is replaced by that modification, `start_stop_selector` and `end_stop_selector` must be equivalent.
         * If no stop_time is replaced, `end_stop_selector` must not be provided. It's otherwise required.
         * </pre>
         *
         * <code>optional .transit_realtime.StopSelector end_stop_selector = 2;</code>
         */
        public com.google.transit.realtime.GtfsRealtime.StopSelector.Builder getEndStopSelectorBuilder() {
          bitField0_ |= 0x00000002;
          onChanged();
          return getEndStopSelectorFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * The stop selector of the last stop of the original trip that is to be affected by this modification. 
         * The selection is inclusive, so if only one stop_time is replaced by that modification, `start_stop_selector` and `end_stop_selector` must be equivalent.
         * If no stop_time is replaced, `end_stop_selector` must not be provided. It's otherwise required.
         * </pre>
         *
         * <code>optional .transit_realtime.StopSelector end_stop_selector = 2;</code>
         */
        public com.google.transit.realtime.GtfsRealtime.StopSelectorOrBuilder getEndStopSelectorOrBuilder() {
          if (endStopSelectorBuilder_ != null) {
            return endStopSelectorBuilder_.getMessageOrBuilder();
          } else {
            return endStopSelector_ == null ?
                com.google.transit.realtime.GtfsRealtime.StopSelector.getDefaultInstance() : endStopSelector_;
          }
        }
        /**
         * <pre>
         * The stop selector of the last stop of the original trip that is to be affected by this modification. 
         * The selection is inclusive, so if only one stop_time is replaced by that modification, `start_stop_selector` and `end_stop_selector` must be equivalent.
         * If no stop_time is replaced, `end_stop_selector` must not be provided. It's otherwise required.
         * </pre>
         *
         * <code>optional .transit_realtime.StopSelector end_stop_selector = 2;</code>
         */
        private com.google.protobuf.SingleFieldBuilder<
            com.google.transit.realtime.GtfsRealtime.StopSelector, com.google.transit.realtime.GtfsRealtime.StopSelector.Builder, com.google.transit.realtime.GtfsRealtime.StopSelectorOrBuilder> 
            getEndStopSelectorFieldBuilder() {
          if (endStopSelectorBuilder_ == null) {
            endStopSelectorBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                com.google.transit.realtime.GtfsRealtime.StopSelector, com.google.transit.realtime.GtfsRealtime.StopSelector.Builder, com.google.transit.realtime.GtfsRealtime.StopSelectorOrBuilder>(
                    getEndStopSelector(),
                    getParentForChildren(),
                    isClean());
            endStopSelector_ = null;
          }
          return endStopSelectorBuilder_;
        }

        private int propagatedModificationDelay_ ;
        /**
         * <pre>
         * The number of seconds of delay to add to all departure and arrival times following the end of this modification. 
         * If multiple modifications apply to the same trip, the delays accumulate as the trip advances. 
         * </pre>
         *
         * <code>optional int32 propagated_modification_delay = 3 [default = 0];</code>
         * @return Whether the propagatedModificationDelay field is set.
         */
        @java.lang.Override
        public boolean hasPropagatedModificationDelay() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * The number of seconds of delay to add to all departure and arrival times following the end of this modification. 
         * If multiple modifications apply to the same trip, the delays accumulate as the trip advances. 
         * </pre>
         *
         * <code>optional int32 propagated_modification_delay = 3 [default = 0];</code>
         * @return The propagatedModificationDelay.
         */
        @java.lang.Override
        public int getPropagatedModificationDelay() {
          return propagatedModificationDelay_;
        }
        /**
         * <pre>
         * The number of seconds of delay to add to all departure and arrival times following the end of this modification. 
         * If multiple modifications apply to the same trip, the delays accumulate as the trip advances. 
         * </pre>
         *
         * <code>optional int32 propagated_modification_delay = 3 [default = 0];</code>
         * @param value The propagatedModificationDelay to set.
         * @return This builder for chaining.
         */
        public Builder setPropagatedModificationDelay(int value) {

          propagatedModificationDelay_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The number of seconds of delay to add to all departure and arrival times following the end of this modification. 
         * If multiple modifications apply to the same trip, the delays accumulate as the trip advances. 
         * </pre>
         *
         * <code>optional int32 propagated_modification_delay = 3 [default = 0];</code>
         * @return This builder for chaining.
         */
        public Builder clearPropagatedModificationDelay() {
          bitField0_ = (bitField0_ & ~0x00000004);
          propagatedModificationDelay_ = 0;
          onChanged();
          return this;
        }

        private java.util.List<com.google.transit.realtime.GtfsRealtime.ReplacementStop> replacementStops_ =
          java.util.Collections.emptyList();
        private void ensureReplacementStopsIsMutable() {
          if (!((bitField0_ & 0x00000008) != 0)) {
            replacementStops_ = new java.util.ArrayList<com.google.transit.realtime.GtfsRealtime.ReplacementStop>(replacementStops_);
            bitField0_ |= 0x00000008;
           }
        }

        private com.google.protobuf.RepeatedFieldBuilder<
            com.google.transit.realtime.GtfsRealtime.ReplacementStop, com.google.transit.realtime.GtfsRealtime.ReplacementStop.Builder, com.google.transit.realtime.GtfsRealtime.ReplacementStopOrBuilder> replacementStopsBuilder_;

        /**
         * <pre>
         * A list of replacement stops, replacing those of the original trip. 
         * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
         * </pre>
         *
         * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
         */
        public java.util.List<com.google.transit.realtime.GtfsRealtime.ReplacementStop> getReplacementStopsList() {
          if (replacementStopsBuilder_ == null) {
            return java.util.Collections.unmodifiableList(replacementStops_);
          } else {
            return replacementStopsBuilder_.getMessageList();
          }
        }
        /**
         * <pre>
         * A list of replacement stops, replacing those of the original trip. 
         * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
         * </pre>
         *
         * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
         */
        public int getReplacementStopsCount() {
          if (replacementStopsBuilder_ == null) {
            return replacementStops_.size();
          } else {
            return replacementStopsBuilder_.getCount();
          }
        }
        /**
         * <pre>
         * A list of replacement stops, replacing those of the original trip. 
         * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
         * </pre>
         *
         * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
         */
        public com.google.transit.realtime.GtfsRealtime.ReplacementStop getReplacementStops(int index) {
          if (replacementStopsBuilder_ == null) {
            return replacementStops_.get(index);
          } else {
            return replacementStopsBuilder_.getMessage(index);
          }
        }
        /**
         * <pre>
         * A list of replacement stops, replacing those of the original trip. 
         * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
         * </pre>
         *
         * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
         */
        public Builder setReplacementStops(
            int index, com.google.transit.realtime.GtfsRealtime.ReplacementStop value) {
          if (replacementStopsBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureReplacementStopsIsMutable();
            replacementStops_.set(index, value);
            onChanged();
          } else {
            replacementStopsBuilder_.setMessage(index, value);
          }
          return this;
        }
        /**
         * <pre>
         * A list of replacement stops, replacing those of the original trip. 
         * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
         * </pre>
         *
         * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
         */
        public Builder setReplacementStops(
            int index, com.google.transit.realtime.GtfsRealtime.ReplacementStop.Builder builderForValue) {
          if (replacementStopsBuilder_ == null) {
            ensureReplacementStopsIsMutable();
            replacementStops_.set(index, builderForValue.build());
            onChanged();
          } else {
            replacementStopsBuilder_.setMessage(index, builderForValue.build());
          }
          return this;
        }
        /**
         * <pre>
         * A list of replacement stops, replacing those of the original trip. 
         * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
         * </pre>
         *
         * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
         */
        public Builder addReplacementStops(com.google.transit.realtime.GtfsRealtime.ReplacementStop value) {
          if (replacementStopsBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureReplacementStopsIsMutable();
            replacementStops_.add(value);
            onChanged();
          } else {
            replacementStopsBuilder_.addMessage(value);
          }
          return this;
        }
        /**
         * <pre>
         * A list of replacement stops, replacing those of the original trip. 
         * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
         * </pre>
         *
         * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
         */
        public Builder addReplacementStops(
            int index, com.google.transit.realtime.GtfsRealtime.ReplacementStop value) {
          if (replacementStopsBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureReplacementStopsIsMutable();
            replacementStops_.add(index, value);
            onChanged();
          } else {
            replacementStopsBuilder_.addMessage(index, value);
          }
          return this;
        }
        /**
         * <pre>
         * A list of replacement stops, replacing those of the original trip. 
         * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
         * </pre>
         *
         * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
         */
        public Builder addReplacementStops(
            com.google.transit.realtime.GtfsRealtime.ReplacementStop.Builder builderForValue) {
          if (replacementStopsBuilder_ == null) {
            ensureReplacementStopsIsMutable();
            replacementStops_.add(builderForValue.build());
            onChanged();
          } else {
            replacementStopsBuilder_.addMessage(builderForValue.build());
          }
          return this;
        }
        /**
         * <pre>
         * A list of replacement stops, replacing those of the original trip. 
         * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
         * </pre>
         *
         * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
         */
        public Builder addReplacementStops(
            int index, com.google.transit.realtime.GtfsRealtime.ReplacementStop.Builder builderForValue) {
          if (replacementStopsBuilder_ == null) {
            ensureReplacementStopsIsMutable();
            replacementStops_.add(index, builderForValue.build());
            onChanged();
          } else {
            replacementStopsBuilder_.addMessage(index, builderForValue.build());
          }
          return this;
        }
        /**
         * <pre>
         * A list of replacement stops, replacing those of the original trip. 
         * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
         * </pre>
         *
         * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
         */
        public Builder addAllReplacementStops(
            java.lang.Iterable<? extends com.google.transit.realtime.GtfsRealtime.ReplacementStop> values) {
          if (replacementStopsBuilder_ == null) {
            ensureReplacementStopsIsMutable();
            com.google.protobuf.AbstractMessageLite.Builder.addAll(
                values, replacementStops_);
            onChanged();
          } else {
            replacementStopsBuilder_.addAllMessages(values);
          }
          return this;
        }
        /**
         * <pre>
         * A list of replacement stops, replacing those of the original trip. 
         * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
         * </pre>
         *
         * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
         */
        public Builder clearReplacementStops() {
          if (replacementStopsBuilder_ == null) {
            replacementStops_ = java.util.Collections.emptyList();
            bitField0_ = (bitField0_ & ~0x00000008);
            onChanged();
          } else {
            replacementStopsBuilder_.clear();
          }
          return this;
        }
        /**
         * <pre>
         * A list of replacement stops, replacing those of the original trip. 
         * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
         * </pre>
         *
         * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
         */
        public Builder removeReplacementStops(int index) {
          if (replacementStopsBuilder_ == null) {
            ensureReplacementStopsIsMutable();
            replacementStops_.remove(index);
            onChanged();
          } else {
            replacementStopsBuilder_.remove(index);
          }
          return this;
        }
        /**
         * <pre>
         * A list of replacement stops, replacing those of the original trip. 
         * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
         * </pre>
         *
         * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
         */
        public com.google.transit.realtime.GtfsRealtime.ReplacementStop.Builder getReplacementStopsBuilder(
            int index) {
          return getReplacementStopsFieldBuilder().getBuilder(index);
        }
        /**
         * <pre>
         * A list of replacement stops, replacing those of the original trip. 
         * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
         * </pre>
         *
         * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
         */
        public com.google.transit.realtime.GtfsRealtime.ReplacementStopOrBuilder getReplacementStopsOrBuilder(
            int index) {
          if (replacementStopsBuilder_ == null) {
            return replacementStops_.get(index);  } else {
            return replacementStopsBuilder_.getMessageOrBuilder(index);
          }
        }
        /**
         * <pre>
         * A list of replacement stops, replacing those of the original trip. 
         * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
         * </pre>
         *
         * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
         */
        public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.ReplacementStopOrBuilder> 
             getReplacementStopsOrBuilderList() {
          if (replacementStopsBuilder_ != null) {
            return replacementStopsBuilder_.getMessageOrBuilderList();
          } else {
            return java.util.Collections.unmodifiableList(replacementStops_);
          }
        }
        /**
         * <pre>
         * A list of replacement stops, replacing those of the original trip. 
         * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
         * </pre>
         *
         * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
         */
        public com.google.transit.realtime.GtfsRealtime.ReplacementStop.Builder addReplacementStopsBuilder() {
          return getReplacementStopsFieldBuilder().addBuilder(
              com.google.transit.realtime.GtfsRealtime.ReplacementStop.getDefaultInstance());
        }
        /**
         * <pre>
         * A list of replacement stops, replacing those of the original trip. 
         * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
         * </pre>
         *
         * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
         */
        public com.google.transit.realtime.GtfsRealtime.ReplacementStop.Builder addReplacementStopsBuilder(
            int index) {
          return getReplacementStopsFieldBuilder().addBuilder(
              index, com.google.transit.realtime.GtfsRealtime.ReplacementStop.getDefaultInstance());
        }
        /**
         * <pre>
         * A list of replacement stops, replacing those of the original trip. 
         * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
         * </pre>
         *
         * <code>repeated .transit_realtime.ReplacementStop replacement_stops = 4;</code>
         */
        public java.util.List<com.google.transit.realtime.GtfsRealtime.ReplacementStop.Builder> 
             getReplacementStopsBuilderList() {
          return getReplacementStopsFieldBuilder().getBuilderList();
        }
        private com.google.protobuf.RepeatedFieldBuilder<
            com.google.transit.realtime.GtfsRealtime.ReplacementStop, com.google.transit.realtime.GtfsRealtime.ReplacementStop.Builder, com.google.transit.realtime.GtfsRealtime.ReplacementStopOrBuilder> 
            getReplacementStopsFieldBuilder() {
          if (replacementStopsBuilder_ == null) {
            replacementStopsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                com.google.transit.realtime.GtfsRealtime.ReplacementStop, com.google.transit.realtime.GtfsRealtime.ReplacementStop.Builder, com.google.transit.realtime.GtfsRealtime.ReplacementStopOrBuilder>(
                    replacementStops_,
                    ((bitField0_ & 0x00000008) != 0),
                    getParentForChildren(),
                    isClean());
            replacementStops_ = null;
          }
          return replacementStopsBuilder_;
        }

        private java.lang.Object serviceAlertId_ = "";
        /**
         * <pre>
         * An `id` value from the `FeedEntity` message that contains the `Alert` describing this Modification for user-facing communication.
         * </pre>
         *
         * <code>optional string service_alert_id = 5;</code>
         * @return Whether the serviceAlertId field is set.
         */
        public boolean hasServiceAlertId() {
          return ((bitField0_ & 0x00000010) != 0);
        }
        /**
         * <pre>
         * An `id` value from the `FeedEntity` message that contains the `Alert` describing this Modification for user-facing communication.
         * </pre>
         *
         * <code>optional string service_alert_id = 5;</code>
         * @return The serviceAlertId.
         */
        public java.lang.String getServiceAlertId() {
          java.lang.Object ref = serviceAlertId_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              serviceAlertId_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * An `id` value from the `FeedEntity` message that contains the `Alert` describing this Modification for user-facing communication.
         * </pre>
         *
         * <code>optional string service_alert_id = 5;</code>
         * @return The bytes for serviceAlertId.
         */
        public com.google.protobuf.ByteString
            getServiceAlertIdBytes() {
          java.lang.Object ref = serviceAlertId_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            serviceAlertId_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * An `id` value from the `FeedEntity` message that contains the `Alert` describing this Modification for user-facing communication.
         * </pre>
         *
         * <code>optional string service_alert_id = 5;</code>
         * @param value The serviceAlertId to set.
         * @return This builder for chaining.
         */
        public Builder setServiceAlertId(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          serviceAlertId_ = value;
          bitField0_ |= 0x00000010;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * An `id` value from the `FeedEntity` message that contains the `Alert` describing this Modification for user-facing communication.
         * </pre>
         *
         * <code>optional string service_alert_id = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearServiceAlertId() {
          serviceAlertId_ = getDefaultInstance().getServiceAlertId();
          bitField0_ = (bitField0_ & ~0x00000010);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * An `id` value from the `FeedEntity` message that contains the `Alert` describing this Modification for user-facing communication.
         * </pre>
         *
         * <code>optional string service_alert_id = 5;</code>
         * @param value The bytes for serviceAlertId to set.
         * @return This builder for chaining.
         */
        public Builder setServiceAlertIdBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          serviceAlertId_ = value;
          bitField0_ |= 0x00000010;
          onChanged();
          return this;
        }

        private long lastModifiedTime_ ;
        /**
         * <pre>
         * This timestamp identifies the moment when the modification has last been changed.
         * In POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
         * </pre>
         *
         * <code>optional uint64 last_modified_time = 6;</code>
         * @return Whether the lastModifiedTime field is set.
         */
        @java.lang.Override
        public boolean hasLastModifiedTime() {
          return ((bitField0_ & 0x00000020) != 0);
        }
        /**
         * <pre>
         * This timestamp identifies the moment when the modification has last been changed.
         * In POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
         * </pre>
         *
         * <code>optional uint64 last_modified_time = 6;</code>
         * @return The lastModifiedTime.
         */
        @java.lang.Override
        public long getLastModifiedTime() {
          return lastModifiedTime_;
        }
        /**
         * <pre>
         * This timestamp identifies the moment when the modification has last been changed.
         * In POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
         * </pre>
         *
         * <code>optional uint64 last_modified_time = 6;</code>
         * @param value The lastModifiedTime to set.
         * @return This builder for chaining.
         */
        public Builder setLastModifiedTime(long value) {

          lastModifiedTime_ = value;
          bitField0_ |= 0x00000020;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * This timestamp identifies the moment when the modification has last been changed.
         * In POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
         * </pre>
         *
         * <code>optional uint64 last_modified_time = 6;</code>
         * @return This builder for chaining.
         */
        public Builder clearLastModifiedTime() {
          bitField0_ = (bitField0_ & ~0x00000020);
          lastModifiedTime_ = 0L;
          onChanged();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:transit_realtime.TripModifications.Modification)
      }

      // @@protoc_insertion_point(class_scope:transit_realtime.TripModifications.Modification)
      private static final com.google.transit.realtime.GtfsRealtime.TripModifications.Modification DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.TripModifications.Modification();
      }

      public static com.google.transit.realtime.GtfsRealtime.TripModifications.Modification getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<Modification>
          PARSER = new com.google.protobuf.AbstractParser<Modification>() {
        @java.lang.Override
        public Modification parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<Modification> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Modification> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TripModifications.Modification getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface SelectedTripsOrBuilder extends
        // @@protoc_insertion_point(interface_extends:transit_realtime.TripModifications.SelectedTrips)
        com.google.protobuf.GeneratedMessage.
            ExtendableMessageOrBuilder<SelectedTrips> {

      /**
       * <pre>
       * A list of trips affected with this replacement that all have the same new `shape_id`.
       * </pre>
       *
       * <code>repeated string trip_ids = 1;</code>
       * @return A list containing the tripIds.
       */
      java.util.List<java.lang.String>
          getTripIdsList();
      /**
       * <pre>
       * A list of trips affected with this replacement that all have the same new `shape_id`.
       * </pre>
       *
       * <code>repeated string trip_ids = 1;</code>
       * @return The count of tripIds.
       */
      int getTripIdsCount();
      /**
       * <pre>
       * A list of trips affected with this replacement that all have the same new `shape_id`.
       * </pre>
       *
       * <code>repeated string trip_ids = 1;</code>
       * @param index The index of the element to return.
       * @return The tripIds at the given index.
       */
      java.lang.String getTripIds(int index);
      /**
       * <pre>
       * A list of trips affected with this replacement that all have the same new `shape_id`.
       * </pre>
       *
       * <code>repeated string trip_ids = 1;</code>
       * @param index The index of the value to return.
       * @return The bytes of the tripIds at the given index.
       */
      com.google.protobuf.ByteString
          getTripIdsBytes(int index);

      /**
       * <pre>
       * The ID of the new shape for the modified trips in this SelectedTrips.
       * May refer to a new shape added using a GTFS-RT Shape message, or to an existing shape defined in the GTFS-Static feed’s shapes.txt.
       * </pre>
       *
       * <code>optional string shape_id = 2;</code>
       * @return Whether the shapeId field is set.
       */
      boolean hasShapeId();
      /**
       * <pre>
       * The ID of the new shape for the modified trips in this SelectedTrips.
       * May refer to a new shape added using a GTFS-RT Shape message, or to an existing shape defined in the GTFS-Static feed’s shapes.txt.
       * </pre>
       *
       * <code>optional string shape_id = 2;</code>
       * @return The shapeId.
       */
      java.lang.String getShapeId();
      /**
       * <pre>
       * The ID of the new shape for the modified trips in this SelectedTrips.
       * May refer to a new shape added using a GTFS-RT Shape message, or to an existing shape defined in the GTFS-Static feed’s shapes.txt.
       * </pre>
       *
       * <code>optional string shape_id = 2;</code>
       * @return The bytes for shapeId.
       */
      com.google.protobuf.ByteString
          getShapeIdBytes();
    }
    /**
     * Protobuf type {@code transit_realtime.TripModifications.SelectedTrips}
     */
    public static final class SelectedTrips extends
        com.google.protobuf.GeneratedMessage.ExtendableMessage<
          SelectedTrips> implements
        // @@protoc_insertion_point(message_implements:transit_realtime.TripModifications.SelectedTrips)
        SelectedTripsOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 28,
          /* patch= */ 3,
          /* suffix= */ "",
          SelectedTrips.class.getName());
      }
      // Use SelectedTrips.newBuilder() to construct.
      private SelectedTrips(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips, ?> builder) {
        super(builder);
      }
      private SelectedTrips() {
        tripIds_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        shapeId_ = "";
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripModifications_SelectedTrips_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripModifications_SelectedTrips_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips.class, com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips.Builder.class);
      }

      private int bitField0_;
      public static final int TRIP_IDS_FIELD_NUMBER = 1;
      @SuppressWarnings("serial")
      private com.google.protobuf.LazyStringArrayList tripIds_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      /**
       * <pre>
       * A list of trips affected with this replacement that all have the same new `shape_id`.
       * </pre>
       *
       * <code>repeated string trip_ids = 1;</code>
       * @return A list containing the tripIds.
       */
      public com.google.protobuf.ProtocolStringList
          getTripIdsList() {
        return tripIds_;
      }
      /**
       * <pre>
       * A list of trips affected with this replacement that all have the same new `shape_id`.
       * </pre>
       *
       * <code>repeated string trip_ids = 1;</code>
       * @return The count of tripIds.
       */
      public int getTripIdsCount() {
        return tripIds_.size();
      }
      /**
       * <pre>
       * A list of trips affected with this replacement that all have the same new `shape_id`.
       * </pre>
       *
       * <code>repeated string trip_ids = 1;</code>
       * @param index The index of the element to return.
       * @return The tripIds at the given index.
       */
      public java.lang.String getTripIds(int index) {
        return tripIds_.get(index);
      }
      /**
       * <pre>
       * A list of trips affected with this replacement that all have the same new `shape_id`.
       * </pre>
       *
       * <code>repeated string trip_ids = 1;</code>
       * @param index The index of the value to return.
       * @return The bytes of the tripIds at the given index.
       */
      public com.google.protobuf.ByteString
          getTripIdsBytes(int index) {
        return tripIds_.getByteString(index);
      }

      public static final int SHAPE_ID_FIELD_NUMBER = 2;
      @SuppressWarnings("serial")
      private volatile java.lang.Object shapeId_ = "";
      /**
       * <pre>
       * The ID of the new shape for the modified trips in this SelectedTrips.
       * May refer to a new shape added using a GTFS-RT Shape message, or to an existing shape defined in the GTFS-Static feed’s shapes.txt.
       * </pre>
       *
       * <code>optional string shape_id = 2;</code>
       * @return Whether the shapeId field is set.
       */
      @java.lang.Override
      public boolean hasShapeId() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The ID of the new shape for the modified trips in this SelectedTrips.
       * May refer to a new shape added using a GTFS-RT Shape message, or to an existing shape defined in the GTFS-Static feed’s shapes.txt.
       * </pre>
       *
       * <code>optional string shape_id = 2;</code>
       * @return The shapeId.
       */
      @java.lang.Override
      public java.lang.String getShapeId() {
        java.lang.Object ref = shapeId_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            shapeId_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * The ID of the new shape for the modified trips in this SelectedTrips.
       * May refer to a new shape added using a GTFS-RT Shape message, or to an existing shape defined in the GTFS-Static feed’s shapes.txt.
       * </pre>
       *
       * <code>optional string shape_id = 2;</code>
       * @return The bytes for shapeId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getShapeIdBytes() {
        java.lang.Object ref = shapeId_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          shapeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        if (!extensionsAreInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        com.google.protobuf.GeneratedMessage
          .ExtendableMessage.ExtensionSerializer
            extensionWriter = newExtensionSerializer();
        for (int i = 0; i < tripIds_.size(); i++) {
          com.google.protobuf.GeneratedMessage.writeString(output, 1, tripIds_.getRaw(i));
        }
        if (((bitField0_ & 0x00000001) != 0)) {
          com.google.protobuf.GeneratedMessage.writeString(output, 2, shapeId_);
        }
        extensionWriter.writeUntil(10000, output);
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        {
          int dataSize = 0;
          for (int i = 0; i < tripIds_.size(); i++) {
            dataSize += computeStringSizeNoTag(tripIds_.getRaw(i));
          }
          size += dataSize;
          size += 1 * getTripIdsList().size();
        }
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.GeneratedMessage.computeStringSize(2, shapeId_);
        }
        size += extensionsSerializedSize();
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips)) {
          return super.equals(obj);
        }
        com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips other = (com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips) obj;

        if (!getTripIdsList()
            .equals(other.getTripIdsList())) return false;
        if (hasShapeId() != other.hasShapeId()) return false;
        if (hasShapeId()) {
          if (!getShapeId()
              .equals(other.getShapeId())) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        if (!getExtensionFields().equals(other.getExtensionFields()))
          return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (getTripIdsCount() > 0) {
          hash = (37 * hash) + TRIP_IDS_FIELD_NUMBER;
          hash = (53 * hash) + getTripIdsList().hashCode();
        }
        if (hasShapeId()) {
          hash = (37 * hash) + SHAPE_ID_FIELD_NUMBER;
          hash = (53 * hash) + getShapeId().hashCode();
        }
        hash = hashFields(hash, getExtensionFields());
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code transit_realtime.TripModifications.SelectedTrips}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.ExtendableBuilder<
            com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips, Builder> implements
          // @@protoc_insertion_point(builder_implements:transit_realtime.TripModifications.SelectedTrips)
          com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTripsOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripModifications_SelectedTrips_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripModifications_SelectedTrips_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips.class, com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips.Builder.class);
        }

        // Construct using com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          tripIds_ =
              com.google.protobuf.LazyStringArrayList.emptyList();
          shapeId_ = "";
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripModifications_SelectedTrips_descriptor;
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips getDefaultInstanceForType() {
          return com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips.getDefaultInstance();
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips build() {
          com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips buildPartial() {
          com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips result = new com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips result) {
          int from_bitField0_ = bitField0_;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            tripIds_.makeImmutable();
            result.tripIds_ = tripIds_;
          }
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.shapeId_ = shapeId_;
            to_bitField0_ |= 0x00000001;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips) {
            return mergeFrom((com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips other) {
          if (other == com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips.getDefaultInstance()) return this;
          if (!other.tripIds_.isEmpty()) {
            if (tripIds_.isEmpty()) {
              tripIds_ = other.tripIds_;
              bitField0_ |= 0x00000001;
            } else {
              ensureTripIdsIsMutable();
              tripIds_.addAll(other.tripIds_);
            }
            onChanged();
          }
          if (other.hasShapeId()) {
            shapeId_ = other.shapeId_;
            bitField0_ |= 0x00000002;
            onChanged();
          }
          this.mergeExtensionFields(other);
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          if (!extensionsAreInitialized()) {
            return false;
          }
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 10: {
                  com.google.protobuf.ByteString bs = input.readBytes();
                  ensureTripIdsIsMutable();
                  tripIds_.add(bs);
                  break;
                } // case 10
                case 18: {
                  shapeId_ = input.readBytes();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private com.google.protobuf.LazyStringArrayList tripIds_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        private void ensureTripIdsIsMutable() {
          if (!tripIds_.isModifiable()) {
            tripIds_ = new com.google.protobuf.LazyStringArrayList(tripIds_);
          }
          bitField0_ |= 0x00000001;
        }
        /**
         * <pre>
         * A list of trips affected with this replacement that all have the same new `shape_id`.
         * </pre>
         *
         * <code>repeated string trip_ids = 1;</code>
         * @return A list containing the tripIds.
         */
        public com.google.protobuf.ProtocolStringList
            getTripIdsList() {
          tripIds_.makeImmutable();
          return tripIds_;
        }
        /**
         * <pre>
         * A list of trips affected with this replacement that all have the same new `shape_id`.
         * </pre>
         *
         * <code>repeated string trip_ids = 1;</code>
         * @return The count of tripIds.
         */
        public int getTripIdsCount() {
          return tripIds_.size();
        }
        /**
         * <pre>
         * A list of trips affected with this replacement that all have the same new `shape_id`.
         * </pre>
         *
         * <code>repeated string trip_ids = 1;</code>
         * @param index The index of the element to return.
         * @return The tripIds at the given index.
         */
        public java.lang.String getTripIds(int index) {
          return tripIds_.get(index);
        }
        /**
         * <pre>
         * A list of trips affected with this replacement that all have the same new `shape_id`.
         * </pre>
         *
         * <code>repeated string trip_ids = 1;</code>
         * @param index The index of the value to return.
         * @return The bytes of the tripIds at the given index.
         */
        public com.google.protobuf.ByteString
            getTripIdsBytes(int index) {
          return tripIds_.getByteString(index);
        }
        /**
         * <pre>
         * A list of trips affected with this replacement that all have the same new `shape_id`.
         * </pre>
         *
         * <code>repeated string trip_ids = 1;</code>
         * @param index The index to set the value at.
         * @param value The tripIds to set.
         * @return This builder for chaining.
         */
        public Builder setTripIds(
            int index, java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          ensureTripIdsIsMutable();
          tripIds_.set(index, value);
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * A list of trips affected with this replacement that all have the same new `shape_id`.
         * </pre>
         *
         * <code>repeated string trip_ids = 1;</code>
         * @param value The tripIds to add.
         * @return This builder for chaining.
         */
        public Builder addTripIds(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          ensureTripIdsIsMutable();
          tripIds_.add(value);
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * A list of trips affected with this replacement that all have the same new `shape_id`.
         * </pre>
         *
         * <code>repeated string trip_ids = 1;</code>
         * @param values The tripIds to add.
         * @return This builder for chaining.
         */
        public Builder addAllTripIds(
            java.lang.Iterable<java.lang.String> values) {
          ensureTripIdsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, tripIds_);
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * A list of trips affected with this replacement that all have the same new `shape_id`.
         * </pre>
         *
         * <code>repeated string trip_ids = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearTripIds() {
          tripIds_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * A list of trips affected with this replacement that all have the same new `shape_id`.
         * </pre>
         *
         * <code>repeated string trip_ids = 1;</code>
         * @param value The bytes of the tripIds to add.
         * @return This builder for chaining.
         */
        public Builder addTripIdsBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          ensureTripIdsIsMutable();
          tripIds_.add(value);
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }

        private java.lang.Object shapeId_ = "";
        /**
         * <pre>
         * The ID of the new shape for the modified trips in this SelectedTrips.
         * May refer to a new shape added using a GTFS-RT Shape message, or to an existing shape defined in the GTFS-Static feed’s shapes.txt.
         * </pre>
         *
         * <code>optional string shape_id = 2;</code>
         * @return Whether the shapeId field is set.
         */
        public boolean hasShapeId() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * The ID of the new shape for the modified trips in this SelectedTrips.
         * May refer to a new shape added using a GTFS-RT Shape message, or to an existing shape defined in the GTFS-Static feed’s shapes.txt.
         * </pre>
         *
         * <code>optional string shape_id = 2;</code>
         * @return The shapeId.
         */
        public java.lang.String getShapeId() {
          java.lang.Object ref = shapeId_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              shapeId_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * The ID of the new shape for the modified trips in this SelectedTrips.
         * May refer to a new shape added using a GTFS-RT Shape message, or to an existing shape defined in the GTFS-Static feed’s shapes.txt.
         * </pre>
         *
         * <code>optional string shape_id = 2;</code>
         * @return The bytes for shapeId.
         */
        public com.google.protobuf.ByteString
            getShapeIdBytes() {
          java.lang.Object ref = shapeId_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            shapeId_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * The ID of the new shape for the modified trips in this SelectedTrips.
         * May refer to a new shape added using a GTFS-RT Shape message, or to an existing shape defined in the GTFS-Static feed’s shapes.txt.
         * </pre>
         *
         * <code>optional string shape_id = 2;</code>
         * @param value The shapeId to set.
         * @return This builder for chaining.
         */
        public Builder setShapeId(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          shapeId_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The ID of the new shape for the modified trips in this SelectedTrips.
         * May refer to a new shape added using a GTFS-RT Shape message, or to an existing shape defined in the GTFS-Static feed’s shapes.txt.
         * </pre>
         *
         * <code>optional string shape_id = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearShapeId() {
          shapeId_ = getDefaultInstance().getShapeId();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The ID of the new shape for the modified trips in this SelectedTrips.
         * May refer to a new shape added using a GTFS-RT Shape message, or to an existing shape defined in the GTFS-Static feed’s shapes.txt.
         * </pre>
         *
         * <code>optional string shape_id = 2;</code>
         * @param value The bytes for shapeId to set.
         * @return This builder for chaining.
         */
        public Builder setShapeIdBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          shapeId_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:transit_realtime.TripModifications.SelectedTrips)
      }

      // @@protoc_insertion_point(class_scope:transit_realtime.TripModifications.SelectedTrips)
      private static final com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips();
      }

      public static com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<SelectedTrips>
          PARSER = new com.google.protobuf.AbstractParser<SelectedTrips>() {
        @java.lang.Override
        public SelectedTrips parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<SelectedTrips> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<SelectedTrips> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public static final int SELECTED_TRIPS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips> selectedTrips_;
    /**
     * <pre>
     * A list of selected trips affected by this TripModifications.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips> getSelectedTripsList() {
      return selectedTrips_;
    }
    /**
     * <pre>
     * A list of selected trips affected by this TripModifications.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTripsOrBuilder> 
        getSelectedTripsOrBuilderList() {
      return selectedTrips_;
    }
    /**
     * <pre>
     * A list of selected trips affected by this TripModifications.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
     */
    @java.lang.Override
    public int getSelectedTripsCount() {
      return selectedTrips_.size();
    }
    /**
     * <pre>
     * A list of selected trips affected by this TripModifications.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips getSelectedTrips(int index) {
      return selectedTrips_.get(index);
    }
    /**
     * <pre>
     * A list of selected trips affected by this TripModifications.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTripsOrBuilder getSelectedTripsOrBuilder(
        int index) {
      return selectedTrips_.get(index);
    }

    public static final int START_TIMES_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList startTimes_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * A list of start times in the real-time trip descriptor for the trip_id defined in trip_ids. 
     * Useful to target multiple departures of a trip_id in a frequency-based trip.
     * </pre>
     *
     * <code>repeated string start_times = 2;</code>
     * @return A list containing the startTimes.
     */
    public com.google.protobuf.ProtocolStringList
        getStartTimesList() {
      return startTimes_;
    }
    /**
     * <pre>
     * A list of start times in the real-time trip descriptor for the trip_id defined in trip_ids. 
     * Useful to target multiple departures of a trip_id in a frequency-based trip.
     * </pre>
     *
     * <code>repeated string start_times = 2;</code>
     * @return The count of startTimes.
     */
    public int getStartTimesCount() {
      return startTimes_.size();
    }
    /**
     * <pre>
     * A list of start times in the real-time trip descriptor for the trip_id defined in trip_ids. 
     * Useful to target multiple departures of a trip_id in a frequency-based trip.
     * </pre>
     *
     * <code>repeated string start_times = 2;</code>
     * @param index The index of the element to return.
     * @return The startTimes at the given index.
     */
    public java.lang.String getStartTimes(int index) {
      return startTimes_.get(index);
    }
    /**
     * <pre>
     * A list of start times in the real-time trip descriptor for the trip_id defined in trip_ids. 
     * Useful to target multiple departures of a trip_id in a frequency-based trip.
     * </pre>
     *
     * <code>repeated string start_times = 2;</code>
     * @param index The index of the value to return.
     * @return The bytes of the startTimes at the given index.
     */
    public com.google.protobuf.ByteString
        getStartTimesBytes(int index) {
      return startTimes_.getByteString(index);
    }

    public static final int SERVICE_DATES_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList serviceDates_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * Dates on which the modifications occurs, in the YYYYMMDD format. Producers SHOULD only transmit detours occurring within the next week.
     * The dates provided should not be used as user-facing information, if a user-facing start and end date needs to be provided, they can be provided in the linked service alert with `service_alert_id`
     * </pre>
     *
     * <code>repeated string service_dates = 3;</code>
     * @return A list containing the serviceDates.
     */
    public com.google.protobuf.ProtocolStringList
        getServiceDatesList() {
      return serviceDates_;
    }
    /**
     * <pre>
     * Dates on which the modifications occurs, in the YYYYMMDD format. Producers SHOULD only transmit detours occurring within the next week.
     * The dates provided should not be used as user-facing information, if a user-facing start and end date needs to be provided, they can be provided in the linked service alert with `service_alert_id`
     * </pre>
     *
     * <code>repeated string service_dates = 3;</code>
     * @return The count of serviceDates.
     */
    public int getServiceDatesCount() {
      return serviceDates_.size();
    }
    /**
     * <pre>
     * Dates on which the modifications occurs, in the YYYYMMDD format. Producers SHOULD only transmit detours occurring within the next week.
     * The dates provided should not be used as user-facing information, if a user-facing start and end date needs to be provided, they can be provided in the linked service alert with `service_alert_id`
     * </pre>
     *
     * <code>repeated string service_dates = 3;</code>
     * @param index The index of the element to return.
     * @return The serviceDates at the given index.
     */
    public java.lang.String getServiceDates(int index) {
      return serviceDates_.get(index);
    }
    /**
     * <pre>
     * Dates on which the modifications occurs, in the YYYYMMDD format. Producers SHOULD only transmit detours occurring within the next week.
     * The dates provided should not be used as user-facing information, if a user-facing start and end date needs to be provided, they can be provided in the linked service alert with `service_alert_id`
     * </pre>
     *
     * <code>repeated string service_dates = 3;</code>
     * @param index The index of the value to return.
     * @return The bytes of the serviceDates at the given index.
     */
    public com.google.protobuf.ByteString
        getServiceDatesBytes(int index) {
      return serviceDates_.getByteString(index);
    }

    public static final int MODIFICATIONS_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private java.util.List<com.google.transit.realtime.GtfsRealtime.TripModifications.Modification> modifications_;
    /**
     * <pre>
     * A list of modifications to apply to the affected trips. 
     * </pre>
     *
     * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.transit.realtime.GtfsRealtime.TripModifications.Modification> getModificationsList() {
      return modifications_;
    }
    /**
     * <pre>
     * A list of modifications to apply to the affected trips. 
     * </pre>
     *
     * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
     */
    @java.lang.Override
    public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.TripModifications.ModificationOrBuilder> 
        getModificationsOrBuilderList() {
      return modifications_;
    }
    /**
     * <pre>
     * A list of modifications to apply to the affected trips. 
     * </pre>
     *
     * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
     */
    @java.lang.Override
    public int getModificationsCount() {
      return modifications_.size();
    }
    /**
     * <pre>
     * A list of modifications to apply to the affected trips. 
     * </pre>
     *
     * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripModifications.Modification getModifications(int index) {
      return modifications_.get(index);
    }
    /**
     * <pre>
     * A list of modifications to apply to the affected trips. 
     * </pre>
     *
     * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
     */
    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripModifications.ModificationOrBuilder getModificationsOrBuilder(
        int index) {
      return modifications_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      for (int i = 0; i < getSelectedTripsCount(); i++) {
        if (!getSelectedTrips(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      for (int i = 0; i < getModificationsCount(); i++) {
        if (!getModifications(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (!extensionsAreInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessage
        .ExtendableMessage.ExtensionSerializer
          extensionWriter = newExtensionSerializer();
      for (int i = 0; i < selectedTrips_.size(); i++) {
        output.writeMessage(1, selectedTrips_.get(i));
      }
      for (int i = 0; i < startTimes_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, startTimes_.getRaw(i));
      }
      for (int i = 0; i < serviceDates_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, serviceDates_.getRaw(i));
      }
      for (int i = 0; i < modifications_.size(); i++) {
        output.writeMessage(4, modifications_.get(i));
      }
      extensionWriter.writeUntil(10000, output);
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < selectedTrips_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, selectedTrips_.get(i));
      }
      {
        int dataSize = 0;
        for (int i = 0; i < startTimes_.size(); i++) {
          dataSize += computeStringSizeNoTag(startTimes_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getStartTimesList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < serviceDates_.size(); i++) {
          dataSize += computeStringSizeNoTag(serviceDates_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getServiceDatesList().size();
      }
      for (int i = 0; i < modifications_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, modifications_.get(i));
      }
      size += extensionsSerializedSize();
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.TripModifications)) {
        return super.equals(obj);
      }
      com.google.transit.realtime.GtfsRealtime.TripModifications other = (com.google.transit.realtime.GtfsRealtime.TripModifications) obj;

      if (!getSelectedTripsList()
          .equals(other.getSelectedTripsList())) return false;
      if (!getStartTimesList()
          .equals(other.getStartTimesList())) return false;
      if (!getServiceDatesList()
          .equals(other.getServiceDatesList())) return false;
      if (!getModificationsList()
          .equals(other.getModificationsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      if (!getExtensionFields().equals(other.getExtensionFields()))
        return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getSelectedTripsCount() > 0) {
        hash = (37 * hash) + SELECTED_TRIPS_FIELD_NUMBER;
        hash = (53 * hash) + getSelectedTripsList().hashCode();
      }
      if (getStartTimesCount() > 0) {
        hash = (37 * hash) + START_TIMES_FIELD_NUMBER;
        hash = (53 * hash) + getStartTimesList().hashCode();
      }
      if (getServiceDatesCount() > 0) {
        hash = (37 * hash) + SERVICE_DATES_FIELD_NUMBER;
        hash = (53 * hash) + getServiceDatesList().hashCode();
      }
      if (getModificationsCount() > 0) {
        hash = (37 * hash) + MODIFICATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getModificationsList().hashCode();
      }
      hash = hashFields(hash, getExtensionFields());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.transit.realtime.GtfsRealtime.TripModifications parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripModifications parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripModifications parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripModifications parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripModifications parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripModifications parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripModifications parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripModifications parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.transit.realtime.GtfsRealtime.TripModifications parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.transit.realtime.GtfsRealtime.TripModifications parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripModifications parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripModifications parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.TripModifications prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.TripModifications}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
          com.google.transit.realtime.GtfsRealtime.TripModifications, Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_realtime.TripModifications)
        com.google.transit.realtime.GtfsRealtime.TripModificationsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripModifications_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripModifications_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.TripModifications.class, com.google.transit.realtime.GtfsRealtime.TripModifications.Builder.class);
      }

      // Construct using com.google.transit.realtime.GtfsRealtime.TripModifications.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (selectedTripsBuilder_ == null) {
          selectedTrips_ = java.util.Collections.emptyList();
        } else {
          selectedTrips_ = null;
          selectedTripsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        startTimes_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        serviceDates_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        if (modificationsBuilder_ == null) {
          modifications_ = java.util.Collections.emptyList();
        } else {
          modifications_ = null;
          modificationsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_TripModifications_descriptor;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TripModifications getDefaultInstanceForType() {
        return com.google.transit.realtime.GtfsRealtime.TripModifications.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TripModifications build() {
        com.google.transit.realtime.GtfsRealtime.TripModifications result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.TripModifications buildPartial() {
        com.google.transit.realtime.GtfsRealtime.TripModifications result = new com.google.transit.realtime.GtfsRealtime.TripModifications(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(com.google.transit.realtime.GtfsRealtime.TripModifications result) {
        if (selectedTripsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            selectedTrips_ = java.util.Collections.unmodifiableList(selectedTrips_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.selectedTrips_ = selectedTrips_;
        } else {
          result.selectedTrips_ = selectedTripsBuilder_.build();
        }
        if (modificationsBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0)) {
            modifications_ = java.util.Collections.unmodifiableList(modifications_);
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.modifications_ = modifications_;
        } else {
          result.modifications_ = modificationsBuilder_.build();
        }
      }

      private void buildPartial0(com.google.transit.realtime.GtfsRealtime.TripModifications result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          startTimes_.makeImmutable();
          result.startTimes_ = startTimes_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          serviceDates_.makeImmutable();
          result.serviceDates_ = serviceDates_;
        }
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.transit.realtime.GtfsRealtime.TripModifications) {
          return mergeFrom((com.google.transit.realtime.GtfsRealtime.TripModifications)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.TripModifications other) {
        if (other == com.google.transit.realtime.GtfsRealtime.TripModifications.getDefaultInstance()) return this;
        if (selectedTripsBuilder_ == null) {
          if (!other.selectedTrips_.isEmpty()) {
            if (selectedTrips_.isEmpty()) {
              selectedTrips_ = other.selectedTrips_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureSelectedTripsIsMutable();
              selectedTrips_.addAll(other.selectedTrips_);
            }
            onChanged();
          }
        } else {
          if (!other.selectedTrips_.isEmpty()) {
            if (selectedTripsBuilder_.isEmpty()) {
              selectedTripsBuilder_.dispose();
              selectedTripsBuilder_ = null;
              selectedTrips_ = other.selectedTrips_;
              bitField0_ = (bitField0_ & ~0x00000001);
              selectedTripsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getSelectedTripsFieldBuilder() : null;
            } else {
              selectedTripsBuilder_.addAllMessages(other.selectedTrips_);
            }
          }
        }
        if (!other.startTimes_.isEmpty()) {
          if (startTimes_.isEmpty()) {
            startTimes_ = other.startTimes_;
            bitField0_ |= 0x00000002;
          } else {
            ensureStartTimesIsMutable();
            startTimes_.addAll(other.startTimes_);
          }
          onChanged();
        }
        if (!other.serviceDates_.isEmpty()) {
          if (serviceDates_.isEmpty()) {
            serviceDates_ = other.serviceDates_;
            bitField0_ |= 0x00000004;
          } else {
            ensureServiceDatesIsMutable();
            serviceDates_.addAll(other.serviceDates_);
          }
          onChanged();
        }
        if (modificationsBuilder_ == null) {
          if (!other.modifications_.isEmpty()) {
            if (modifications_.isEmpty()) {
              modifications_ = other.modifications_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureModificationsIsMutable();
              modifications_.addAll(other.modifications_);
            }
            onChanged();
          }
        } else {
          if (!other.modifications_.isEmpty()) {
            if (modificationsBuilder_.isEmpty()) {
              modificationsBuilder_.dispose();
              modificationsBuilder_ = null;
              modifications_ = other.modifications_;
              bitField0_ = (bitField0_ & ~0x00000008);
              modificationsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getModificationsFieldBuilder() : null;
            } else {
              modificationsBuilder_.addAllMessages(other.modifications_);
            }
          }
        }
        this.mergeExtensionFields(other);
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        for (int i = 0; i < getSelectedTripsCount(); i++) {
          if (!getSelectedTrips(i).isInitialized()) {
            return false;
          }
        }
        for (int i = 0; i < getModificationsCount(); i++) {
          if (!getModifications(i).isInitialized()) {
            return false;
          }
        }
        if (!extensionsAreInitialized()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips m =
                    input.readMessage(
                        com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips.parser(),
                        extensionRegistry);
                if (selectedTripsBuilder_ == null) {
                  ensureSelectedTripsIsMutable();
                  selectedTrips_.add(m);
                } else {
                  selectedTripsBuilder_.addMessage(m);
                }
                break;
              } // case 10
              case 18: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureStartTimesIsMutable();
                startTimes_.add(bs);
                break;
              } // case 18
              case 26: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureServiceDatesIsMutable();
                serviceDates_.add(bs);
                break;
              } // case 26
              case 34: {
                com.google.transit.realtime.GtfsRealtime.TripModifications.Modification m =
                    input.readMessage(
                        com.google.transit.realtime.GtfsRealtime.TripModifications.Modification.parser(),
                        extensionRegistry);
                if (modificationsBuilder_ == null) {
                  ensureModificationsIsMutable();
                  modifications_.add(m);
                } else {
                  modificationsBuilder_.addMessage(m);
                }
                break;
              } // case 34
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips> selectedTrips_ =
        java.util.Collections.emptyList();
      private void ensureSelectedTripsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          selectedTrips_ = new java.util.ArrayList<com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips>(selectedTrips_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips, com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips.Builder, com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTripsOrBuilder> selectedTripsBuilder_;

      /**
       * <pre>
       * A list of selected trips affected by this TripModifications.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips> getSelectedTripsList() {
        if (selectedTripsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(selectedTrips_);
        } else {
          return selectedTripsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * A list of selected trips affected by this TripModifications.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
       */
      public int getSelectedTripsCount() {
        if (selectedTripsBuilder_ == null) {
          return selectedTrips_.size();
        } else {
          return selectedTripsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * A list of selected trips affected by this TripModifications.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips getSelectedTrips(int index) {
        if (selectedTripsBuilder_ == null) {
          return selectedTrips_.get(index);
        } else {
          return selectedTripsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * A list of selected trips affected by this TripModifications.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
       */
      public Builder setSelectedTrips(
          int index, com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips value) {
        if (selectedTripsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSelectedTripsIsMutable();
          selectedTrips_.set(index, value);
          onChanged();
        } else {
          selectedTripsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of selected trips affected by this TripModifications.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
       */
      public Builder setSelectedTrips(
          int index, com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips.Builder builderForValue) {
        if (selectedTripsBuilder_ == null) {
          ensureSelectedTripsIsMutable();
          selectedTrips_.set(index, builderForValue.build());
          onChanged();
        } else {
          selectedTripsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of selected trips affected by this TripModifications.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
       */
      public Builder addSelectedTrips(com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips value) {
        if (selectedTripsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSelectedTripsIsMutable();
          selectedTrips_.add(value);
          onChanged();
        } else {
          selectedTripsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of selected trips affected by this TripModifications.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
       */
      public Builder addSelectedTrips(
          int index, com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips value) {
        if (selectedTripsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSelectedTripsIsMutable();
          selectedTrips_.add(index, value);
          onChanged();
        } else {
          selectedTripsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of selected trips affected by this TripModifications.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
       */
      public Builder addSelectedTrips(
          com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips.Builder builderForValue) {
        if (selectedTripsBuilder_ == null) {
          ensureSelectedTripsIsMutable();
          selectedTrips_.add(builderForValue.build());
          onChanged();
        } else {
          selectedTripsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of selected trips affected by this TripModifications.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
       */
      public Builder addSelectedTrips(
          int index, com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips.Builder builderForValue) {
        if (selectedTripsBuilder_ == null) {
          ensureSelectedTripsIsMutable();
          selectedTrips_.add(index, builderForValue.build());
          onChanged();
        } else {
          selectedTripsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of selected trips affected by this TripModifications.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
       */
      public Builder addAllSelectedTrips(
          java.lang.Iterable<? extends com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips> values) {
        if (selectedTripsBuilder_ == null) {
          ensureSelectedTripsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, selectedTrips_);
          onChanged();
        } else {
          selectedTripsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * A list of selected trips affected by this TripModifications.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
       */
      public Builder clearSelectedTrips() {
        if (selectedTripsBuilder_ == null) {
          selectedTrips_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          selectedTripsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * A list of selected trips affected by this TripModifications.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
       */
      public Builder removeSelectedTrips(int index) {
        if (selectedTripsBuilder_ == null) {
          ensureSelectedTripsIsMutable();
          selectedTrips_.remove(index);
          onChanged();
        } else {
          selectedTripsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * A list of selected trips affected by this TripModifications.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips.Builder getSelectedTripsBuilder(
          int index) {
        return getSelectedTripsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * A list of selected trips affected by this TripModifications.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTripsOrBuilder getSelectedTripsOrBuilder(
          int index) {
        if (selectedTripsBuilder_ == null) {
          return selectedTrips_.get(index);  } else {
          return selectedTripsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * A list of selected trips affected by this TripModifications.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
       */
      public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTripsOrBuilder> 
           getSelectedTripsOrBuilderList() {
        if (selectedTripsBuilder_ != null) {
          return selectedTripsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(selectedTrips_);
        }
      }
      /**
       * <pre>
       * A list of selected trips affected by this TripModifications.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips.Builder addSelectedTripsBuilder() {
        return getSelectedTripsFieldBuilder().addBuilder(
            com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips.getDefaultInstance());
      }
      /**
       * <pre>
       * A list of selected trips affected by this TripModifications.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips.Builder addSelectedTripsBuilder(
          int index) {
        return getSelectedTripsFieldBuilder().addBuilder(
            index, com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips.getDefaultInstance());
      }
      /**
       * <pre>
       * A list of selected trips affected by this TripModifications.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips.Builder> 
           getSelectedTripsBuilderList() {
        return getSelectedTripsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips, com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips.Builder, com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTripsOrBuilder> 
          getSelectedTripsFieldBuilder() {
        if (selectedTripsBuilder_ == null) {
          selectedTripsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips, com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTrips.Builder, com.google.transit.realtime.GtfsRealtime.TripModifications.SelectedTripsOrBuilder>(
                  selectedTrips_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          selectedTrips_ = null;
        }
        return selectedTripsBuilder_;
      }

      private com.google.protobuf.LazyStringArrayList startTimes_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureStartTimesIsMutable() {
        if (!startTimes_.isModifiable()) {
          startTimes_ = new com.google.protobuf.LazyStringArrayList(startTimes_);
        }
        bitField0_ |= 0x00000002;
      }
      /**
       * <pre>
       * A list of start times in the real-time trip descriptor for the trip_id defined in trip_ids. 
       * Useful to target multiple departures of a trip_id in a frequency-based trip.
       * </pre>
       *
       * <code>repeated string start_times = 2;</code>
       * @return A list containing the startTimes.
       */
      public com.google.protobuf.ProtocolStringList
          getStartTimesList() {
        startTimes_.makeImmutable();
        return startTimes_;
      }
      /**
       * <pre>
       * A list of start times in the real-time trip descriptor for the trip_id defined in trip_ids. 
       * Useful to target multiple departures of a trip_id in a frequency-based trip.
       * </pre>
       *
       * <code>repeated string start_times = 2;</code>
       * @return The count of startTimes.
       */
      public int getStartTimesCount() {
        return startTimes_.size();
      }
      /**
       * <pre>
       * A list of start times in the real-time trip descriptor for the trip_id defined in trip_ids. 
       * Useful to target multiple departures of a trip_id in a frequency-based trip.
       * </pre>
       *
       * <code>repeated string start_times = 2;</code>
       * @param index The index of the element to return.
       * @return The startTimes at the given index.
       */
      public java.lang.String getStartTimes(int index) {
        return startTimes_.get(index);
      }
      /**
       * <pre>
       * A list of start times in the real-time trip descriptor for the trip_id defined in trip_ids. 
       * Useful to target multiple departures of a trip_id in a frequency-based trip.
       * </pre>
       *
       * <code>repeated string start_times = 2;</code>
       * @param index The index of the value to return.
       * @return The bytes of the startTimes at the given index.
       */
      public com.google.protobuf.ByteString
          getStartTimesBytes(int index) {
        return startTimes_.getByteString(index);
      }
      /**
       * <pre>
       * A list of start times in the real-time trip descriptor for the trip_id defined in trip_ids. 
       * Useful to target multiple departures of a trip_id in a frequency-based trip.
       * </pre>
       *
       * <code>repeated string start_times = 2;</code>
       * @param index The index to set the value at.
       * @param value The startTimes to set.
       * @return This builder for chaining.
       */
      public Builder setStartTimes(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureStartTimesIsMutable();
        startTimes_.set(index, value);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of start times in the real-time trip descriptor for the trip_id defined in trip_ids. 
       * Useful to target multiple departures of a trip_id in a frequency-based trip.
       * </pre>
       *
       * <code>repeated string start_times = 2;</code>
       * @param value The startTimes to add.
       * @return This builder for chaining.
       */
      public Builder addStartTimes(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureStartTimesIsMutable();
        startTimes_.add(value);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of start times in the real-time trip descriptor for the trip_id defined in trip_ids. 
       * Useful to target multiple departures of a trip_id in a frequency-based trip.
       * </pre>
       *
       * <code>repeated string start_times = 2;</code>
       * @param values The startTimes to add.
       * @return This builder for chaining.
       */
      public Builder addAllStartTimes(
          java.lang.Iterable<java.lang.String> values) {
        ensureStartTimesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, startTimes_);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of start times in the real-time trip descriptor for the trip_id defined in trip_ids. 
       * Useful to target multiple departures of a trip_id in a frequency-based trip.
       * </pre>
       *
       * <code>repeated string start_times = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearStartTimes() {
        startTimes_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000002);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of start times in the real-time trip descriptor for the trip_id defined in trip_ids. 
       * Useful to target multiple departures of a trip_id in a frequency-based trip.
       * </pre>
       *
       * <code>repeated string start_times = 2;</code>
       * @param value The bytes of the startTimes to add.
       * @return This builder for chaining.
       */
      public Builder addStartTimesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureStartTimesIsMutable();
        startTimes_.add(value);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList serviceDates_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureServiceDatesIsMutable() {
        if (!serviceDates_.isModifiable()) {
          serviceDates_ = new com.google.protobuf.LazyStringArrayList(serviceDates_);
        }
        bitField0_ |= 0x00000004;
      }
      /**
       * <pre>
       * Dates on which the modifications occurs, in the YYYYMMDD format. Producers SHOULD only transmit detours occurring within the next week.
       * The dates provided should not be used as user-facing information, if a user-facing start and end date needs to be provided, they can be provided in the linked service alert with `service_alert_id`
       * </pre>
       *
       * <code>repeated string service_dates = 3;</code>
       * @return A list containing the serviceDates.
       */
      public com.google.protobuf.ProtocolStringList
          getServiceDatesList() {
        serviceDates_.makeImmutable();
        return serviceDates_;
      }
      /**
       * <pre>
       * Dates on which the modifications occurs, in the YYYYMMDD format. Producers SHOULD only transmit detours occurring within the next week.
       * The dates provided should not be used as user-facing information, if a user-facing start and end date needs to be provided, they can be provided in the linked service alert with `service_alert_id`
       * </pre>
       *
       * <code>repeated string service_dates = 3;</code>
       * @return The count of serviceDates.
       */
      public int getServiceDatesCount() {
        return serviceDates_.size();
      }
      /**
       * <pre>
       * Dates on which the modifications occurs, in the YYYYMMDD format. Producers SHOULD only transmit detours occurring within the next week.
       * The dates provided should not be used as user-facing information, if a user-facing start and end date needs to be provided, they can be provided in the linked service alert with `service_alert_id`
       * </pre>
       *
       * <code>repeated string service_dates = 3;</code>
       * @param index The index of the element to return.
       * @return The serviceDates at the given index.
       */
      public java.lang.String getServiceDates(int index) {
        return serviceDates_.get(index);
      }
      /**
       * <pre>
       * Dates on which the modifications occurs, in the YYYYMMDD format. Producers SHOULD only transmit detours occurring within the next week.
       * The dates provided should not be used as user-facing information, if a user-facing start and end date needs to be provided, they can be provided in the linked service alert with `service_alert_id`
       * </pre>
       *
       * <code>repeated string service_dates = 3;</code>
       * @param index The index of the value to return.
       * @return The bytes of the serviceDates at the given index.
       */
      public com.google.protobuf.ByteString
          getServiceDatesBytes(int index) {
        return serviceDates_.getByteString(index);
      }
      /**
       * <pre>
       * Dates on which the modifications occurs, in the YYYYMMDD format. Producers SHOULD only transmit detours occurring within the next week.
       * The dates provided should not be used as user-facing information, if a user-facing start and end date needs to be provided, they can be provided in the linked service alert with `service_alert_id`
       * </pre>
       *
       * <code>repeated string service_dates = 3;</code>
       * @param index The index to set the value at.
       * @param value The serviceDates to set.
       * @return This builder for chaining.
       */
      public Builder setServiceDates(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureServiceDatesIsMutable();
        serviceDates_.set(index, value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Dates on which the modifications occurs, in the YYYYMMDD format. Producers SHOULD only transmit detours occurring within the next week.
       * The dates provided should not be used as user-facing information, if a user-facing start and end date needs to be provided, they can be provided in the linked service alert with `service_alert_id`
       * </pre>
       *
       * <code>repeated string service_dates = 3;</code>
       * @param value The serviceDates to add.
       * @return This builder for chaining.
       */
      public Builder addServiceDates(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureServiceDatesIsMutable();
        serviceDates_.add(value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Dates on which the modifications occurs, in the YYYYMMDD format. Producers SHOULD only transmit detours occurring within the next week.
       * The dates provided should not be used as user-facing information, if a user-facing start and end date needs to be provided, they can be provided in the linked service alert with `service_alert_id`
       * </pre>
       *
       * <code>repeated string service_dates = 3;</code>
       * @param values The serviceDates to add.
       * @return This builder for chaining.
       */
      public Builder addAllServiceDates(
          java.lang.Iterable<java.lang.String> values) {
        ensureServiceDatesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, serviceDates_);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Dates on which the modifications occurs, in the YYYYMMDD format. Producers SHOULD only transmit detours occurring within the next week.
       * The dates provided should not be used as user-facing information, if a user-facing start and end date needs to be provided, they can be provided in the linked service alert with `service_alert_id`
       * </pre>
       *
       * <code>repeated string service_dates = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearServiceDates() {
        serviceDates_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000004);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Dates on which the modifications occurs, in the YYYYMMDD format. Producers SHOULD only transmit detours occurring within the next week.
       * The dates provided should not be used as user-facing information, if a user-facing start and end date needs to be provided, they can be provided in the linked service alert with `service_alert_id`
       * </pre>
       *
       * <code>repeated string service_dates = 3;</code>
       * @param value The bytes of the serviceDates to add.
       * @return This builder for chaining.
       */
      public Builder addServiceDatesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureServiceDatesIsMutable();
        serviceDates_.add(value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private java.util.List<com.google.transit.realtime.GtfsRealtime.TripModifications.Modification> modifications_ =
        java.util.Collections.emptyList();
      private void ensureModificationsIsMutable() {
        if (!((bitField0_ & 0x00000008) != 0)) {
          modifications_ = new java.util.ArrayList<com.google.transit.realtime.GtfsRealtime.TripModifications.Modification>(modifications_);
          bitField0_ |= 0x00000008;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TripModifications.Modification, com.google.transit.realtime.GtfsRealtime.TripModifications.Modification.Builder, com.google.transit.realtime.GtfsRealtime.TripModifications.ModificationOrBuilder> modificationsBuilder_;

      /**
       * <pre>
       * A list of modifications to apply to the affected trips. 
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.TripModifications.Modification> getModificationsList() {
        if (modificationsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(modifications_);
        } else {
          return modificationsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * A list of modifications to apply to the affected trips. 
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
       */
      public int getModificationsCount() {
        if (modificationsBuilder_ == null) {
          return modifications_.size();
        } else {
          return modificationsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * A list of modifications to apply to the affected trips. 
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripModifications.Modification getModifications(int index) {
        if (modificationsBuilder_ == null) {
          return modifications_.get(index);
        } else {
          return modificationsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * A list of modifications to apply to the affected trips. 
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
       */
      public Builder setModifications(
          int index, com.google.transit.realtime.GtfsRealtime.TripModifications.Modification value) {
        if (modificationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureModificationsIsMutable();
          modifications_.set(index, value);
          onChanged();
        } else {
          modificationsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of modifications to apply to the affected trips. 
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
       */
      public Builder setModifications(
          int index, com.google.transit.realtime.GtfsRealtime.TripModifications.Modification.Builder builderForValue) {
        if (modificationsBuilder_ == null) {
          ensureModificationsIsMutable();
          modifications_.set(index, builderForValue.build());
          onChanged();
        } else {
          modificationsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of modifications to apply to the affected trips. 
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
       */
      public Builder addModifications(com.google.transit.realtime.GtfsRealtime.TripModifications.Modification value) {
        if (modificationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureModificationsIsMutable();
          modifications_.add(value);
          onChanged();
        } else {
          modificationsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of modifications to apply to the affected trips. 
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
       */
      public Builder addModifications(
          int index, com.google.transit.realtime.GtfsRealtime.TripModifications.Modification value) {
        if (modificationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureModificationsIsMutable();
          modifications_.add(index, value);
          onChanged();
        } else {
          modificationsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of modifications to apply to the affected trips. 
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
       */
      public Builder addModifications(
          com.google.transit.realtime.GtfsRealtime.TripModifications.Modification.Builder builderForValue) {
        if (modificationsBuilder_ == null) {
          ensureModificationsIsMutable();
          modifications_.add(builderForValue.build());
          onChanged();
        } else {
          modificationsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of modifications to apply to the affected trips. 
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
       */
      public Builder addModifications(
          int index, com.google.transit.realtime.GtfsRealtime.TripModifications.Modification.Builder builderForValue) {
        if (modificationsBuilder_ == null) {
          ensureModificationsIsMutable();
          modifications_.add(index, builderForValue.build());
          onChanged();
        } else {
          modificationsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of modifications to apply to the affected trips. 
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
       */
      public Builder addAllModifications(
          java.lang.Iterable<? extends com.google.transit.realtime.GtfsRealtime.TripModifications.Modification> values) {
        if (modificationsBuilder_ == null) {
          ensureModificationsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, modifications_);
          onChanged();
        } else {
          modificationsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * A list of modifications to apply to the affected trips. 
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
       */
      public Builder clearModifications() {
        if (modificationsBuilder_ == null) {
          modifications_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
        } else {
          modificationsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * A list of modifications to apply to the affected trips. 
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
       */
      public Builder removeModifications(int index) {
        if (modificationsBuilder_ == null) {
          ensureModificationsIsMutable();
          modifications_.remove(index);
          onChanged();
        } else {
          modificationsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * A list of modifications to apply to the affected trips. 
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripModifications.Modification.Builder getModificationsBuilder(
          int index) {
        return getModificationsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * A list of modifications to apply to the affected trips. 
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripModifications.ModificationOrBuilder getModificationsOrBuilder(
          int index) {
        if (modificationsBuilder_ == null) {
          return modifications_.get(index);  } else {
          return modificationsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * A list of modifications to apply to the affected trips. 
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
       */
      public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.TripModifications.ModificationOrBuilder> 
           getModificationsOrBuilderList() {
        if (modificationsBuilder_ != null) {
          return modificationsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(modifications_);
        }
      }
      /**
       * <pre>
       * A list of modifications to apply to the affected trips. 
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripModifications.Modification.Builder addModificationsBuilder() {
        return getModificationsFieldBuilder().addBuilder(
            com.google.transit.realtime.GtfsRealtime.TripModifications.Modification.getDefaultInstance());
      }
      /**
       * <pre>
       * A list of modifications to apply to the affected trips. 
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripModifications.Modification.Builder addModificationsBuilder(
          int index) {
        return getModificationsFieldBuilder().addBuilder(
            index, com.google.transit.realtime.GtfsRealtime.TripModifications.Modification.getDefaultInstance());
      }
      /**
       * <pre>
       * A list of modifications to apply to the affected trips. 
       * </pre>
       *
       * <code>repeated .transit_realtime.TripModifications.Modification modifications = 4;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.TripModifications.Modification.Builder> 
           getModificationsBuilderList() {
        return getModificationsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          com.google.transit.realtime.GtfsRealtime.TripModifications.Modification, com.google.transit.realtime.GtfsRealtime.TripModifications.Modification.Builder, com.google.transit.realtime.GtfsRealtime.TripModifications.ModificationOrBuilder> 
          getModificationsFieldBuilder() {
        if (modificationsBuilder_ == null) {
          modificationsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              com.google.transit.realtime.GtfsRealtime.TripModifications.Modification, com.google.transit.realtime.GtfsRealtime.TripModifications.Modification.Builder, com.google.transit.realtime.GtfsRealtime.TripModifications.ModificationOrBuilder>(
                  modifications_,
                  ((bitField0_ & 0x00000008) != 0),
                  getParentForChildren(),
                  isClean());
          modifications_ = null;
        }
        return modificationsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.TripModifications)
    }

    // @@protoc_insertion_point(class_scope:transit_realtime.TripModifications)
    private static final com.google.transit.realtime.GtfsRealtime.TripModifications DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.TripModifications();
    }

    public static com.google.transit.realtime.GtfsRealtime.TripModifications getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TripModifications>
        PARSER = new com.google.protobuf.AbstractParser<TripModifications>() {
      @java.lang.Override
      public TripModifications parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TripModifications> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TripModifications> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.TripModifications getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface StopSelectorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_realtime.StopSelector)
      com.google.protobuf.GeneratedMessage.
          ExtendableMessageOrBuilder<StopSelector> {

    /**
     * <pre>
     * Must be the same as in stop_times.txt in the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional uint32 stop_sequence = 1;</code>
     * @return Whether the stopSequence field is set.
     */
    boolean hasStopSequence();
    /**
     * <pre>
     * Must be the same as in stop_times.txt in the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional uint32 stop_sequence = 1;</code>
     * @return The stopSequence.
     */
    int getStopSequence();

    /**
     * <pre>
     * Must be the same as in stops.txt in the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional string stop_id = 2;</code>
     * @return Whether the stopId field is set.
     */
    boolean hasStopId();
    /**
     * <pre>
     * Must be the same as in stops.txt in the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional string stop_id = 2;</code>
     * @return The stopId.
     */
    java.lang.String getStopId();
    /**
     * <pre>
     * Must be the same as in stops.txt in the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional string stop_id = 2;</code>
     * @return The bytes for stopId.
     */
    com.google.protobuf.ByteString
        getStopIdBytes();
  }
  /**
   * <pre>
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   * Select a stop by stop sequence or by stop_id. At least one of the two values must be provided.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.StopSelector}
   */
  public static final class StopSelector extends
      com.google.protobuf.GeneratedMessage.ExtendableMessage<
        StopSelector> implements
      // @@protoc_insertion_point(message_implements:transit_realtime.StopSelector)
      StopSelectorOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 28,
        /* patch= */ 3,
        /* suffix= */ "",
        StopSelector.class.getName());
    }
    // Use StopSelector.newBuilder() to construct.
    private StopSelector(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.StopSelector, ?> builder) {
      super(builder);
    }
    private StopSelector() {
      stopId_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_StopSelector_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_StopSelector_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.transit.realtime.GtfsRealtime.StopSelector.class, com.google.transit.realtime.GtfsRealtime.StopSelector.Builder.class);
    }

    private int bitField0_;
    public static final int STOP_SEQUENCE_FIELD_NUMBER = 1;
    private int stopSequence_ = 0;
    /**
     * <pre>
     * Must be the same as in stop_times.txt in the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional uint32 stop_sequence = 1;</code>
     * @return Whether the stopSequence field is set.
     */
    @java.lang.Override
    public boolean hasStopSequence() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Must be the same as in stop_times.txt in the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional uint32 stop_sequence = 1;</code>
     * @return The stopSequence.
     */
    @java.lang.Override
    public int getStopSequence() {
      return stopSequence_;
    }

    public static final int STOP_ID_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object stopId_ = "";
    /**
     * <pre>
     * Must be the same as in stops.txt in the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional string stop_id = 2;</code>
     * @return Whether the stopId field is set.
     */
    @java.lang.Override
    public boolean hasStopId() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Must be the same as in stops.txt in the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional string stop_id = 2;</code>
     * @return The stopId.
     */
    @java.lang.Override
    public java.lang.String getStopId() {
      java.lang.Object ref = stopId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          stopId_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Must be the same as in stops.txt in the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional string stop_id = 2;</code>
     * @return The bytes for stopId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStopIdBytes() {
      java.lang.Object ref = stopId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        stopId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!extensionsAreInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessage
        .ExtendableMessage.ExtensionSerializer
          extensionWriter = newExtensionSerializer();
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt32(1, stopSequence_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, stopId_);
      }
      extensionWriter.writeUntil(10000, output);
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(1, stopSequence_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, stopId_);
      }
      size += extensionsSerializedSize();
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.StopSelector)) {
        return super.equals(obj);
      }
      com.google.transit.realtime.GtfsRealtime.StopSelector other = (com.google.transit.realtime.GtfsRealtime.StopSelector) obj;

      if (hasStopSequence() != other.hasStopSequence()) return false;
      if (hasStopSequence()) {
        if (getStopSequence()
            != other.getStopSequence()) return false;
      }
      if (hasStopId() != other.hasStopId()) return false;
      if (hasStopId()) {
        if (!getStopId()
            .equals(other.getStopId())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      if (!getExtensionFields().equals(other.getExtensionFields()))
        return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasStopSequence()) {
        hash = (37 * hash) + STOP_SEQUENCE_FIELD_NUMBER;
        hash = (53 * hash) + getStopSequence();
      }
      if (hasStopId()) {
        hash = (37 * hash) + STOP_ID_FIELD_NUMBER;
        hash = (53 * hash) + getStopId().hashCode();
      }
      hash = hashFields(hash, getExtensionFields());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.transit.realtime.GtfsRealtime.StopSelector parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.StopSelector parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.StopSelector parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.StopSelector parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.StopSelector parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.StopSelector parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.StopSelector parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.StopSelector parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.transit.realtime.GtfsRealtime.StopSelector parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.transit.realtime.GtfsRealtime.StopSelector parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.StopSelector parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.StopSelector parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.StopSelector prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * Select a stop by stop sequence or by stop_id. At least one of the two values must be provided.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.StopSelector}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
          com.google.transit.realtime.GtfsRealtime.StopSelector, Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_realtime.StopSelector)
        com.google.transit.realtime.GtfsRealtime.StopSelectorOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_StopSelector_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_StopSelector_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.StopSelector.class, com.google.transit.realtime.GtfsRealtime.StopSelector.Builder.class);
      }

      // Construct using com.google.transit.realtime.GtfsRealtime.StopSelector.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        stopSequence_ = 0;
        stopId_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_StopSelector_descriptor;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.StopSelector getDefaultInstanceForType() {
        return com.google.transit.realtime.GtfsRealtime.StopSelector.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.StopSelector build() {
        com.google.transit.realtime.GtfsRealtime.StopSelector result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.StopSelector buildPartial() {
        com.google.transit.realtime.GtfsRealtime.StopSelector result = new com.google.transit.realtime.GtfsRealtime.StopSelector(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.transit.realtime.GtfsRealtime.StopSelector result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.stopSequence_ = stopSequence_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.stopId_ = stopId_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.transit.realtime.GtfsRealtime.StopSelector) {
          return mergeFrom((com.google.transit.realtime.GtfsRealtime.StopSelector)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.StopSelector other) {
        if (other == com.google.transit.realtime.GtfsRealtime.StopSelector.getDefaultInstance()) return this;
        if (other.hasStopSequence()) {
          setStopSequence(other.getStopSequence());
        }
        if (other.hasStopId()) {
          stopId_ = other.stopId_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeExtensionFields(other);
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!extensionsAreInitialized()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                stopSequence_ = input.readUInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                stopId_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int stopSequence_ ;
      /**
       * <pre>
       * Must be the same as in stop_times.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional uint32 stop_sequence = 1;</code>
       * @return Whether the stopSequence field is set.
       */
      @java.lang.Override
      public boolean hasStopSequence() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Must be the same as in stop_times.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional uint32 stop_sequence = 1;</code>
       * @return The stopSequence.
       */
      @java.lang.Override
      public int getStopSequence() {
        return stopSequence_;
      }
      /**
       * <pre>
       * Must be the same as in stop_times.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional uint32 stop_sequence = 1;</code>
       * @param value The stopSequence to set.
       * @return This builder for chaining.
       */
      public Builder setStopSequence(int value) {

        stopSequence_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Must be the same as in stop_times.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional uint32 stop_sequence = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearStopSequence() {
        bitField0_ = (bitField0_ & ~0x00000001);
        stopSequence_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object stopId_ = "";
      /**
       * <pre>
       * Must be the same as in stops.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 2;</code>
       * @return Whether the stopId field is set.
       */
      public boolean hasStopId() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Must be the same as in stops.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 2;</code>
       * @return The stopId.
       */
      public java.lang.String getStopId() {
        java.lang.Object ref = stopId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            stopId_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Must be the same as in stops.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 2;</code>
       * @return The bytes for stopId.
       */
      public com.google.protobuf.ByteString
          getStopIdBytes() {
        java.lang.Object ref = stopId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          stopId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Must be the same as in stops.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 2;</code>
       * @param value The stopId to set.
       * @return This builder for chaining.
       */
      public Builder setStopId(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        stopId_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Must be the same as in stops.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearStopId() {
        stopId_ = getDefaultInstance().getStopId();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Must be the same as in stops.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 2;</code>
       * @param value The bytes for stopId to set.
       * @return This builder for chaining.
       */
      public Builder setStopIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        stopId_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.StopSelector)
    }

    // @@protoc_insertion_point(class_scope:transit_realtime.StopSelector)
    private static final com.google.transit.realtime.GtfsRealtime.StopSelector DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.StopSelector();
    }

    public static com.google.transit.realtime.GtfsRealtime.StopSelector getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<StopSelector>
        PARSER = new com.google.protobuf.AbstractParser<StopSelector>() {
      @java.lang.Override
      public StopSelector parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<StopSelector> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<StopSelector> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.StopSelector getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ReplacementStopOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_realtime.ReplacementStop)
      com.google.protobuf.GeneratedMessage.
          ExtendableMessageOrBuilder<ReplacementStop> {

    /**
     * <pre>
     * The difference in seconds between the arrival time at this stop and the arrival time at the reference stop. The reference stop is the stop prior to start_stop_selector. If the modification begins at the first stop of the trip, then the first stop of the trip is the reference stop.
     * This value MUST be monotonically increasing and may only be a negative number if the first stop of the original trip is the reference stop.
     * </pre>
     *
     * <code>optional int32 travel_time_to_stop = 1;</code>
     * @return Whether the travelTimeToStop field is set.
     */
    boolean hasTravelTimeToStop();
    /**
     * <pre>
     * The difference in seconds between the arrival time at this stop and the arrival time at the reference stop. The reference stop is the stop prior to start_stop_selector. If the modification begins at the first stop of the trip, then the first stop of the trip is the reference stop.
     * This value MUST be monotonically increasing and may only be a negative number if the first stop of the original trip is the reference stop.
     * </pre>
     *
     * <code>optional int32 travel_time_to_stop = 1;</code>
     * @return The travelTimeToStop.
     */
    int getTravelTimeToStop();

    /**
     * <pre>
     * The replacement stop ID which will now be visited by the trip. May refer to a new stop added using a GTFS-RT Stop message, or to an existing stop defined in the GTFS-Static feed’s stops.txt. The stop MUST have location_type=0 (routable stops).
     * </pre>
     *
     * <code>optional string stop_id = 2;</code>
     * @return Whether the stopId field is set.
     */
    boolean hasStopId();
    /**
     * <pre>
     * The replacement stop ID which will now be visited by the trip. May refer to a new stop added using a GTFS-RT Stop message, or to an existing stop defined in the GTFS-Static feed’s stops.txt. The stop MUST have location_type=0 (routable stops).
     * </pre>
     *
     * <code>optional string stop_id = 2;</code>
     * @return The stopId.
     */
    java.lang.String getStopId();
    /**
     * <pre>
     * The replacement stop ID which will now be visited by the trip. May refer to a new stop added using a GTFS-RT Stop message, or to an existing stop defined in the GTFS-Static feed’s stops.txt. The stop MUST have location_type=0 (routable stops).
     * </pre>
     *
     * <code>optional string stop_id = 2;</code>
     * @return The bytes for stopId.
     */
    com.google.protobuf.ByteString
        getStopIdBytes();
  }
  /**
   * <pre>
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.ReplacementStop}
   */
  public static final class ReplacementStop extends
      com.google.protobuf.GeneratedMessage.ExtendableMessage<
        ReplacementStop> implements
      // @@protoc_insertion_point(message_implements:transit_realtime.ReplacementStop)
      ReplacementStopOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 28,
        /* patch= */ 3,
        /* suffix= */ "",
        ReplacementStop.class.getName());
    }
    // Use ReplacementStop.newBuilder() to construct.
    private ReplacementStop(com.google.protobuf.GeneratedMessage.ExtendableBuilder<com.google.transit.realtime.GtfsRealtime.ReplacementStop, ?> builder) {
      super(builder);
    }
    private ReplacementStop() {
      stopId_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_ReplacementStop_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_ReplacementStop_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.transit.realtime.GtfsRealtime.ReplacementStop.class, com.google.transit.realtime.GtfsRealtime.ReplacementStop.Builder.class);
    }

    private int bitField0_;
    public static final int TRAVEL_TIME_TO_STOP_FIELD_NUMBER = 1;
    private int travelTimeToStop_ = 0;
    /**
     * <pre>
     * The difference in seconds between the arrival time at this stop and the arrival time at the reference stop. The reference stop is the stop prior to start_stop_selector. If the modification begins at the first stop of the trip, then the first stop of the trip is the reference stop.
     * This value MUST be monotonically increasing and may only be a negative number if the first stop of the original trip is the reference stop.
     * </pre>
     *
     * <code>optional int32 travel_time_to_stop = 1;</code>
     * @return Whether the travelTimeToStop field is set.
     */
    @java.lang.Override
    public boolean hasTravelTimeToStop() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The difference in seconds between the arrival time at this stop and the arrival time at the reference stop. The reference stop is the stop prior to start_stop_selector. If the modification begins at the first stop of the trip, then the first stop of the trip is the reference stop.
     * This value MUST be monotonically increasing and may only be a negative number if the first stop of the original trip is the reference stop.
     * </pre>
     *
     * <code>optional int32 travel_time_to_stop = 1;</code>
     * @return The travelTimeToStop.
     */
    @java.lang.Override
    public int getTravelTimeToStop() {
      return travelTimeToStop_;
    }

    public static final int STOP_ID_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object stopId_ = "";
    /**
     * <pre>
     * The replacement stop ID which will now be visited by the trip. May refer to a new stop added using a GTFS-RT Stop message, or to an existing stop defined in the GTFS-Static feed’s stops.txt. The stop MUST have location_type=0 (routable stops).
     * </pre>
     *
     * <code>optional string stop_id = 2;</code>
     * @return Whether the stopId field is set.
     */
    @java.lang.Override
    public boolean hasStopId() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The replacement stop ID which will now be visited by the trip. May refer to a new stop added using a GTFS-RT Stop message, or to an existing stop defined in the GTFS-Static feed’s stops.txt. The stop MUST have location_type=0 (routable stops).
     * </pre>
     *
     * <code>optional string stop_id = 2;</code>
     * @return The stopId.
     */
    @java.lang.Override
    public java.lang.String getStopId() {
      java.lang.Object ref = stopId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          stopId_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The replacement stop ID which will now be visited by the trip. May refer to a new stop added using a GTFS-RT Stop message, or to an existing stop defined in the GTFS-Static feed’s stops.txt. The stop MUST have location_type=0 (routable stops).
     * </pre>
     *
     * <code>optional string stop_id = 2;</code>
     * @return The bytes for stopId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStopIdBytes() {
      java.lang.Object ref = stopId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        stopId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!extensionsAreInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessage
        .ExtendableMessage.ExtensionSerializer
          extensionWriter = newExtensionSerializer();
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt32(1, travelTimeToStop_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, stopId_);
      }
      extensionWriter.writeUntil(10000, output);
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, travelTimeToStop_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, stopId_);
      }
      size += extensionsSerializedSize();
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.transit.realtime.GtfsRealtime.ReplacementStop)) {
        return super.equals(obj);
      }
      com.google.transit.realtime.GtfsRealtime.ReplacementStop other = (com.google.transit.realtime.GtfsRealtime.ReplacementStop) obj;

      if (hasTravelTimeToStop() != other.hasTravelTimeToStop()) return false;
      if (hasTravelTimeToStop()) {
        if (getTravelTimeToStop()
            != other.getTravelTimeToStop()) return false;
      }
      if (hasStopId() != other.hasStopId()) return false;
      if (hasStopId()) {
        if (!getStopId()
            .equals(other.getStopId())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      if (!getExtensionFields().equals(other.getExtensionFields()))
        return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasTravelTimeToStop()) {
        hash = (37 * hash) + TRAVEL_TIME_TO_STOP_FIELD_NUMBER;
        hash = (53 * hash) + getTravelTimeToStop();
      }
      if (hasStopId()) {
        hash = (37 * hash) + STOP_ID_FIELD_NUMBER;
        hash = (53 * hash) + getStopId().hashCode();
      }
      hash = hashFields(hash, getExtensionFields());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.transit.realtime.GtfsRealtime.ReplacementStop parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.ReplacementStop parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.ReplacementStop parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.ReplacementStop parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.ReplacementStop parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.transit.realtime.GtfsRealtime.ReplacementStop parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.ReplacementStop parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.ReplacementStop parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.transit.realtime.GtfsRealtime.ReplacementStop parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.transit.realtime.GtfsRealtime.ReplacementStop parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.ReplacementStop parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.ReplacementStop parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.ReplacementStop prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.ReplacementStop}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
          com.google.transit.realtime.GtfsRealtime.ReplacementStop, Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_realtime.ReplacementStop)
        com.google.transit.realtime.GtfsRealtime.ReplacementStopOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_ReplacementStop_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_ReplacementStop_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.transit.realtime.GtfsRealtime.ReplacementStop.class, com.google.transit.realtime.GtfsRealtime.ReplacementStop.Builder.class);
      }

      // Construct using com.google.transit.realtime.GtfsRealtime.ReplacementStop.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        travelTimeToStop_ = 0;
        stopId_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.transit.realtime.GtfsRealtime.internal_static_transit_realtime_ReplacementStop_descriptor;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.ReplacementStop getDefaultInstanceForType() {
        return com.google.transit.realtime.GtfsRealtime.ReplacementStop.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.ReplacementStop build() {
        com.google.transit.realtime.GtfsRealtime.ReplacementStop result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.transit.realtime.GtfsRealtime.ReplacementStop buildPartial() {
        com.google.transit.realtime.GtfsRealtime.ReplacementStop result = new com.google.transit.realtime.GtfsRealtime.ReplacementStop(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.transit.realtime.GtfsRealtime.ReplacementStop result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.travelTimeToStop_ = travelTimeToStop_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.stopId_ = stopId_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.transit.realtime.GtfsRealtime.ReplacementStop) {
          return mergeFrom((com.google.transit.realtime.GtfsRealtime.ReplacementStop)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.transit.realtime.GtfsRealtime.ReplacementStop other) {
        if (other == com.google.transit.realtime.GtfsRealtime.ReplacementStop.getDefaultInstance()) return this;
        if (other.hasTravelTimeToStop()) {
          setTravelTimeToStop(other.getTravelTimeToStop());
        }
        if (other.hasStopId()) {
          stopId_ = other.stopId_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeExtensionFields(other);
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!extensionsAreInitialized()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                travelTimeToStop_ = input.readInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                stopId_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int travelTimeToStop_ ;
      /**
       * <pre>
       * The difference in seconds between the arrival time at this stop and the arrival time at the reference stop. The reference stop is the stop prior to start_stop_selector. If the modification begins at the first stop of the trip, then the first stop of the trip is the reference stop.
       * This value MUST be monotonically increasing and may only be a negative number if the first stop of the original trip is the reference stop.
       * </pre>
       *
       * <code>optional int32 travel_time_to_stop = 1;</code>
       * @return Whether the travelTimeToStop field is set.
       */
      @java.lang.Override
      public boolean hasTravelTimeToStop() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The difference in seconds between the arrival time at this stop and the arrival time at the reference stop. The reference stop is the stop prior to start_stop_selector. If the modification begins at the first stop of the trip, then the first stop of the trip is the reference stop.
       * This value MUST be monotonically increasing and may only be a negative number if the first stop of the original trip is the reference stop.
       * </pre>
       *
       * <code>optional int32 travel_time_to_stop = 1;</code>
       * @return The travelTimeToStop.
       */
      @java.lang.Override
      public int getTravelTimeToStop() {
        return travelTimeToStop_;
      }
      /**
       * <pre>
       * The difference in seconds between the arrival time at this stop and the arrival time at the reference stop. The reference stop is the stop prior to start_stop_selector. If the modification begins at the first stop of the trip, then the first stop of the trip is the reference stop.
       * This value MUST be monotonically increasing and may only be a negative number if the first stop of the original trip is the reference stop.
       * </pre>
       *
       * <code>optional int32 travel_time_to_stop = 1;</code>
       * @param value The travelTimeToStop to set.
       * @return This builder for chaining.
       */
      public Builder setTravelTimeToStop(int value) {

        travelTimeToStop_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The difference in seconds between the arrival time at this stop and the arrival time at the reference stop. The reference stop is the stop prior to start_stop_selector. If the modification begins at the first stop of the trip, then the first stop of the trip is the reference stop.
       * This value MUST be monotonically increasing and may only be a negative number if the first stop of the original trip is the reference stop.
       * </pre>
       *
       * <code>optional int32 travel_time_to_stop = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTravelTimeToStop() {
        bitField0_ = (bitField0_ & ~0x00000001);
        travelTimeToStop_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object stopId_ = "";
      /**
       * <pre>
       * The replacement stop ID which will now be visited by the trip. May refer to a new stop added using a GTFS-RT Stop message, or to an existing stop defined in the GTFS-Static feed’s stops.txt. The stop MUST have location_type=0 (routable stops).
       * </pre>
       *
       * <code>optional string stop_id = 2;</code>
       * @return Whether the stopId field is set.
       */
      public boolean hasStopId() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The replacement stop ID which will now be visited by the trip. May refer to a new stop added using a GTFS-RT Stop message, or to an existing stop defined in the GTFS-Static feed’s stops.txt. The stop MUST have location_type=0 (routable stops).
       * </pre>
       *
       * <code>optional string stop_id = 2;</code>
       * @return The stopId.
       */
      public java.lang.String getStopId() {
        java.lang.Object ref = stopId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            stopId_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The replacement stop ID which will now be visited by the trip. May refer to a new stop added using a GTFS-RT Stop message, or to an existing stop defined in the GTFS-Static feed’s stops.txt. The stop MUST have location_type=0 (routable stops).
       * </pre>
       *
       * <code>optional string stop_id = 2;</code>
       * @return The bytes for stopId.
       */
      public com.google.protobuf.ByteString
          getStopIdBytes() {
        java.lang.Object ref = stopId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          stopId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The replacement stop ID which will now be visited by the trip. May refer to a new stop added using a GTFS-RT Stop message, or to an existing stop defined in the GTFS-Static feed’s stops.txt. The stop MUST have location_type=0 (routable stops).
       * </pre>
       *
       * <code>optional string stop_id = 2;</code>
       * @param value The stopId to set.
       * @return This builder for chaining.
       */
      public Builder setStopId(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        stopId_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The replacement stop ID which will now be visited by the trip. May refer to a new stop added using a GTFS-RT Stop message, or to an existing stop defined in the GTFS-Static feed’s stops.txt. The stop MUST have location_type=0 (routable stops).
       * </pre>
       *
       * <code>optional string stop_id = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearStopId() {
        stopId_ = getDefaultInstance().getStopId();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The replacement stop ID which will now be visited by the trip. May refer to a new stop added using a GTFS-RT Stop message, or to an existing stop defined in the GTFS-Static feed’s stops.txt. The stop MUST have location_type=0 (routable stops).
       * </pre>
       *
       * <code>optional string stop_id = 2;</code>
       * @param value The bytes for stopId to set.
       * @return This builder for chaining.
       */
      public Builder setStopIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        stopId_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.ReplacementStop)
    }

    // @@protoc_insertion_point(class_scope:transit_realtime.ReplacementStop)
    private static final com.google.transit.realtime.GtfsRealtime.ReplacementStop DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.transit.realtime.GtfsRealtime.ReplacementStop();
    }

    public static com.google.transit.realtime.GtfsRealtime.ReplacementStop getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ReplacementStop>
        PARSER = new com.google.protobuf.AbstractParser<ReplacementStop>() {
      @java.lang.Override
      public ReplacementStop parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ReplacementStop> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ReplacementStop> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.transit.realtime.GtfsRealtime.ReplacementStop getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_FeedMessage_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_FeedMessage_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_FeedHeader_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_FeedHeader_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_FeedEntity_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_FeedEntity_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_TripUpdate_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_TripUpdate_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_TripUpdate_StopTimeEvent_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_TripUpdate_StopTimeEvent_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_TripUpdate_StopTimeUpdate_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_TripUpdate_StopTimeUpdate_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_TripUpdate_StopTimeUpdate_StopTimeProperties_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_TripUpdate_StopTimeUpdate_StopTimeProperties_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_TripUpdate_TripProperties_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_TripUpdate_TripProperties_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_VehiclePosition_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_VehiclePosition_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_VehiclePosition_CarriageDetails_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_VehiclePosition_CarriageDetails_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_Alert_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_Alert_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_TimeRange_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_TimeRange_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_Position_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_Position_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_TripDescriptor_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_TripDescriptor_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_TripDescriptor_ModifiedTripSelector_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_TripDescriptor_ModifiedTripSelector_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_VehicleDescriptor_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_VehicleDescriptor_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_EntitySelector_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_EntitySelector_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_TranslatedString_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_TranslatedString_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_TranslatedString_Translation_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_TranslatedString_Translation_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_TranslatedImage_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_TranslatedImage_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_TranslatedImage_LocalizedImage_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_TranslatedImage_LocalizedImage_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_Shape_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_Shape_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_Stop_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_Stop_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_TripModifications_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_TripModifications_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_TripModifications_Modification_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_TripModifications_Modification_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_TripModifications_SelectedTrips_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_TripModifications_SelectedTrips_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_StopSelector_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_StopSelector_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_realtime_ReplacementStop_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_transit_realtime_ReplacementStop_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\023gtfs-realtime.proto\022\020transit_realtime\"" +
      "y\n\013FeedMessage\022,\n\006header\030\001 \002(\0132\034.transit" +
      "_realtime.FeedHeader\022,\n\006entity\030\002 \003(\0132\034.t" +
      "ransit_realtime.FeedEntity*\006\010\350\007\020\320\017*\006\010\250F\020" +
      "\220N\"\355\001\n\nFeedHeader\022\035\n\025gtfs_realtime_versi" +
      "on\030\001 \002(\t\022Q\n\016incrementality\030\002 \001(\0162+.trans" +
      "it_realtime.FeedHeader.Incrementality:\014F" +
      "ULL_DATASET\022\021\n\ttimestamp\030\003 \001(\004\022\024\n\014feed_v" +
      "ersion\030\004 \001(\t\"4\n\016Incrementality\022\020\n\014FULL_D" +
      "ATASET\020\000\022\020\n\014DIFFERENTIAL\020\001*\006\010\350\007\020\320\017*\006\010\250F\020" +
      "\220N\"\341\002\n\nFeedEntity\022\n\n\002id\030\001 \002(\t\022\031\n\nis_dele" +
      "ted\030\002 \001(\010:\005false\0221\n\013trip_update\030\003 \001(\0132\034." +
      "transit_realtime.TripUpdate\0222\n\007vehicle\030\004" +
      " \001(\0132!.transit_realtime.VehiclePosition\022" +
      "&\n\005alert\030\005 \001(\0132\027.transit_realtime.Alert\022" +
      "&\n\005shape\030\006 \001(\0132\027.transit_realtime.Shape\022" +
      "$\n\004stop\030\007 \001(\0132\026.transit_realtime.Stop\022?\n" +
      "\022trip_modifications\030\010 \001(\0132#.transit_real" +
      "time.TripModifications*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"\353" +
      "\010\n\nTripUpdate\022.\n\004trip\030\001 \002(\0132 .transit_re" +
      "altime.TripDescriptor\0224\n\007vehicle\030\003 \001(\0132#" +
      ".transit_realtime.VehicleDescriptor\022E\n\020s" +
      "top_time_update\030\002 \003(\0132+.transit_realtime" +
      ".TripUpdate.StopTimeUpdate\022\021\n\ttimestamp\030" +
      "\004 \001(\004\022\r\n\005delay\030\005 \001(\005\022D\n\017trip_properties\030" +
      "\006 \001(\0132+.transit_realtime.TripUpdate.Trip" +
      "Properties\032Q\n\rStopTimeEvent\022\r\n\005delay\030\001 \001" +
      "(\005\022\014\n\004time\030\002 \001(\003\022\023\n\013uncertainty\030\003 \001(\005*\006\010" +
      "\350\007\020\320\017*\006\010\250F\020\220N\032\367\004\n\016StopTimeUpdate\022\025\n\rstop" +
      "_sequence\030\001 \001(\r\022\017\n\007stop_id\030\004 \001(\t\022;\n\007arri" +
      "val\030\002 \001(\0132*.transit_realtime.TripUpdate." +
      "StopTimeEvent\022=\n\tdeparture\030\003 \001(\0132*.trans" +
      "it_realtime.TripUpdate.StopTimeEvent\022U\n\032" +
      "departure_occupancy_status\030\007 \001(\01621.trans" +
      "it_realtime.VehiclePosition.OccupancySta" +
      "tus\022j\n\025schedule_relationship\030\005 \001(\0162@.tra" +
      "nsit_realtime.TripUpdate.StopTimeUpdate." +
      "ScheduleRelationship:\tSCHEDULED\022\\\n\024stop_" +
      "time_properties\030\006 \001(\0132>.transit_realtime" +
      ".TripUpdate.StopTimeUpdate.StopTimePrope" +
      "rties\032>\n\022StopTimeProperties\022\030\n\020assigned_" +
      "stop_id\030\001 \001(\t*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"P\n\024Schedul" +
      "eRelationship\022\r\n\tSCHEDULED\020\000\022\013\n\007SKIPPED\020" +
      "\001\022\013\n\007NO_DATA\020\002\022\017\n\013UNSCHEDULED\020\003*\006\010\350\007\020\320\017*" +
      "\006\010\250F\020\220N\032k\n\016TripProperties\022\017\n\007trip_id\030\001 \001" +
      "(\t\022\022\n\nstart_date\030\002 \001(\t\022\022\n\nstart_time\030\003 \001" +
      "(\t\022\020\n\010shape_id\030\004 \001(\t*\006\010\350\007\020\320\017*\006\010\250F\020\220N*\006\010\350" +
      "\007\020\320\017*\006\010\250F\020\220N\"\337\t\n\017VehiclePosition\022.\n\004trip" +
      "\030\001 \001(\0132 .transit_realtime.TripDescriptor" +
      "\0224\n\007vehicle\030\010 \001(\0132#.transit_realtime.Veh" +
      "icleDescriptor\022,\n\010position\030\002 \001(\0132\032.trans" +
      "it_realtime.Position\022\035\n\025current_stop_seq" +
      "uence\030\003 \001(\r\022\017\n\007stop_id\030\007 \001(\t\022Z\n\016current_" +
      "status\030\004 \001(\01623.transit_realtime.VehicleP" +
      "osition.VehicleStopStatus:\rIN_TRANSIT_TO" +
      "\022\021\n\ttimestamp\030\005 \001(\004\022K\n\020congestion_level\030" +
      "\006 \001(\01621.transit_realtime.VehiclePosition" +
      ".CongestionLevel\022K\n\020occupancy_status\030\t \001" +
      "(\01621.transit_realtime.VehiclePosition.Oc" +
      "cupancyStatus\022\034\n\024occupancy_percentage\030\n " +
      "\001(\r\022Q\n\026multi_carriage_details\030\013 \003(\01321.tr" +
      "ansit_realtime.VehiclePosition.CarriageD" +
      "etails\032\331\001\n\017CarriageDetails\022\n\n\002id\030\001 \001(\t\022\r" +
      "\n\005label\030\002 \001(\t\022^\n\020occupancy_status\030\003 \001(\0162" +
      "1.transit_realtime.VehiclePosition.Occup" +
      "ancyStatus:\021NO_DATA_AVAILABLE\022 \n\024occupan" +
      "cy_percentage\030\004 \001(\005:\002-1\022\031\n\021carriage_sequ" +
      "ence\030\005 \001(\r*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"G\n\021VehicleSto" +
      "pStatus\022\017\n\013INCOMING_AT\020\000\022\016\n\nSTOPPED_AT\020\001" +
      "\022\021\n\rIN_TRANSIT_TO\020\002\"}\n\017CongestionLevel\022\034" +
      "\n\030UNKNOWN_CONGESTION_LEVEL\020\000\022\024\n\020RUNNING_" +
      "SMOOTHLY\020\001\022\017\n\013STOP_AND_GO\020\002\022\016\n\nCONGESTIO" +
      "N\020\003\022\025\n\021SEVERE_CONGESTION\020\004\"\331\001\n\017Occupancy" +
      "Status\022\t\n\005EMPTY\020\000\022\030\n\024MANY_SEATS_AVAILABL" +
      "E\020\001\022\027\n\023FEW_SEATS_AVAILABLE\020\002\022\026\n\022STANDING" +
      "_ROOM_ONLY\020\003\022\036\n\032CRUSHED_STANDING_ROOM_ON" +
      "LY\020\004\022\010\n\004FULL\020\005\022\034\n\030NOT_ACCEPTING_PASSENGE" +
      "RS\020\006\022\025\n\021NO_DATA_AVAILABLE\020\007\022\021\n\rNOT_BOARD" +
      "ABLE\020\010*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"\353\n\n\005Alert\0222\n\racti" +
      "ve_period\030\001 \003(\0132\033.transit_realtime.TimeR" +
      "ange\0229\n\017informed_entity\030\005 \003(\0132 .transit_" +
      "realtime.EntitySelector\022;\n\005cause\030\006 \001(\0162\035" +
      ".transit_realtime.Alert.Cause:\rUNKNOWN_C" +
      "AUSE\022>\n\006effect\030\007 \001(\0162\036.transit_realtime." +
      "Alert.Effect:\016UNKNOWN_EFFECT\022/\n\003url\030\010 \001(" +
      "\0132\".transit_realtime.TranslatedString\0227\n" +
      "\013header_text\030\n \001(\0132\".transit_realtime.Tr" +
      "anslatedString\022<\n\020description_text\030\013 \001(\013" +
      "2\".transit_realtime.TranslatedString\022;\n\017" +
      "tts_header_text\030\014 \001(\0132\".transit_realtime" +
      ".TranslatedString\022@\n\024tts_description_tex" +
      "t\030\r \001(\0132\".transit_realtime.TranslatedStr" +
      "ing\022O\n\016severity_level\030\016 \001(\0162%.transit_re" +
      "altime.Alert.SeverityLevel:\020UNKNOWN_SEVE" +
      "RITY\0220\n\005image\030\017 \001(\0132!.transit_realtime.T" +
      "ranslatedImage\022B\n\026image_alternative_text" +
      "\030\020 \001(\0132\".transit_realtime.TranslatedStri" +
      "ng\0228\n\014cause_detail\030\021 \001(\0132\".transit_realt" +
      "ime.TranslatedString\0229\n\reffect_detail\030\022 " +
      "\001(\0132\".transit_realtime.TranslatedString\"" +
      "\330\001\n\005Cause\022\021\n\rUNKNOWN_CAUSE\020\001\022\017\n\013OTHER_CA" +
      "USE\020\002\022\025\n\021TECHNICAL_PROBLEM\020\003\022\n\n\006STRIKE\020\004" +
      "\022\021\n\rDEMONSTRATION\020\005\022\014\n\010ACCIDENT\020\006\022\013\n\007HOL" +
      "IDAY\020\007\022\013\n\007WEATHER\020\010\022\017\n\013MAINTENANCE\020\t\022\020\n\014" +
      "CONSTRUCTION\020\n\022\023\n\017POLICE_ACTIVITY\020\013\022\025\n\021M" +
      "EDICAL_EMERGENCY\020\014\"\335\001\n\006Effect\022\016\n\nNO_SERV" +
      "ICE\020\001\022\023\n\017REDUCED_SERVICE\020\002\022\026\n\022SIGNIFICAN" +
      "T_DELAYS\020\003\022\n\n\006DETOUR\020\004\022\026\n\022ADDITIONAL_SER" +
      "VICE\020\005\022\024\n\020MODIFIED_SERVICE\020\006\022\020\n\014OTHER_EF" +
      "FECT\020\007\022\022\n\016UNKNOWN_EFFECT\020\010\022\016\n\nSTOP_MOVED" +
      "\020\t\022\r\n\tNO_EFFECT\020\n\022\027\n\023ACCESSIBILITY_ISSUE" +
      "\020\013\"H\n\rSeverityLevel\022\024\n\020UNKNOWN_SEVERITY\020" +
      "\001\022\010\n\004INFO\020\002\022\013\n\007WARNING\020\003\022\n\n\006SEVERE\020\004*\006\010\350" +
      "\007\020\320\017*\006\010\250F\020\220N\"7\n\tTimeRange\022\r\n\005start\030\001 \001(\004" +
      "\022\013\n\003end\030\002 \001(\004*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"q\n\010Positio" +
      "n\022\020\n\010latitude\030\001 \002(\002\022\021\n\tlongitude\030\002 \002(\002\022\017" +
      "\n\007bearing\030\003 \001(\002\022\020\n\010odometer\030\004 \001(\001\022\r\n\005spe" +
      "ed\030\005 \001(\002*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"\256\004\n\016TripDescrip" +
      "tor\022\017\n\007trip_id\030\001 \001(\t\022\020\n\010route_id\030\005 \001(\t\022\024" +
      "\n\014direction_id\030\006 \001(\r\022\022\n\nstart_time\030\002 \001(\t" +
      "\022\022\n\nstart_date\030\003 \001(\t\022T\n\025schedule_relatio" +
      "nship\030\004 \001(\01625.transit_realtime.TripDescr" +
      "iptor.ScheduleRelationship\022L\n\rmodified_t" +
      "rip\030\007 \001(\01325.transit_realtime.TripDescrip" +
      "tor.ModifiedTripSelector\032\202\001\n\024ModifiedTri" +
      "pSelector\022\030\n\020modifications_id\030\001 \001(\t\022\030\n\020a" +
      "ffected_trip_id\030\002 \001(\t\022\022\n\nstart_time\030\003 \001(" +
      "\t\022\022\n\nstart_date\030\004 \001(\t*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"\201\001" +
      "\n\024ScheduleRelationship\022\r\n\tSCHEDULED\020\000\022\t\n" +
      "\005ADDED\020\001\022\017\n\013UNSCHEDULED\020\002\022\014\n\010CANCELED\020\003\022" +
      "\023\n\013REPLACEMENT\020\005\032\002\010\001\022\016\n\nDUPLICATED\020\006\022\013\n\007" +
      "DELETED\020\007*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"\243\002\n\021VehicleDes" +
      "criptor\022\n\n\002id\030\001 \001(\t\022\r\n\005label\030\002 \001(\t\022\025\n\rli" +
      "cense_plate\030\003 \001(\t\022a\n\025wheelchair_accessib" +
      "le\030\004 \001(\01628.transit_realtime.VehicleDescr" +
      "iptor.WheelchairAccessible:\010NO_VALUE\"i\n\024" +
      "WheelchairAccessible\022\014\n\010NO_VALUE\020\000\022\013\n\007UN" +
      "KNOWN\020\001\022\031\n\025WHEELCHAIR_ACCESSIBLE\020\002\022\033\n\027WH" +
      "EELCHAIR_INACCESSIBLE\020\003*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"" +
      "\260\001\n\016EntitySelector\022\021\n\tagency_id\030\001 \001(\t\022\020\n" +
      "\010route_id\030\002 \001(\t\022\022\n\nroute_type\030\003 \001(\005\022.\n\004t" +
      "rip\030\004 \001(\0132 .transit_realtime.TripDescrip" +
      "tor\022\017\n\007stop_id\030\005 \001(\t\022\024\n\014direction_id\030\006 \001" +
      "(\r*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"\246\001\n\020TranslatedString\022" +
      "C\n\013translation\030\001 \003(\0132..transit_realtime." +
      "TranslatedString.Translation\032=\n\013Translat" +
      "ion\022\014\n\004text\030\001 \002(\t\022\020\n\010language\030\002 \001(\t*\006\010\350\007" +
      "\020\320\017*\006\010\250F\020\220N*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"\301\001\n\017Translat" +
      "edImage\022I\n\017localized_image\030\001 \003(\01320.trans" +
      "it_realtime.TranslatedImage.LocalizedIma" +
      "ge\032S\n\016LocalizedImage\022\013\n\003url\030\001 \002(\t\022\022\n\nmed" +
      "ia_type\030\002 \002(\t\022\020\n\010language\030\003 \001(\t*\006\010\350\007\020\320\017*" +
      "\006\010\250F\020\220N*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"C\n\005Shape\022\020\n\010shap" +
      "e_id\030\001 \001(\t\022\030\n\020encoded_polyline\030\002 \001(\t*\006\010\350" +
      "\007\020\320\017*\006\010\250F\020\220N\"\204\005\n\004Stop\022\017\n\007stop_id\030\001 \001(\t\0225" +
      "\n\tstop_code\030\002 \001(\0132\".transit_realtime.Tra" +
      "nslatedString\0225\n\tstop_name\030\003 \001(\0132\".trans" +
      "it_realtime.TranslatedString\0229\n\rtts_stop" +
      "_name\030\004 \001(\0132\".transit_realtime.Translate" +
      "dString\0225\n\tstop_desc\030\005 \001(\0132\".transit_rea" +
      "ltime.TranslatedString\022\020\n\010stop_lat\030\006 \001(\002" +
      "\022\020\n\010stop_lon\030\007 \001(\002\022\017\n\007zone_id\030\010 \001(\t\0224\n\010s" +
      "top_url\030\t \001(\0132\".transit_realtime.Transla" +
      "tedString\022\026\n\016parent_station\030\013 \001(\t\022\025\n\rsto" +
      "p_timezone\030\014 \001(\t\022O\n\023wheelchair_boarding\030" +
      "\r \001(\0162).transit_realtime.Stop.Wheelchair" +
      "Boarding:\007UNKNOWN\022\020\n\010level_id\030\016 \001(\t\0229\n\rp" +
      "latform_code\030\017 \001(\0132\".transit_realtime.Tr" +
      "anslatedString\"C\n\022WheelchairBoarding\022\013\n\007" +
      "UNKNOWN\020\000\022\r\n\tAVAILABLE\020\001\022\021\n\rNOT_AVAILABL" +
      "E\020\002*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"\337\004\n\021TripModification" +
      "s\022I\n\016selected_trips\030\001 \003(\01321.transit_real" +
      "time.TripModifications.SelectedTrips\022\023\n\013" +
      "start_times\030\002 \003(\t\022\025\n\rservice_dates\030\003 \003(\t" +
      "\022G\n\rmodifications\030\004 \003(\01320.transit_realti" +
      "me.TripModifications.Modification\032\264\002\n\014Mo" +
      "dification\022;\n\023start_stop_selector\030\001 \001(\0132" +
      "\036.transit_realtime.StopSelector\0229\n\021end_s" +
      "top_selector\030\002 \001(\0132\036.transit_realtime.St" +
      "opSelector\022(\n\035propagated_modification_de" +
      "lay\030\003 \001(\005:\0010\022<\n\021replacement_stops\030\004 \003(\0132" +
      "!.transit_realtime.ReplacementStop\022\030\n\020se" +
      "rvice_alert_id\030\005 \001(\t\022\032\n\022last_modified_ti" +
      "me\030\006 \001(\004*\006\010\350\007\020\320\017*\006\010\250F\020\220N\032C\n\rSelectedTrip" +
      "s\022\020\n\010trip_ids\030\001 \003(\t\022\020\n\010shape_id\030\002 \001(\t*\006\010" +
      "\350\007\020\320\017*\006\010\250F\020\220N*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"F\n\014StopSel" +
      "ector\022\025\n\rstop_sequence\030\001 \001(\r\022\017\n\007stop_id\030" +
      "\002 \001(\t*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"O\n\017ReplacementStop" +
      "\022\033\n\023travel_time_to_stop\030\001 \001(\005\022\017\n\007stop_id" +
      "\030\002 \001(\t*\006\010\350\007\020\320\017*\006\010\250F\020\220NB\035\n\033com.google.tra" +
      "nsit.realtime"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_transit_realtime_FeedMessage_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_transit_realtime_FeedMessage_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_FeedMessage_descriptor,
        new java.lang.String[] { "Header", "Entity", });
    internal_static_transit_realtime_FeedHeader_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_transit_realtime_FeedHeader_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_FeedHeader_descriptor,
        new java.lang.String[] { "GtfsRealtimeVersion", "Incrementality", "Timestamp", "FeedVersion", });
    internal_static_transit_realtime_FeedEntity_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_transit_realtime_FeedEntity_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_FeedEntity_descriptor,
        new java.lang.String[] { "Id", "IsDeleted", "TripUpdate", "Vehicle", "Alert", "Shape", "Stop", "TripModifications", });
    internal_static_transit_realtime_TripUpdate_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_transit_realtime_TripUpdate_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_TripUpdate_descriptor,
        new java.lang.String[] { "Trip", "Vehicle", "StopTimeUpdate", "Timestamp", "Delay", "TripProperties", });
    internal_static_transit_realtime_TripUpdate_StopTimeEvent_descriptor =
      internal_static_transit_realtime_TripUpdate_descriptor.getNestedTypes().get(0);
    internal_static_transit_realtime_TripUpdate_StopTimeEvent_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_TripUpdate_StopTimeEvent_descriptor,
        new java.lang.String[] { "Delay", "Time", "Uncertainty", });
    internal_static_transit_realtime_TripUpdate_StopTimeUpdate_descriptor =
      internal_static_transit_realtime_TripUpdate_descriptor.getNestedTypes().get(1);
    internal_static_transit_realtime_TripUpdate_StopTimeUpdate_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_TripUpdate_StopTimeUpdate_descriptor,
        new java.lang.String[] { "StopSequence", "StopId", "Arrival", "Departure", "DepartureOccupancyStatus", "ScheduleRelationship", "StopTimeProperties", });
    internal_static_transit_realtime_TripUpdate_StopTimeUpdate_StopTimeProperties_descriptor =
      internal_static_transit_realtime_TripUpdate_StopTimeUpdate_descriptor.getNestedTypes().get(0);
    internal_static_transit_realtime_TripUpdate_StopTimeUpdate_StopTimeProperties_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_TripUpdate_StopTimeUpdate_StopTimeProperties_descriptor,
        new java.lang.String[] { "AssignedStopId", });
    internal_static_transit_realtime_TripUpdate_TripProperties_descriptor =
      internal_static_transit_realtime_TripUpdate_descriptor.getNestedTypes().get(2);
    internal_static_transit_realtime_TripUpdate_TripProperties_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_TripUpdate_TripProperties_descriptor,
        new java.lang.String[] { "TripId", "StartDate", "StartTime", "ShapeId", });
    internal_static_transit_realtime_VehiclePosition_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_transit_realtime_VehiclePosition_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_VehiclePosition_descriptor,
        new java.lang.String[] { "Trip", "Vehicle", "Position", "CurrentStopSequence", "StopId", "CurrentStatus", "Timestamp", "CongestionLevel", "OccupancyStatus", "OccupancyPercentage", "MultiCarriageDetails", });
    internal_static_transit_realtime_VehiclePosition_CarriageDetails_descriptor =
      internal_static_transit_realtime_VehiclePosition_descriptor.getNestedTypes().get(0);
    internal_static_transit_realtime_VehiclePosition_CarriageDetails_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_VehiclePosition_CarriageDetails_descriptor,
        new java.lang.String[] { "Id", "Label", "OccupancyStatus", "OccupancyPercentage", "CarriageSequence", });
    internal_static_transit_realtime_Alert_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_transit_realtime_Alert_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_Alert_descriptor,
        new java.lang.String[] { "ActivePeriod", "InformedEntity", "Cause", "Effect", "Url", "HeaderText", "DescriptionText", "TtsHeaderText", "TtsDescriptionText", "SeverityLevel", "Image", "ImageAlternativeText", "CauseDetail", "EffectDetail", });
    internal_static_transit_realtime_TimeRange_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_transit_realtime_TimeRange_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_TimeRange_descriptor,
        new java.lang.String[] { "Start", "End", });
    internal_static_transit_realtime_Position_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_transit_realtime_Position_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_Position_descriptor,
        new java.lang.String[] { "Latitude", "Longitude", "Bearing", "Odometer", "Speed", });
    internal_static_transit_realtime_TripDescriptor_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_transit_realtime_TripDescriptor_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_TripDescriptor_descriptor,
        new java.lang.String[] { "TripId", "RouteId", "DirectionId", "StartTime", "StartDate", "ScheduleRelationship", "ModifiedTrip", });
    internal_static_transit_realtime_TripDescriptor_ModifiedTripSelector_descriptor =
      internal_static_transit_realtime_TripDescriptor_descriptor.getNestedTypes().get(0);
    internal_static_transit_realtime_TripDescriptor_ModifiedTripSelector_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_TripDescriptor_ModifiedTripSelector_descriptor,
        new java.lang.String[] { "ModificationsId", "AffectedTripId", "StartTime", "StartDate", });
    internal_static_transit_realtime_VehicleDescriptor_descriptor =
      getDescriptor().getMessageTypes().get(9);
    internal_static_transit_realtime_VehicleDescriptor_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_VehicleDescriptor_descriptor,
        new java.lang.String[] { "Id", "Label", "LicensePlate", "WheelchairAccessible", });
    internal_static_transit_realtime_EntitySelector_descriptor =
      getDescriptor().getMessageTypes().get(10);
    internal_static_transit_realtime_EntitySelector_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_EntitySelector_descriptor,
        new java.lang.String[] { "AgencyId", "RouteId", "RouteType", "Trip", "StopId", "DirectionId", });
    internal_static_transit_realtime_TranslatedString_descriptor =
      getDescriptor().getMessageTypes().get(11);
    internal_static_transit_realtime_TranslatedString_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_TranslatedString_descriptor,
        new java.lang.String[] { "Translation", });
    internal_static_transit_realtime_TranslatedString_Translation_descriptor =
      internal_static_transit_realtime_TranslatedString_descriptor.getNestedTypes().get(0);
    internal_static_transit_realtime_TranslatedString_Translation_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_TranslatedString_Translation_descriptor,
        new java.lang.String[] { "Text", "Language", });
    internal_static_transit_realtime_TranslatedImage_descriptor =
      getDescriptor().getMessageTypes().get(12);
    internal_static_transit_realtime_TranslatedImage_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_TranslatedImage_descriptor,
        new java.lang.String[] { "LocalizedImage", });
    internal_static_transit_realtime_TranslatedImage_LocalizedImage_descriptor =
      internal_static_transit_realtime_TranslatedImage_descriptor.getNestedTypes().get(0);
    internal_static_transit_realtime_TranslatedImage_LocalizedImage_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_TranslatedImage_LocalizedImage_descriptor,
        new java.lang.String[] { "Url", "MediaType", "Language", });
    internal_static_transit_realtime_Shape_descriptor =
      getDescriptor().getMessageTypes().get(13);
    internal_static_transit_realtime_Shape_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_Shape_descriptor,
        new java.lang.String[] { "ShapeId", "EncodedPolyline", });
    internal_static_transit_realtime_Stop_descriptor =
      getDescriptor().getMessageTypes().get(14);
    internal_static_transit_realtime_Stop_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_Stop_descriptor,
        new java.lang.String[] { "StopId", "StopCode", "StopName", "TtsStopName", "StopDesc", "StopLat", "StopLon", "ZoneId", "StopUrl", "ParentStation", "StopTimezone", "WheelchairBoarding", "LevelId", "PlatformCode", });
    internal_static_transit_realtime_TripModifications_descriptor =
      getDescriptor().getMessageTypes().get(15);
    internal_static_transit_realtime_TripModifications_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_TripModifications_descriptor,
        new java.lang.String[] { "SelectedTrips", "StartTimes", "ServiceDates", "Modifications", });
    internal_static_transit_realtime_TripModifications_Modification_descriptor =
      internal_static_transit_realtime_TripModifications_descriptor.getNestedTypes().get(0);
    internal_static_transit_realtime_TripModifications_Modification_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_TripModifications_Modification_descriptor,
        new java.lang.String[] { "StartStopSelector", "EndStopSelector", "PropagatedModificationDelay", "ReplacementStops", "ServiceAlertId", "LastModifiedTime", });
    internal_static_transit_realtime_TripModifications_SelectedTrips_descriptor =
      internal_static_transit_realtime_TripModifications_descriptor.getNestedTypes().get(1);
    internal_static_transit_realtime_TripModifications_SelectedTrips_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_TripModifications_SelectedTrips_descriptor,
        new java.lang.String[] { "TripIds", "ShapeId", });
    internal_static_transit_realtime_StopSelector_descriptor =
      getDescriptor().getMessageTypes().get(16);
    internal_static_transit_realtime_StopSelector_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_StopSelector_descriptor,
        new java.lang.String[] { "StopSequence", "StopId", });
    internal_static_transit_realtime_ReplacementStop_descriptor =
      getDescriptor().getMessageTypes().get(17);
    internal_static_transit_realtime_ReplacementStop_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_transit_realtime_ReplacementStop_descriptor,
        new java.lang.String[] { "TravelTimeToStop", "StopId", });
    descriptor.resolveAllFeaturesImmutable();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
